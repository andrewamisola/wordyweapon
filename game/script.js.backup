// === DEMO MODE ===
// Full build (set to true to re-enable demo restrictions)
const IS_DEMO = false;

// === RESPONSIVE LAYOUT ===
// Game uses viewport-filling CSS grid layout (no fixed dimensions)
// These constants kept for canvas sizing reference
const GAME_WIDTH = 1920;
const GAME_HEIGHT = 1080;

// Detect if running in Electron (uses smart auto-scaling via setZoomFactor)
const IS_ELECTRON = typeof process !== 'undefined' && process.versions && process.versions.electron;

// === 136 BPM RHYTHMIC TIMING ===
const RHYTHM = {
  BEAT: 441.2,        // 1/4 note (ms)
  HALF: 220.6,        // 1/8 note (ms)
  QUARTER: 110.3,     // 1/16 note (ms)
  EIGHTH: 55.1,       // 1/32 note (ms)
  BAR: 1764.7         // 1 measure (ms)
};

// === BUG REPORTING SYSTEM ===
const ERROR_LOG = [];
const MAX_ERROR_LOG = 20;

// Capture errors globally
window.onerror = function(message, source, lineno, colno, error) {
  const errorInfo = {
    type: 'error',
    message: message,
    source: source ? source.split('/').pop() : 'unknown',
    line: lineno,
    col: colno,
    stack: error?.stack || 'No stack trace',
    timestamp: new Date().toISOString(),
    gameState: getGameStateSnapshot()
  };
  ERROR_LOG.push(errorInfo);
  if (ERROR_LOG.length > MAX_ERROR_LOG) ERROR_LOG.shift();
  showBugReportPrompt(errorInfo);
  return false; // Don't suppress the error
};

// Capture unhandled promise rejections
window.onunhandledrejection = function(event) {
  const errorInfo = {
    type: 'promise',
    message: event.reason?.message || String(event.reason),
    stack: event.reason?.stack || 'No stack trace',
    timestamp: new Date().toISOString(),
    gameState: getGameStateSnapshot()
  };
  ERROR_LOG.push(errorInfo);
  if (ERROR_LOG.length > MAX_ERROR_LOG) ERROR_LOG.shift();
  showBugReportPrompt(errorInfo);
};

// Get a snapshot of relevant game state for debugging
function getGameStateSnapshot() {
  try {
    return {
      roundIndex: S?.roundIndex,
      heroId: S?.heroId,
      gold: S?.gold,
      difficulty: S?.difficulty,
      talents: S?.talents?.slice(0, 10), // First 10 talents
      invCount: S?.inv?.length,
      selectedSlots: S?.sel ? Object.keys(S.sel).filter(k => S.sel[k]) : [],
      enemyId: S?.enemy?.id,
      enemyHP: S?.enemy?.hp,
      chapterBoss: S?.chapterBoss?.id,
      isMiniboss: S?.isMiniboss,
      version: '1.0.0-beta'
    };
  } catch (e) {
    return { error: 'Could not capture game state' };
  }
}

// Show bug report prompt when error occurs
function showBugReportPrompt(errorInfo) {
  // Don't spam - only show if modal doesn't exist
  if (document.getElementById('bug-report-modal')) return;

  const modal = document.createElement('div');
  modal.id = 'bug-report-modal';
  modal.style.cssText = `
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.85); z-index: 99999;
    display: flex; align-items: center; justify-content: center;
    font-family: 'EB Garamond', serif;
  `;

  const reportData = generateBugReport(errorInfo);

  modal.innerHTML = `
    <div style="background: #1f2937; border: 2px solid #ef4444; border-radius: 12px; padding: 24px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;">
      <h2 style="color: #ef4444; margin: 0 0 12px 0; font-size: 20px;">Something went wrong!</h2>
      <p style="color: #9ca3af; margin: 0 0 16px 0; font-size: 14px;">
        An error occurred. Help us fix it by sending a bug report.
      </p>
      <div style="background: #111827; border-radius: 8px; padding: 12px; margin-bottom: 16px; font-family: monospace; font-size: 11px; color: #f87171; max-height: 150px; overflow-y: auto; word-break: break-all;">
        ${errorInfo.message}
      </div>
      <textarea id="bug-report-text" readonly style="width: 100%; height: 120px; background: #111827; border: 1px solid #374151; border-radius: 8px; padding: 8px; color: #d1d5db; font-family: monospace; font-size: 10px; resize: none; margin-bottom: 12px;">${reportData}</textarea>
      <div style="display: flex; gap: 8px; flex-wrap: wrap;">
        <button id="bug-copy-btn" style="flex: 1; min-width: 100px; padding: 10px 16px; background: #3b82f6; border: none; border-radius: 6px; color: white; cursor: pointer; font-size: 14px;">Copy Report</button>
        <button id="bug-discord-btn" style="flex: 1; min-width: 100px; padding: 10px 16px; background: #5865f2; border: none; border-radius: 6px; color: white; cursor: pointer; font-size: 14px;">Discord</button>
        <button id="bug-x-btn" style="flex: 1; min-width: 100px; padding: 10px 16px; background: #000; border: 1px solid #333; border-radius: 6px; color: white; cursor: pointer; font-size: 14px;">ùïè</button>
        <button id="bug-dismiss-btn" style="flex: 1; min-width: 100px; padding: 10px 16px; background: #374151; border: none; border-radius: 6px; color: #9ca3af; cursor: pointer; font-size: 14px;">Dismiss</button>
      </div>
      <p style="color: #6b7280; margin: 12px 0 0 0; font-size: 11px; text-align: center;">
        No data is sent automatically. Copy the report and share it with us if you'd like help.
      </p>
    </div>
  `;

  document.body.appendChild(modal);

  document.getElementById('bug-copy-btn').onclick = () => {
    navigator.clipboard.writeText(reportData).then(() => {
      document.getElementById('bug-copy-btn').textContent = 'Copied!';
      setTimeout(() => {
        const btn = document.getElementById('bug-copy-btn');
        if (btn) btn.textContent = 'Copy Report';
      }, 2000);
    });
  };

  document.getElementById('bug-discord-btn').onclick = () => {
    window.open('https://discord.gg/Nn73SWvgQK', '_blank');
  };

  document.getElementById('bug-x-btn').onclick = () => {
    window.open('https://x.com/wordyweapon', '_blank');
  };

  document.getElementById('bug-dismiss-btn').onclick = () => {
    modal.remove();
  };

  // Allow clicking backdrop to dismiss
  modal.onclick = (e) => {
    if (e.target === modal) modal.remove();
  };
}

// Generate formatted bug report text
function generateBugReport(errorInfo) {
  const lines = [
    '=== WORDY WEAPON BUG REPORT ===',
    `Time: ${errorInfo.timestamp}`,
    `Type: ${errorInfo.type}`,
    `Error: ${errorInfo.message}`,
    errorInfo.source ? `File: ${errorInfo.source}:${errorInfo.line}:${errorInfo.col}` : '',
    '',
    '--- GAME STATE ---',
    `Round: ${errorInfo.gameState?.roundIndex || 'N/A'}`,
    `Hero: ${errorInfo.gameState?.heroId || 'N/A'}`,
    `Difficulty: ${['Apprentice', 'Adept', 'Master'][errorInfo.gameState?.difficulty] || 'N/A'}`,
    `Gold: ${errorInfo.gameState?.gold ?? 'N/A'}`,
    `Enemy: ${errorInfo.gameState?.enemyId || 'N/A'} (HP: ${errorInfo.gameState?.enemyHP || 'N/A'})`,
    `Boss: ${errorInfo.gameState?.chapterBoss || 'None'}`,
    `Slots: ${errorInfo.gameState?.selectedSlots?.join(', ') || 'None'}`,
    `Talents: ${errorInfo.gameState?.talents?.length || 0}`,
    `Inventory: ${errorInfo.gameState?.invCount || 0} words`,
    '',
    '--- STACK TRACE ---',
    errorInfo.stack || 'No stack trace available',
    '',
    '--- BROWSER ---',
    navigator.userAgent
  ].filter(line => line !== undefined);

  return lines.join('\n');
}

// Manual bug report (accessible from settings or console)
function openBugReport() {
  const errorInfo = {
    type: 'manual',
    message: 'User-initiated bug report',
    timestamp: new Date().toISOString(),
    gameState: getGameStateSnapshot()
  };
  showBugReportPrompt(errorInfo);
}
const DEMO_ROUND_LIMIT = 18;
const DEMO_HERO_LIMIT = 2; // Demo-only lock count; ignored for full build
const STEAM_WISHLIST_URL = 'https://store.steampowered.com/app/4248130';
const DISCORD_URL = 'https://discord.gg/wordyweapon';

// === CONSTANTS ===
const E={PHYS:0,POISON:1,FIRE:2,WATER:3,LIGHT:4,DARK:5,EARTH:6,LIGHTNING:7},
EN=["Physical","Poison","Fire","Water","Light","Dark","Earth","Lightning"],
EC=["#a0a0a0","#7ee04d","#ff6633","#4d99ff","#ffffa0","#9966cc","#996633","#ffff4d"],
T={T0:0,T1:1,T2:2,T3:3}, // Tier indices
TN=["T0","T1","T2","T3"], // Tier display names
TC=["tier-0","tier-1","tier-2","tier-3"], // Tier CSS classes
TYPE_ORDER={weapon:0,elemental:1,rarity:2};

// Helper to generate SVG icon HTML (replaces emoji)
function icon(name, size='') {
  const sizeClass = size ? ` ${size}` : '';
  return `<svg class="icon${sizeClass}"><use href="#icon-${name}"/></svg>`;
}

// Maximum inventory size to prevent hoarding too many words
// Increase inventory limit so players can hold more words
const INV_LIMIT=24;
// Cap how many consumables can be held at once to keep power in check
const CONSUMABLE_LIMIT=2;

// === INTEREST SYSTEM ===
// Interest is granted when leaving the shop (not on victory)
// Total cap: 30 gold
// Gold interest: +1 per 10 gold held (max +6 from 60g)
// Slot interest: +1 per empty inventory slot (max +24 from empty bank)
const INTEREST_CAP = 30;
const GOLD_INTEREST_CAP = 6;
const GOLD_PER_INTEREST = 10;

function calculateInterest() {
  const visibleInvCount = S.inv ? S.inv.filter(w => !w.hiddenInBank).length : 0;
  const emptySlots = Math.max(0, INV_LIMIT - visibleInvCount);
  const goldInterest = Math.min(GOLD_INTEREST_CAP, Math.floor((S.gold || 0) / GOLD_PER_INTEREST));
  const slotInterest = emptySlots; // +1 per empty slot
  const baseInterest = Math.min(INTEREST_CAP, goldInterest + slotInterest);
  // Apply difficulty multiplier to interest
  const interestMult = DIFF_INTEREST_MULT[S.difficulty || 0];
  const totalInterest = Math.floor(baseInterest * interestMult);
  return { goldInterest, slotInterest, totalInterest, emptySlots, interestMult };
}

// === BALATRO-STYLE DIFFICULTY SCALING ===
// Each 3-round block has: Small Blind (1.0√ó), Big Blind (1.5√ó), Boss (2.0√ó)
// Block base HP grows exponentially between blocks
//
// Adjusted for accessible start (40 HP R3 Boss) -> Steeper curve requiring skill tree upgrades
// Block 0 (Rounds 1-3): Base 20 √ó 2.0 multiplier = 40 HP Boss - comfortable for starting deck
// Block 5 (Rounds 16-18): Base 20 √ó 4.0^5 √ó 2.0 multiplier ‚âà 40,960 HP Boss - Chapter 2 finale

const BASE_HP_BLOCK0 = 20;   // Low starting point for comfortable early game
const BLOCK_GROWTH = 4.0;    // Balanced growth - closer to Balatro's scaling
const ROUND_MULTS = [1.0, 1.5, 2.0]; // Small blind, Big blind, Boss

// Difficulty system - voluntary challenge modifiers (blacksmithing ranks)
const DIFFICULTY = {
  APPRENTICE: 0,
  ADEPT: 1,
  MASTER: 2
};
const DIFF_NAMES = ['Apprentice', 'Adept', 'Master'];
const DIFF_HP_MULT = [1.0, 1.5, 2.0];      // Enemy HP multiplier
const DIFF_SKILL_MULT = [1.0, 1.0, 1.0];   // Skill tree always full (that's the point!)
const DIFF_INTEREST_MULT = [1.0, 1.0, 1.0];  // Interest unchanged by difficulty
const DIFF_PRICE_MULT = [1.0, 1.25, 1.5];  // Shop price multiplier (Adept +25%, Master +50%)

// Calculate enemy HP based on round number using block-based pacing
// Block index = Math.floor((round - 1) / 3)
// Position in block = (round - 1) % 3 (0=small, 1=big, 2=boss)
function enemyHp(round) {
  const blockIndex = Math.floor((round - 1) / 3);
  const posInBlock = (round - 1) % 3;
  const baseForBlock = BASE_HP_BLOCK0 * Math.pow(BLOCK_GROWTH, blockIndex);
  const diffMult = DIFF_HP_MULT[S.difficulty || 0];
  return Math.floor(baseForBlock * ROUND_MULTS[posInBlock] * diffMult);
}
// HP progression (with 4.0√ó growth):
// Block 0 (R1-3): 20, 30, 40
// Block 1 (R4-6): 80, 120, 160
// Block 2 (R7-9): 320, 480, 640       <- Chapter 1 boss
// Block 3 (R10-12): 1,280, 1,920, 2,560
// Block 4 (R13-15): 5,120, 7,680, 10,240
// Block 5 (R16-18): 20,480, 30,720, 40,960 <- Chapter 2 boss (victory!)
// Block 6 (R19-21): 81,920, 122,880, 163,840  <- Endless mode
// Block 7 (R22-24): 327,680, 491,520, 655,360
// Block 8 (R25-27): 1.31M, 1.97M, 2.62M  <- Chapter 3 boss

// Get spark colors based on word's element (for anvil spark effects)
function getElementSparkColors(word) {
  if (!word || word.elem === undefined) {
    return ['#ff9933', '#ffcc00', '#ffaa44']; // Default blacksmith orange
  }
  const elemSparkColors = {
    [E.PHYS]: ['#a0a0a0', '#cccccc', '#888888'],
    [E.FIRE]: ['#ff6633', '#ff9933', '#ffcc00'],
    [E.WATER]: ['#4d99ff', '#66b3ff', '#99ccff'],
    [E.LIGHTNING]: ['#ffff4d', '#ffffff', '#ffffaa'],
    [E.EARTH]: ['#996633', '#cc9966', '#aa7744'],
    [E.POISON]: ['#7ee04d', '#99ff66', '#66cc33'],
    [E.LIGHT]: ['#ffffa0', '#ffffff', '#ffffcc'],
    [E.DARK]: ['#9966cc', '#bb88ee', '#7744aa']
  };
  return elemSparkColors[word.elem] || ['#ff9933', '#ffcc00', '#ffaa44'];
}

// Format large numbers with commas (e.g., 57000 ‚Üí "57,000")
function fmtBig(n) {
  return Math.floor(n).toLocaleString();
}

// === FX ENGINE (CANVAS) ===
const fxCanvas = document.getElementById('fx-canvas');
const fxCtx = fxCanvas ? fxCanvas.getContext('2d') : null;
// Fixed render dimensions - canvas always renders at 1080p regardless of screen size
let fxWidth = GAME_WIDTH;
let fxHeight = GAME_HEIGHT;

// Initialize canvas to match viewport dimensions (responsive layout)
function resizeFxCanvas() {
  if (!fxCanvas || !fxCtx) return;

  // Match the viewport dimensions for responsive layout
  fxWidth = window.innerWidth;
  fxHeight = window.innerHeight;

  fxCanvas.width = fxWidth;
  fxCanvas.height = fxHeight;

  // Reset transform to identity
  fxCtx.setTransform(1, 0, 0, 1, 0, 0);
}
window.addEventListener('resize', resizeFxCanvas);
if (fxCanvas) resizeFxCanvas();

// Active FX particles/animations
let fxAnimations = [];
let fxLoopRunning = false;

// Main FX Loop - only runs when there are animations
function fxLoop() {
  if (!fxCtx) { fxLoopRunning = false; return; }

  // Clear canvas first
  fxCtx.clearRect(0, 0, fxWidth, fxHeight);

  // Update and draw all animations, filter out dead ones
  fxAnimations = fxAnimations.filter(anim => anim.update(fxCtx));

  // Stop loop if no animations left
  if (fxAnimations.length === 0) {
    fxLoopRunning = false;
    return;
  }

  requestAnimationFrame(fxLoop);
}

// Start fx loop when needed
function startFxLoop() {
  if (!fxLoopRunning) {
    fxLoopRunning = true;
    requestAnimationFrame(fxLoop);
  }
}

// Helper to add animation and start loop
function addFxAnimation(anim) {
  fxAnimations.push(anim);
  startFxLoop();
}

// --- LIGHTNING EFFECT (CodePen inspired) ---
class LightningBolt {
  constructor(x1, y1, x2, y2, color) {
    this.segments = [];
    this.color = color || '#ffffff';
    this.life = 1.0;
    this.decay = 0.05;
    this.generate(x1, y1, x2, y2, 80); // 80 = displacement
  }

  generate(x1, y1, x2, y2, displace) {
    // Increased threshold from 2 to 5 = fewer segments = better performance
    if (displace < 5) {
      this.segments.push({ x1, y1, x2, y2 });
    } else {
      let midX = (x1 + x2) / 2;
      let midY = (y1 + y2) / 2;
      midX += (Math.random() - 0.5) * displace;
      midY += (Math.random() - 0.5) * displace;
      this.generate(x1, y1, midX, midY, displace / 2);
      this.generate(midX, midY, x2, y2, displace / 2);
    }
  }

  update(ctx) {
    if (this.life <= 0) return false;

    ctx.globalCompositeOperation = 'lighter';
    ctx.globalAlpha = this.life * (0.8 + Math.random() * 0.2);

    // Glow pass FIRST (only in normal FX mode) - reduced blur for performance
    if (!gfxSettings.lowFx) {
      ctx.shadowBlur = 8; // Reduced from 15
      ctx.shadowColor = this.color;
    }

    // Single stroke with glow applied
    ctx.beginPath();
    this.segments.forEach(s => {
      ctx.moveTo(s.x1, s.y1);
      ctx.lineTo(s.x2, s.y2);
    });
    ctx.strokeStyle = this.color;
    ctx.lineWidth = 2 + Math.random() * 2;
    ctx.stroke();

    // Reset shadow immediately
    ctx.shadowBlur = 0;

    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;

    this.life -= this.decay;
    return true;
  }
}

// --- METAL CLASH EFFECT (Physical element - impact sparks + shockwave) ---
class MetalClash {
  constructor(x1, y1, x2, y2, color) {
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
    this.color = color;
    this.progress = 0;
    this.speed = 0.12; // Fast travel
    this.sparks = [];
    this.rings = [];
    this.impacted = false;
  }

  update(ctx) {
    this.progress += this.speed;

    // Projectile phase - fast moving streak
    if (this.progress < 1.0) {
      const currentX = this.x1 + (this.x2 - this.x1) * this.progress;
      const currentY = this.y1 + (this.y2 - this.y1) * this.progress;
      const prevX = this.x1 + (this.x2 - this.x1) * Math.max(0, this.progress - 0.15);
      const prevY = this.y1 + (this.y2 - this.y1) * Math.max(0, this.progress - 0.15);

      // Draw streak
      ctx.beginPath();
      ctx.moveTo(prevX, prevY);
      ctx.lineTo(currentX, currentY);
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 3;
      ctx.globalAlpha = 0.9;
      ctx.stroke();

      // Inner gray line
      ctx.beginPath();
      ctx.moveTo(prevX, prevY);
      ctx.lineTo(currentX, currentY);
      ctx.strokeStyle = this.color;
      ctx.lineWidth = 1.5;
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // Impact - spawn sparks and shockwave rings
    if (this.progress >= 1.0 && !this.impacted) {
      this.impacted = true;

      // Create impact sparks (like metal hitting metal)
      for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2 + Math.random() * 0.3;
        const speed = 3 + Math.random() * 4;
        this.sparks.push({
          x: this.x2,
          y: this.y2,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 1.0,
          size: 2 + Math.random() * 2
        });
      }

      // Create shockwave rings
      for (let i = 0; i < 2; i++) {
        this.rings.push({
          x: this.x2,
          y: this.y2,
          radius: 5,
          maxRadius: 40 + i * 20,
          life: 1.0,
          speed: 3 + i
        });
      }
    }

    // Update and draw sparks
    ctx.fillStyle = '#cccccc';
    this.sparks.forEach(s => {
      s.x += s.vx;
      s.y += s.vy;
      s.vx *= 0.92;
      s.vy *= 0.92;
      s.vy += 0.1; // Slight gravity
      s.life -= 0.04;

      const radius = Math.max(0, s.size * s.life);
      if (radius > 0) {
        ctx.globalAlpha = Math.max(0, s.life);
        ctx.beginPath();
        ctx.arc(s.x, s.y, radius, 0, Math.PI * 2);
        ctx.fill();

        // White core
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(s.x, s.y, radius * 0.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#cccccc';
      }
    });

    // Update and draw shockwave rings
    this.rings.forEach(r => {
      r.radius += r.speed;
      r.life = 1 - (r.radius / r.maxRadius);

      if (r.life > 0) {
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2 * r.life;
        ctx.globalAlpha = r.life * 0.6;
        ctx.stroke();
      }
    });

    ctx.globalAlpha = 1;

    // Cleanup
    this.sparks = this.sparks.filter(s => s.life > 0);
    this.rings = this.rings.filter(r => r.life > 0);

    return this.sparks.length > 0 || this.rings.length > 0 || this.progress < 1.0;
  }
}

// --- PARTICLE TRAIL EFFECT (Fire, Water, etc.) ---
class ParticleTrail {
  constructor(x1, y1, x2, y2, type, color) {
    this.x = x1;
    this.y = y1;
    this.targetX = x2;
    this.targetY = y2;
    this.type = type; // 'fire', 'water', 'earth', etc.
    this.color = color;
    this.speed = 0.08; // Progress per frame (0 to 1)
    this.progress = 0;
    this.particles = [];
  }

  update(ctx) {
    this.progress += this.speed;
    const currentX = this.x + (this.targetX - this.x) * this.progress;
    const currentY = this.y + (this.targetY - this.y) * this.progress;

    // Spawn particles at current head position
    if (this.progress < 1.0) {
      for (let i = 0; i < 3; i++) {
        this.particles.push({
          x: currentX + (Math.random() - 0.5) * 10,
          y: currentY + (Math.random() - 0.5) * 10,
          vx: (Math.random() - 0.5) * 2,
          vy: (Math.random() - 0.5) * 2,
          life: 1.0,
          size: Math.random() * 4 + 2
        });
      }
    }

    // Update and draw particles
    ctx.fillStyle = this.color;
    this.particles.forEach(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.life -= 0.04;

      // Type specific behavior
      if (this.type === 'fire') { p.y -= 1; p.size *= 0.95; } // Rise and shrink
      if (this.type === 'water') { p.y += 0.5; } // Drip
      if (this.type === 'light' && !gfxSettings.lowFx) { ctx.shadowBlur = 10; ctx.shadowColor = '#fff'; }

      ctx.globalAlpha = Math.max(0, p.life);
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;

    // Cleanup dead particles
    this.particles = this.particles.filter(p => p.life > 0);

    return this.particles.length > 0 || this.progress < 1.0;
  }
}

// --- ENERGY BEAM EFFECT (Light/Dark elements) ---
// Intangible, ethereal effect - slow ease in/out with heavy blur
class EnergyBeam {
  constructor(x1, y1, x2, y2, color, isDark = false) {
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
    this.color = color;
    this.isDark = isDark;
    this.progress = 0;
    this.speed = 0.025; // Slower for ethereal feel
    this.phase = 'in'; // 'in', 'sustain', 'out'
    this.sustainTime = 0;
    this.maxSustain = 20; // Longer sustain
    this.opacity = 0;
  }

  // Ease in-out cubic for smooth transitions
  easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
  }

  update(ctx) {
    // Phase transitions with easing
    if (this.phase === 'in') {
      this.progress += this.speed;
      this.opacity = this.easeInOutCubic(Math.min(1, this.progress));
      if (this.progress >= 1) {
        this.phase = 'sustain';
        this.progress = 1;
        this.opacity = 1;
      }
    } else if (this.phase === 'sustain') {
      this.sustainTime++;
      if (this.sustainTime >= this.maxSustain) {
        this.phase = 'out';
        this.progress = 1;
      }
    } else if (this.phase === 'out') {
      this.progress -= this.speed;
      this.opacity = this.easeInOutCubic(Math.max(0, this.progress));
      if (this.progress <= 0) return false;
    }

    const dx = this.x2 - this.x1;
    const dy = this.y2 - this.y1;
    const length = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx);

    // Cone dimensions - softer edges
    const baseWidth = 12;
    const tipWidth = 50 * this.easeInOutCubic(Math.min(1, this.phase === 'in' ? this.progress : 1));

    ctx.save();
    ctx.translate(this.x1, this.y1);
    ctx.rotate(angle);

    // Create gradient - more ethereal/transparent
    const gradient = ctx.createLinearGradient(0, 0, length * this.easeInOutCubic(Math.min(1, this.phase === 'in' ? this.progress : 1)), 0);
    if (this.isDark) {
      gradient.addColorStop(0, 'rgba(60,20,80,0.6)');
      gradient.addColorStop(0.5, this.color);
      gradient.addColorStop(1, 'rgba(20,0,40,0.3)');
    } else {
      gradient.addColorStop(0, 'rgba(255,255,200,0.6)');
      gradient.addColorStop(0.5, this.color);
      gradient.addColorStop(1, 'rgba(255,255,255,0.3)');
    }

    ctx.globalAlpha = this.opacity * 0.7; // More transparent overall
    ctx.globalCompositeOperation = 'lighter';

    // Heavy blur for intangible feel (skip in low-FX mode)
    if (!gfxSettings.lowFx) {
      ctx.shadowBlur = 40;
      ctx.shadowColor = this.color;
    }

    // Draw cone shape
    const drawLength = length * this.easeInOutCubic(Math.min(1, this.phase === 'in' ? this.progress : 1));
    ctx.beginPath();
    ctx.moveTo(0, -baseWidth / 2);
    ctx.lineTo(drawLength, -tipWidth / 2);
    ctx.lineTo(drawLength, tipWidth / 2);
    ctx.lineTo(0, baseWidth / 2);
    ctx.closePath();
    ctx.fillStyle = gradient;
    ctx.fill();

    // Extra glow layer for more blur (skip in low-FX mode)
    if (!gfxSettings.lowFx) {
      ctx.shadowBlur = 60;
      ctx.globalAlpha = this.opacity * 0.4;
      ctx.fill();
    }

    ctx.restore();
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
    ctx.shadowBlur = 0;

    return true;
  }
}

// --- WATER STREAM EFFECT ---
class WaterStream {
  constructor(x1, y1, x2, y2, color) {
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
    this.color = color;
    this.progress = 0;
    this.speed = 0.06;
    this.particles = [];
    this.time = 0;
  }

  update(ctx) {
    this.progress += this.speed;
    this.time += 0.1;

    // Sine wave wobble for path
    const wobble = Math.sin(this.time * 3) * 15;

    const currentX = this.x1 + (this.x2 - this.x1) * Math.min(this.progress, 1);
    const currentY = this.y1 + (this.y2 - this.y1) * Math.min(this.progress, 1) + wobble;

    // Spawn teardrop particles
    if (this.progress < 1.0) {
      for (let i = 0; i < 4; i++) {
        this.particles.push({
          x: currentX + (Math.random() - 0.5) * 12,
          y: currentY + (Math.random() - 0.5) * 12,
          vx: (Math.random() - 0.5) * 1.5,
          vy: (Math.random() - 0.5) * 1.5,
          life: 1.0,
          size: Math.random() * 6 + 3,
          stretch: 1.2 + Math.random() * 0.5 // Teardrop stretch
        });
      }
    }

    // Update and draw particles
    ctx.fillStyle = this.color;
    this.particles.forEach(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.1; // Gravity drip
      p.life -= 0.035;

      ctx.globalAlpha = Math.max(0, p.life * 0.8);
      ctx.beginPath();
      // Draw teardrop/ellipse shape
      ctx.ellipse(p.x, p.y, p.size * 0.6, p.size * p.stretch, Math.PI / 4, 0, Math.PI * 2);
      ctx.fill();
    });

    // Add shimmer (skip in low-FX mode)
    if (!gfxSettings.lowFx) {
      ctx.shadowBlur = 8;
      ctx.shadowColor = '#88ccff';
      this.particles.slice(-5).forEach(p => {
        ctx.globalAlpha = Math.max(0, p.life * 0.3);
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * 0.4, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;

    this.particles = this.particles.filter(p => p.life > 0);
    return this.particles.length > 0 || this.progress < 1.0;
  }
}

// --- ROCK THROW EFFECT ---
class RockThrow {
  constructor(x1, y1, x2, y2, color) {
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
    this.color = color;
    this.progress = 0;
    this.speed = 0.04;
    this.rocks = [];
    this.spawned = false;
  }

  createRock() {
    const vertices = [];
    const numVertices = 3 + Math.floor(Math.random() * 3); // 3-5 vertices
    for (let i = 0; i < numVertices; i++) {
      const angle = (i / numVertices) * Math.PI * 2;
      const radius = 8 + Math.random() * 6;
      vertices.push({
        x: Math.cos(angle) * radius,
        y: Math.sin(angle) * radius
      });
    }
    return {
      vertices,
      rotation: 0,
      rotationSpeed: (Math.random() - 0.5) * 0.3,
      offsetX: (Math.random() - 0.5) * 30,
      offsetY: (Math.random() - 0.5) * 20,
      scale: 0.7 + Math.random() * 0.6
    };
  }

  update(ctx) {
    if (!this.spawned) {
      for (let i = 0; i < 3; i++) {
        this.rocks.push(this.createRock());
      }
      this.spawned = true;
    }

    this.progress += this.speed;

    // Stop immediately when done - don't draw final frame
    if (this.progress >= 1.0) {
      return false;
    }

    const t = this.progress;

    // Parabolic arc
    const arcHeight = -100 * Math.sin(t * Math.PI);
    const currentX = this.x1 + (this.x2 - this.x1) * t;
    const currentY = this.y1 + (this.y2 - this.y1) * t + arcHeight;

    ctx.fillStyle = this.color;
    ctx.strokeStyle = '#5a4020';
    ctx.lineWidth = 2;

    this.rocks.forEach(rock => {
      rock.rotation += rock.rotationSpeed;

      const rockX = currentX + rock.offsetX;
      const rockY = currentY + rock.offsetY;

      ctx.save();
      ctx.translate(rockX, rockY);
      ctx.rotate(rock.rotation);
      ctx.scale(rock.scale, rock.scale);

      // Draw irregular polygon
      ctx.beginPath();
      ctx.moveTo(rock.vertices[0].x, rock.vertices[0].y);
      for (let i = 1; i < rock.vertices.length; i++) {
        ctx.lineTo(rock.vertices[i].x, rock.vertices[i].y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      ctx.restore();
    });

    // Dust trail
    ctx.globalAlpha = 0.4;
    for (let i = 0; i < 3; i++) {
      const dustX = currentX + (Math.random() - 0.5) * 20;
      const dustY = currentY + 10 + Math.random() * 10;
      ctx.beginPath();
      ctx.arc(dustX, dustY, 2 + Math.random() * 3, 0, Math.PI * 2);
      ctx.fillStyle = '#8b7355';
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    return true;
  }
}

// --- PHYSICAL SLASH EFFECT ---
class PhysicalSlash {
  constructor(x1, y1, x2, y2, color) {
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
    this.color = color;
    this.progress = 0;
    this.speed = 0.25; // Fast animation
    this.speedLines = [];
  }

  update(ctx) {
    this.progress += this.speed;

    const dx = this.x2 - this.x1;
    const dy = this.y2 - this.y1;
    const angle = Math.atan2(dy, dx);
    const length = Math.sqrt(dx * dx + dy * dy);

    // Current position
    const t = Math.min(this.progress, 1);
    const currentX = this.x1 + dx * t;
    const currentY = this.y1 + dy * t;

    // Add speed lines behind
    if (this.progress < 1) {
      this.speedLines.push({
        x: currentX - Math.cos(angle) * 20,
        y: currentY - Math.sin(angle) * 20,
        length: 30 + Math.random() * 20,
        offset: (Math.random() - 0.5) * 30,
        life: 1
      });
    }

    ctx.save();

    // Draw speed lines
    ctx.strokeStyle = this.color;
    ctx.lineWidth = 2;
    this.speedLines.forEach(line => {
      line.life -= 0.1;
      ctx.globalAlpha = Math.max(0, line.life * 0.6);
      ctx.beginPath();
      const perpX = -Math.sin(angle) * line.offset;
      const perpY = Math.cos(angle) * line.offset;
      ctx.moveTo(line.x + perpX, line.y + perpY);
      ctx.lineTo(line.x + perpX - Math.cos(angle) * line.length,
                 line.y + perpY - Math.sin(angle) * line.length);
      ctx.stroke();
    });

    // Draw crescent slash
    if (this.progress < 1.2) {
      const slashOpacity = this.progress > 1 ? (1.2 - this.progress) * 5 : 1;
      ctx.globalAlpha = slashOpacity;
      ctx.translate(currentX, currentY);
      ctx.rotate(angle + Math.PI / 4);

      // Arc crescent
      ctx.beginPath();
      ctx.arc(0, 0, 25, -Math.PI * 0.3, Math.PI * 0.3);
      ctx.lineWidth = 4;
      ctx.strokeStyle = '#ffffff';
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(0, 0, 25, -Math.PI * 0.3, Math.PI * 0.3);
      ctx.lineWidth = 8;
      ctx.strokeStyle = this.color;
      ctx.globalAlpha = slashOpacity * 0.5;
      ctx.stroke();
    }

    ctx.restore();
    ctx.globalAlpha = 1;

    this.speedLines = this.speedLines.filter(l => l.life > 0);
    return this.progress < 1.2 || this.speedLines.length > 0;
  }
}

// --- WIND GUST EFFECT (Poison) ---
// Intangible, gaseous effect - slow ease in/out with heavy blur
class WindGust {
  constructor(x1, y1, x2, y2, color) {
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
    this.color = color;
    this.streaks = [];
    this.spawned = false;
    this.time = 0;
  }

  // Ease in-out cubic for smooth transitions
  easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
  }

  update(ctx) {
    this.time++;

    if (!this.spawned) {
      // Create 10 staggered streaks for more gaseous feel
      for (let i = 0; i < 10; i++) {
        this.streaks.push({
          delay: i * 4, // More staggered timing
          progress: 0,
          yOffset: (i - 4.5) * 10,
          opacity: 0.3 + Math.random() * 0.2, // More transparent
          width: 4 + Math.random() * 4 // Wider streaks
        });
      }
      this.spawned = true;
    }

    const dx = this.x2 - this.x1;
    const dy = this.y2 - this.y1;
    const angle = Math.atan2(dy, dx);

    ctx.save();
    ctx.strokeStyle = this.color;
    ctx.lineCap = 'round';

    // Heavy blur for intangible/gaseous feel (skip in low-FX mode)
    if (!gfxSettings.lowFx) {
      ctx.shadowBlur = 30;
      ctx.shadowColor = this.color;
    }

    let allDone = true;
    this.streaks.forEach(streak => {
      if (this.time < streak.delay) {
        allDone = false;
        return;
      }

      streak.progress += 0.03; // Much slower movement
      if (streak.progress < 1.5) allDone = false;

      // Ease in-out for both appearance and disappearance
      const rawT = Math.min(streak.progress, 1);
      const t = this.easeInOutCubic(rawT);

      // Smooth fade in and out
      let fadeMultiplier;
      if (streak.progress < 0.3) {
        fadeMultiplier = this.easeInOutCubic(streak.progress / 0.3);
      } else if (streak.progress > 1) {
        fadeMultiplier = this.easeInOutCubic(Math.max(0, (1.5 - streak.progress) / 0.5));
      } else {
        fadeMultiplier = 1;
      }

      ctx.globalAlpha = streak.opacity * fadeMultiplier;
      ctx.lineWidth = streak.width;

      // Calculate streak position with perpendicular offset
      const perpX = -Math.sin(angle) * streak.yOffset;
      const perpY = Math.cos(angle) * streak.yOffset;

      const startX = this.x1 + perpX + dx * (t - 0.15);
      const startY = this.y1 + perpY + dy * (t - 0.15);
      const endX = this.x1 + perpX + dx * t;
      const endY = this.y1 + perpY + dy * t;

      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(endX, endY);
      ctx.stroke();
    });

    ctx.restore();
    ctx.globalAlpha = 1;

    return !allDone;
  }
}

// --- REPLACED FUNCTION: createAuraAnimation ---
function playElementalEffect(fromSlot, targetElement, word) {
  if (!fxCtx || !fromSlot || !targetElement) return;

  const rect1 = fromSlot.getBoundingClientRect();
  const rect2 = targetElement.getBoundingClientRect();
  const x1 = rect1.left + rect1.width / 2;
  const y1 = rect1.top + rect1.height / 2;
  const x2 = rect2.left + rect2.width / 2;
  const y2 = rect2.top + rect2.height / 2;

  let type = 'physical';
  let color = '#a0a0a0'; // Physical Gray

  if (word && word.elem !== undefined) {
    const elemData = {
      [E.FIRE]: { type: 'fire', color: '#ff6633' },
      [E.WATER]: { type: 'water', color: '#4d99ff' },
      [E.LIGHTNING]: { type: 'lightning', color: '#ffff4d' },
      [E.EARTH]: { type: 'earth', color: '#996633' },
      [E.POISON]: { type: 'poison', color: '#7ee04d' },
      [E.LIGHT]: { type: 'light', color: '#ffffa0' },
      [E.DARK]: { type: 'dark', color: '#9966cc' },
      [E.PHYS]: { type: 'physical', color: '#a0a0a0' }
    };
    if (elemData[word.elem]) {
      type = elemData[word.elem].type;
      color = elemData[word.elem].color;
    }
  }

  // Trigger specific effect based on element type
  // Physical element has no special FX (just dust puff from slot)
  switch (type) {
    case 'lightning':
      // Flash white then color (reduced from 3 bolts to 2 for performance)
      addFxAnimation(new LightningBolt(x1, y1, x2, y2, '#ffffff'));
      setTimeout(() => addFxAnimation(new LightningBolt(x1, y1, x2, y2, color)), RHYTHM.EIGHTH);
      break;
    case 'light':
      addFxAnimation(new EnergyBeam(x1, y1, x2, y2, color, false));
      break;
    case 'dark':
      addFxAnimation(new EnergyBeam(x1, y1, x2, y2, color, true));
      break;
    case 'water':
      addFxAnimation(new WaterStream(x1, y1, x2, y2, color));
      break;
    case 'earth':
      addFxAnimation(new RockThrow(x1, y1, x2, y2, color));
      break;
    case 'poison':
      addFxAnimation(new WindGust(x1, y1, x2, y2, color));
      break;
    case 'fire':
      addFxAnimation(new ParticleTrail(x1, y1, x2, y2, type, color));
      break;
    case 'physical':
      // Metal clash effect - fast streak with impact sparks and shockwave
      addFxAnimation(new MetalClash(x1, y1, x2, y2, color));
      break;
    default:
      break;
  }
}

// === HERO PROGRESSION SYSTEM ===
// XP required to reach each level (cumulative)
const HERO_XP_THRESHOLDS = [
  0,      // Level 1 (starting)
  100,    // Level 2
  250,    // Level 3
  450,    // Level 4
  700,    // Level 5
  1000,   // Level 6
  1400,   // Level 7
  1900,   // Level 8
  2500,   // Level 9
  3200,   // Level 10
  4000,   // Level 11
  5000,   // Level 12
  6200,   // Level 13
  7600,   // Level 14
  9200,   // Level 15
  11000,  // Level 16
  13000,  // Level 17
  15500,  // Level 18
  18500,  // Level 19
  22000,  // Level 20
  26000,  // Level 21
  30500,  // Level 22
  35500,  // Level 23
  41000,  // Level 24
  47000,  // Level 25
  53500,  // Level 26
  60500,  // Level 27
  68000,  // Level 28
  76000,  // Level 29
  84500,  // Level 30
  93500,  // Level 31
  103000, // Level 32
  113000, // Level 33
  123500, // Level 34
  134500, // Level 35
  146000, // Level 36
  158000, // Level 37
  170500, // Level 38
  183500, // Level 39
  197000, // Level 40
  211000, // Level 41
  225500, // Level 42
  240500, // Level 43
  256000, // Level 44
  272000, // Level 45
  288500, // Level 46
  305500, // Level 47
  323000, // Level 48
  341000, // Level 49
  359500  // Level 50 (max)
];
const HERO_MAX_LEVEL = HERO_XP_THRESHOLDS.length;

// XP awarded based on round reached (base + bonus per round)
function calcRunXP(roundReached, defeatedBoss) {
  const baseXP = 10;
  const perRoundXP = 15;
  const bossBonus = defeatedBoss ? 50 : 0;
  return baseXP + (roundReached * perRoundXP) + bossBonus;
}

// Get hero's current level from XP
function getHeroLevel(heroName) {
  if (!PStats.heroXP) return 1;
  const xp = PStats.heroXP[heroName] || 0;
  for (let i = HERO_XP_THRESHOLDS.length - 1; i >= 0; i--) {
    if (xp >= HERO_XP_THRESHOLDS[i]) return i + 1;
  }
  return 1;
}

// Get XP needed for next level
function getXPForNextLevel(heroName) {
  const level = getHeroLevel(heroName);
  if (level >= HERO_MAX_LEVEL) return null; // Max level
  return HERO_XP_THRESHOLDS[level];
}

// Get XP progress within current level (0-1)
function getXPProgress(heroName) {
  if (!PStats.heroXP) return 0;
  const xp = PStats.heroXP[heroName] || 0;
  const level = getHeroLevel(heroName);
  if (level >= HERO_MAX_LEVEL) return 1;
  const currentThreshold = HERO_XP_THRESHOLDS[level - 1];
  const nextThreshold = HERO_XP_THRESHOLDS[level];
  return (xp - currentThreshold) / (nextThreshold - currentThreshold);
}

// Award XP to hero and handle level ups
function awardHeroXP(heroName, xpAmount) {
  if (!PStats.heroXP) PStats.heroXP = {};
  if (!PStats.heroSkillPoints) PStats.heroSkillPoints = {};
  if (!PStats.heroLevel) PStats.heroLevel = {};
  const oldLevel = getHeroLevel(heroName);
  PStats.heroXP[heroName] = (PStats.heroXP[heroName] || 0) + xpAmount;
  const newLevel = getHeroLevel(heroName);

  // Award skill points for level ups
  const levelsGained = newLevel - oldLevel;
  if (levelsGained > 0) {
    PStats.heroSkillPoints[heroName] = (PStats.heroSkillPoints[heroName] || 0) + levelsGained;
  }

  PStats.heroLevel[heroName] = newLevel;
  saveStats();

  return { oldLevel, newLevel, levelsGained, totalXP: PStats.heroXP[heroName] };
}

// Initialize hero skills if not present
function initHeroSkills(heroName) {
  if (!PStats.heroSkills) PStats.heroSkills = {};
  if (!PStats.heroXP) PStats.heroXP = {};
  if (!PStats.heroLevel) PStats.heroLevel = {};
  if (!PStats.heroSkillPoints) PStats.heroSkillPoints = {};
  if (!PStats.heroSkills[heroName]) {
    PStats.heroSkills[heroName] = {};
  }
  if (!PStats.heroXP[heroName]) {
    PStats.heroXP[heroName] = 0;
  }
  if (!PStats.heroLevel[heroName]) {
    PStats.heroLevel[heroName] = 1;
  }
  if (!PStats.heroSkillPoints[heroName]) {
    PStats.heroSkillPoints[heroName] = 0;
  }
}

// Get total points allocated in a skill
function getSkillPoints(heroName, skillId) {
  initHeroSkills(heroName);
  return PStats.heroSkills[heroName][skillId] || 0;
}

// Check if a skill node is unlocked (prerequisites met)
function isSkillUnlocked(heroName, skillId) {
  const tree = SKILL_TREES[heroName];
  if (!tree) return false;
  const node = tree.nodes.find(n => n.id === skillId);
  if (!node) return false;

  // Check if all prerequisites have minimum required points
  if (node.requires) {
    for (const req of node.requires) {
      const allocated = getSkillPoints(heroName, req.id);
      if (allocated < req.points) return false;
    }
  }
  return true;
}

// Allocate a point to a skill
function allocateSkillPoint(heroName, skillId) {
  initHeroSkills(heroName);
  const tree = SKILL_TREES[heroName];
  if (!tree) return false;

  const node = tree.nodes.find(n => n.id === skillId);
  if (!node) return false;

  const currentPoints = getSkillPoints(heroName, skillId);
  const availablePoints = PStats.heroSkillPoints[heroName] || 0;

  // Check constraints
  if (availablePoints <= 0) return false;
  if (currentPoints >= node.maxPoints) return false;
  if (!isSkillUnlocked(heroName, skillId)) return false;

  // Allocate
  PStats.heroSkills[heroName][skillId] = currentPoints + 1;
  PStats.heroSkillPoints[heroName] = availablePoints - 1;
  saveStats();
  updateSkillBadges();
  return true;
}

// Respec all skills for a hero
function respecHeroSkills(heroName) {
  initHeroSkills(heroName);

  // Count total points allocated
  let totalAllocated = 0;
  for (const skillId in PStats.heroSkills[heroName]) {
    totalAllocated += PStats.heroSkills[heroName][skillId];
  }

  // Refund all points
  PStats.heroSkills[heroName] = {};
  PStats.heroSkillPoints[heroName] = (PStats.heroSkillPoints[heroName] || 0) + totalAllocated;
  saveStats();
  updateSkillBadges();
  return totalAllocated;
}

// Check if any hero has unspent skill points
function hasUnspentSkillPoints() {
  if (!PStats.heroSkillPoints) return false;
  const heroNames = ['Graham Moor', 'Quivera', 'Belle Lettres', 'Alexandria Constanza', 'Caesura', 'Reed'];
  for (const name of heroNames) {
    const points = PStats.heroSkillPoints[name] || 0;
    if (points > 0) return true;
  }
  return false;
}

// Update skill points notification badges
function updateSkillBadges() {
  const hasPoints = hasUnspentSkillPoints();
  const badge1 = document.getElementById('skill-points-badge');
  const badge2 = document.getElementById('skill-points-badge-select');
  if (badge1) badge1.style.display = hasPoints ? 'block' : 'none';
  if (badge2) badge2.style.display = hasPoints ? 'block' : 'none';
}

// Get the bonus value from a skill (for gameplay hooks)
function getSkillBonus(heroName, skillId) {
  const tree = SKILL_TREES[heroName];
  if (!tree) return 0;
  const node = tree.nodes.find(n => n.id === skillId);
  if (!node) return 0;

  const points = getSkillPoints(heroName, skillId);
  if (points === 0) return 0;

  // Return bonus based on points allocated
  return node.bonusPerPoint * points;
}

// Get total bonus of a specific type from all skills for a hero
function getTotalSkillBonus(heroName, bonusType, element = null) {
  const tree = SKILL_TREES[heroName];
  if (!tree) return 0;

  let total = 0;
  for (const node of tree.nodes) {
    if (node.bonusType === bonusType) {
      // If element-specific, check element matches
      if (element !== null && node.element !== undefined && node.element !== element) {
        continue;
      }
      const points = getSkillPoints(heroName, node.id);
      if (points > 0) {
        total += node.bonusPerPoint * points;
      }
    }
  }
  return total;
}

// Get all skill bonuses for a hero (cached for performance during combat)
function getHeroSkillBonuses(heroName) {
  const tree = SKILL_TREES[heroName];
  if (!tree) return {};

  // Apply difficulty scaling to skill tree effectiveness
  const skillMult = DIFF_SKILL_MULT[S.difficulty || 0];

  const bonuses = {};
  for (const node of tree.nodes) {
    const points = getSkillPoints(heroName, node.id);
    if (points > 0) {
      const key = node.element !== undefined ? `${node.bonusType}_${node.element}` : node.bonusType;
      // Capstones are binary (on/off), don't scale them - but numeric bonuses scale with difficulty
      const baseBonus = node.bonusPerPoint * points;
      const scaledBonus = node.type === 'capstone' ? baseBonus : baseBonus * skillMult;
      bonuses[key] = (bonuses[key] || 0) + scaledBonus;
    }
  }
  return bonuses;
}

// Check if a hero has unlocked their capstone ability
function hasCapstone(heroName) {
  const prefixes = {
    'Graham Moor': 'gm',
    'Quivera': 'qv',
    'Belle Lettres': 'bl',
    'Alexandria Constanza': 'ac',
    'Caesura': 'cs',
    'Reed': 'rd'
  };
  const prefix = prefixes[heroName];
  if (!prefix) return false;
  return getSkillPoints(heroName, `${prefix}_capstone`) >= 1;
}

// === SKILL TREES ===
// === HERO SKILL TREES ===
// Expanded branching trees with 3 paths converging to a unique capstone
// Row 0 = start, Row 7 = capstone. 5-column layout for wider spread.

function createGrahamTree() {
  const p = 'gm';
  return {
    capstone: { id: 'cross_the_ts', name: "Cross the T's", desc: "Slash weapons: REREAD √ó1" },
    nodes: [
      // Row 0: Start
      { id: `${p}_recruit`, name: "Weapon Training", type: "minor", maxPoints: 1, row: 0, col: 2,
        desc: "+1 AP to Weapon slot", bonusPerPoint: 1, bonusType: "weaponAP", requires: [] },

      // Row 1: First split
      { id: `${p}_aggression`, name: "Strength I", type: "minor", maxPoints: 3, row: 1, col: 1,
        desc: "+0.5 AP to Weapon slot per point", bonusPerPoint: 0.5, bonusType: "weaponAP", requires: [{id: `${p}_recruit`, points: 1}] },
      { id: `${p}_fortitude`, name: "Endurance I", type: "minor", maxPoints: 3, row: 1, col: 3,
        desc: "+0.5 AP to Noun slot per point", bonusPerPoint: 0.5, bonusType: "nounAP", requires: [{id: `${p}_recruit`, points: 1}] },

      // Row 2: Branch expansion
      { id: `${p}_fury1`, name: "Strength II", type: "minor", maxPoints: 3, row: 2, col: 0,
        desc: "+0.5 AP to Weapon slot per point", bonusPerPoint: 0.5, bonusType: "weaponAP", requires: [{id: `${p}_aggression`, points: 2}] },
      { id: `${p}_precision`, name: "Precision I", type: "minor", maxPoints: 3, row: 2, col: 2,
        desc: "+0.5 AP to Adjective slot per point", bonusPerPoint: 0.5, bonusType: "adjAP", requires: [{id: `${p}_aggression`, points: 2}, {id: `${p}_fortitude`, points: 2}] },
      { id: `${p}_stone1`, name: "Endurance II", type: "minor", maxPoints: 3, row: 2, col: 4,
        desc: "+0.5 AP to Noun slot per point", bonusPerPoint: 0.5, bonusType: "nounAP", requires: [{id: `${p}_fortitude`, points: 2}] },

      // Row 3: Major nodes
      { id: `${p}_battlecry`, name: "Boss Slayer", type: "major", maxPoints: 2, row: 3, col: 0,
        desc: "+3 AP vs Boss enemies per point", bonusPerPoint: 3, bonusType: "bossAP", requires: [{id: `${p}_fury1`, points: 2}] },
      { id: `${p}_veteran`, name: "Veteran", type: "minor", maxPoints: 3, row: 3, col: 2,
        desc: "+3 Starting Gold per point", bonusPerPoint: 3, bonusType: "startGold", requires: [{id: `${p}_precision`, points: 2}] },
      { id: `${p}_earthshaker`, name: "Earth Mastery", type: "major", maxPoints: 2, row: 3, col: 4,
        desc: "+2 AP per Earth word per point", bonusPerPoint: 2, bonusType: "earthAP", requires: [{id: `${p}_stone1`, points: 2}] },

      // Row 4: Continue branches
      { id: `${p}_fury2`, name: "Strength III", type: "minor", maxPoints: 3, row: 4, col: 0,
        desc: "+0.5 AP to Weapon slot per point", bonusPerPoint: 0.5, bonusType: "weaponAP", requires: [{id: `${p}_battlecry`, points: 1}] },
      { id: `${p}_edge1`, name: "Precision II", type: "minor", maxPoints: 3, row: 4, col: 1,
        desc: "+0.5 AP to Adjective slot per point", bonusPerPoint: 0.5, bonusType: "adjAP", requires: [{id: `${p}_battlecry`, points: 1}] },
      { id: `${p}_gilded`, name: "Gilded", type: "minor", maxPoints: 3, row: 4, col: 2,
        desc: "+5 Starting Gold per point", bonusPerPoint: 5, bonusType: "startGold", requires: [{id: `${p}_veteran`, points: 2}] },
      { id: `${p}_edge2`, name: "Precision III", type: "minor", maxPoints: 3, row: 4, col: 3,
        desc: "+0.5 AP to Adjective slot per point", bonusPerPoint: 0.5, bonusType: "adjAP", requires: [{id: `${p}_earthshaker`, points: 1}] },
      { id: `${p}_stone2`, name: "Endurance III", type: "minor", maxPoints: 3, row: 4, col: 4,
        desc: "+0.5 AP to Noun slot per point", bonusPerPoint: 0.5, bonusType: "nounAP", requires: [{id: `${p}_earthshaker`, points: 1}] },

      // Row 5: Pre-major
      { id: `${p}_wrath`, name: "Gem Focus I", type: "minor", maxPoints: 3, row: 5, col: 0,
        desc: "+0.5 AP to Gem slot per point", bonusPerPoint: 0.5, bonusType: "gemAP", requires: [{id: `${p}_fury2`, points: 2}] },
      { id: `${p}_sharp`, name: "Strength IV", type: "minor", maxPoints: 3, row: 5, col: 2,
        desc: "+0.5 AP to Weapon slot per point", bonusPerPoint: 0.5, bonusType: "weaponAP", requires: [{id: `${p}_gilded`, points: 2}] },
      { id: `${p}_mountain`, name: "Gem Focus II", type: "minor", maxPoints: 3, row: 5, col: 4,
        desc: "+0.5 AP to Gem slot per point", bonusPerPoint: 0.5, bonusType: "gemAP", requires: [{id: `${p}_stone2`, points: 2}] },

      // Row 6: Final major nodes before capstone
      { id: `${p}_bladework`, name: "Slash Mastery", type: "major", maxPoints: 1, row: 6, col: 1,
        desc: "+3 AP with Slash weapons", bonusPerPoint: 3, bonusType: "slashAP", requires: [{id: `${p}_wrath`, points: 2}, {id: `${p}_sharp`, points: 2}] },
      { id: `${p}_titan`, name: "Physical Mastery", type: "major", maxPoints: 1, row: 6, col: 3,
        desc: "+3 AP with Physical words", bonusPerPoint: 3, bonusType: "physAP", requires: [{id: `${p}_sharp`, points: 2}, {id: `${p}_mountain`, points: 2}] },

      // Row 7: Capstone
      { id: `${p}_capstone`, name: "Duty Bound", type: "capstone", maxPoints: 1, row: 7, col: 2,
        desc: "Slash weapons: REREAD √ó1", bonusPerPoint: 1, bonusType: "capstone", requires: [{id: `${p}_bladework`, points: 1}, {id: `${p}_titan`, points: 1}] },
    ]
  };
}

function createQuiveraTree() {
  const p = 'qv';
  return {
    capstone: { id: 'last_arrow', name: "Last Arrow", desc: "Last word in forge triggers twice" },
    nodes: [
      // Row 0: Start
      { id: `${p}_scout`, name: "Tracking", type: "minor", maxPoints: 1, row: 0, col: 2,
        desc: "+1 AP to Noun slot", bonusPerPoint: 1, bonusType: "nounAP", requires: [] },

      // Row 1: First split
      { id: `${p}_charge`, name: "Agility I", type: "minor", maxPoints: 3, row: 1, col: 1,
        desc: "+0.5 AP to Noun slot per point", bonusPerPoint: 0.5, bonusType: "nounAP", requires: [{id: `${p}_scout`, points: 1}] },
      { id: `${p}_grounded`, name: "Focus I", type: "minor", maxPoints: 3, row: 1, col: 3,
        desc: "+0.5 AP to Adjective slot per point", bonusPerPoint: 0.5, bonusType: "adjAP", requires: [{id: `${p}_scout`, points: 1}] },

      // Row 2: Branch expansion
      { id: `${p}_volt1`, name: "Agility II", type: "minor", maxPoints: 3, row: 2, col: 0,
        desc: "+0.5 AP to Noun slot per point", bonusPerPoint: 0.5, bonusType: "nounAP", requires: [{id: `${p}_charge`, points: 2}] },
      { id: `${p}_focus`, name: "Aim I", type: "minor", maxPoints: 3, row: 2, col: 2,
        desc: "+0.5 AP to Weapon slot per point", bonusPerPoint: 0.5, bonusType: "weaponAP", requires: [{id: `${p}_charge`, points: 2}, {id: `${p}_grounded`, points: 2}] },
      { id: `${p}_stone1`, name: "Focus II", type: "minor", maxPoints: 3, row: 2, col: 4,
        desc: "+0.5 AP to Adjective slot per point", bonusPerPoint: 0.5, bonusType: "adjAP", requires: [{id: `${p}_grounded`, points: 2}] },

      // Row 3: Major nodes
      { id: `${p}_stormshot`, name: "Lightning Mastery", type: "major", maxPoints: 2, row: 3, col: 0,
        desc: "+2 AP per Lightning word per point", bonusPerPoint: 2, bonusType: "lightningAP", requires: [{id: `${p}_volt1`, points: 2}] },
      { id: `${p}_huntress`, name: "Resourceful", type: "minor", maxPoints: 3, row: 3, col: 2,
        desc: "+3 Starting Gold per point", bonusPerPoint: 3, bonusType: "startGold", requires: [{id: `${p}_focus`, points: 2}] },
      { id: `${p}_terraform`, name: "Earth Mastery", type: "major", maxPoints: 2, row: 3, col: 4,
        desc: "+2 AP per Earth word per point", bonusPerPoint: 2, bonusType: "earthAP", requires: [{id: `${p}_stone1`, points: 2}] },

      // Row 4: Continue branches
      { id: `${p}_volt2`, name: "Agility III", type: "minor", maxPoints: 3, row: 4, col: 0,
        desc: "+0.5 AP to Noun slot per point", bonusPerPoint: 0.5, bonusType: "nounAP", requires: [{id: `${p}_stormshot`, points: 1}] },
      { id: `${p}_aim1`, name: "Aim II", type: "minor", maxPoints: 3, row: 4, col: 1,
        desc: "+0.5 AP to Weapon slot per point", bonusPerPoint: 0.5, bonusType: "weaponAP", requires: [{id: `${p}_stormshot`, points: 1}] },
      { id: `${p}_gilded`, name: "Gilded", type: "minor", maxPoints: 3, row: 4, col: 2,
        desc: "+5 Starting Gold per point", bonusPerPoint: 5, bonusType: "startGold", requires: [{id: `${p}_huntress`, points: 2}] },
      { id: `${p}_aim2`, name: "Aim III", type: "minor", maxPoints: 3, row: 4, col: 3,
        desc: "+0.5 AP to Weapon slot per point", bonusPerPoint: 0.5, bonusType: "weaponAP", requires: [{id: `${p}_terraform`, points: 1}] },
      { id: `${p}_stone2`, name: "Focus III", type: "minor", maxPoints: 3, row: 4, col: 4,
        desc: "+0.5 AP to Adjective slot per point", bonusPerPoint: 0.5, bonusType: "adjAP", requires: [{id: `${p}_terraform`, points: 1}] },

      // Row 5: Pre-major
      { id: `${p}_thunder`, name: "Gem Focus I", type: "minor", maxPoints: 3, row: 5, col: 0,
        desc: "+0.5 AP to Gem slot per point", bonusPerPoint: 0.5, bonusType: "gemAP", requires: [{id: `${p}_volt2`, points: 2}] },
      { id: `${p}_precise`, name: "Aim IV", type: "minor", maxPoints: 3, row: 5, col: 2,
        desc: "+0.5 AP to Weapon slot per point", bonusPerPoint: 0.5, bonusType: "weaponAP", requires: [{id: `${p}_gilded`, points: 2}] },
      { id: `${p}_mountain`, name: "Gem Focus II", type: "minor", maxPoints: 3, row: 5, col: 4,
        desc: "+0.5 AP to Gem slot per point", bonusPerPoint: 0.5, bonusType: "gemAP", requires: [{id: `${p}_stone2`, points: 2}] },

      // Row 6: Final major nodes before capstone
      { id: `${p}_marksman`, name: "Pierce Mastery", type: "major", maxPoints: 1, row: 6, col: 1,
        desc: "+3 AP with Pierce weapons", bonusPerPoint: 3, bonusType: "pierceAP", requires: [{id: `${p}_thunder`, points: 2}, {id: `${p}_precise`, points: 2}] },
      { id: `${p}_trapper`, name: "Weakness Exploit", type: "major", maxPoints: 1, row: 6, col: 3,
        desc: "+3 AP when hitting weakness", bonusPerPoint: 3, bonusType: "weaknessAP", requires: [{id: `${p}_precise`, points: 2}, {id: `${p}_mountain`, points: 2}] },

      // Row 7: Capstone
      { id: `${p}_capstone`, name: "Last Arrow", type: "capstone", maxPoints: 1, row: 7, col: 2,
        desc: "Last word triggers twice", bonusPerPoint: 1, bonusType: "capstone", requires: [{id: `${p}_marksman`, points: 1}, {id: `${p}_trapper`, points: 1}] },
    ]
  };
}

function createBelleTree() {
  const p = 'bl';
  return {
    capstone: { id: 'knowledge_eternal', name: "Knowledge Eternal", desc: "All words: REREAD √ó1" },
    nodes: [
      // Row 0: Start
      { id: `${p}_student`, name: "Bookworm", type: "minor", maxPoints: 1, row: 0, col: 2,
        desc: "+1 AP to Adjective slot", bonusPerPoint: 1, bonusType: "adjAP", requires: [] },

      // Row 1: First split - Light (left) and Dark (right)
      { id: `${p}_radiant`, name: "Insight I", type: "minor", maxPoints: 3, row: 1, col: 1,
        desc: "+0.5 AP to Adjective slot per point", bonusPerPoint: 0.5, bonusType: "adjAP", requires: [{id: `${p}_student`, points: 1}] },
      { id: `${p}_shadow`, name: "Wisdom I", type: "minor", maxPoints: 3, row: 1, col: 3,
        desc: "+0.5 AP to Noun slot per point", bonusPerPoint: 0.5, bonusType: "nounAP", requires: [{id: `${p}_student`, points: 1}] },

      // Row 2: Branch expansion
      { id: `${p}_glow1`, name: "Insight II", type: "minor", maxPoints: 3, row: 2, col: 0,
        desc: "+0.5 AP to Adjective slot per point", bonusPerPoint: 0.5, bonusType: "adjAP", requires: [{id: `${p}_radiant`, points: 2}] },
      { id: `${p}_channel`, name: "Spell I", type: "minor", maxPoints: 3, row: 2, col: 2,
        desc: "+0.5 AP to Weapon slot per point", bonusPerPoint: 0.5, bonusType: "weaponAP", requires: [{id: `${p}_radiant`, points: 2}, {id: `${p}_shadow`, points: 2}] },
      { id: `${p}_shade1`, name: "Wisdom II", type: "minor", maxPoints: 3, row: 2, col: 4,
        desc: "+0.5 AP to Noun slot per point", bonusPerPoint: 0.5, bonusType: "nounAP", requires: [{id: `${p}_shadow`, points: 2}] },

      // Row 3: Major nodes - Light Mastery (left) and Dark Mastery (right)
      { id: `${p}_lightmaster`, name: "Light Mastery", type: "major", maxPoints: 2, row: 3, col: 0,
        desc: "+2 AP per Light word per point", bonusPerPoint: 2, bonusType: "lightAP", requires: [{id: `${p}_glow1`, points: 2}] },
      { id: `${p}_scholar`, name: "Scholar", type: "minor", maxPoints: 3, row: 3, col: 2,
        desc: "+3 Starting Gold per point", bonusPerPoint: 3, bonusType: "startGold", requires: [{id: `${p}_channel`, points: 2}] },
      { id: `${p}_darkmaster`, name: "Dark Mastery", type: "major", maxPoints: 2, row: 3, col: 4,
        desc: "+2 AP per Dark word per point", bonusPerPoint: 2, bonusType: "darkAP", requires: [{id: `${p}_shade1`, points: 2}] },

      // Row 4: Continue branches
      { id: `${p}_glow2`, name: "Insight III", type: "minor", maxPoints: 3, row: 4, col: 0,
        desc: "+0.5 AP to Adjective slot per point", bonusPerPoint: 0.5, bonusType: "adjAP", requires: [{id: `${p}_lightmaster`, points: 1}] },
      { id: `${p}_spell1`, name: "Spell II", type: "minor", maxPoints: 3, row: 4, col: 1,
        desc: "+0.5 AP to Weapon slot per point", bonusPerPoint: 0.5, bonusType: "weaponAP", requires: [{id: `${p}_lightmaster`, points: 1}] },
      { id: `${p}_gilded`, name: "Gilded", type: "minor", maxPoints: 3, row: 4, col: 2,
        desc: "+5 Starting Gold per point", bonusPerPoint: 5, bonusType: "startGold", requires: [{id: `${p}_scholar`, points: 2}] },
      { id: `${p}_spell2`, name: "Spell III", type: "minor", maxPoints: 3, row: 4, col: 3,
        desc: "+0.5 AP to Weapon slot per point", bonusPerPoint: 0.5, bonusType: "weaponAP", requires: [{id: `${p}_darkmaster`, points: 1}] },
      { id: `${p}_shade2`, name: "Wisdom III", type: "minor", maxPoints: 3, row: 4, col: 4,
        desc: "+0.5 AP to Noun slot per point", bonusPerPoint: 0.5, bonusType: "nounAP", requires: [{id: `${p}_darkmaster`, points: 1}] },

      // Row 5: Pre-major
      { id: `${p}_luminous`, name: "Gem Focus I", type: "minor", maxPoints: 3, row: 5, col: 0,
        desc: "+0.5 AP to Gem slot per point", bonusPerPoint: 0.5, bonusType: "gemAP", requires: [{id: `${p}_glow2`, points: 2}] },
      { id: `${p}_arcane`, name: "Spell IV", type: "minor", maxPoints: 3, row: 5, col: 2,
        desc: "+0.5 AP to Weapon slot per point", bonusPerPoint: 0.5, bonusType: "weaponAP", requires: [{id: `${p}_gilded`, points: 2}] },
      { id: `${p}_void`, name: "Gem Focus II", type: "minor", maxPoints: 3, row: 5, col: 4,
        desc: "+0.5 AP to Gem slot per point", bonusPerPoint: 0.5, bonusType: "gemAP", requires: [{id: `${p}_shade2`, points: 2}] },

      // Row 6: Final major nodes before capstone
      { id: `${p}_arcana`, name: "Magic Mastery", type: "major", maxPoints: 1, row: 6, col: 1,
        desc: "+3 AP with Magic weapons", bonusPerPoint: 3, bonusType: "magicAP", requires: [{id: `${p}_luminous`, points: 2}, {id: `${p}_arcane`, points: 2}] },
      { id: `${p}_duality`, name: "Light/Dark Duality", type: "major", maxPoints: 1, row: 6, col: 3,
        desc: "+3 AP if both Light and Dark", bonusPerPoint: 3, bonusType: "lightDarkDualAP", requires: [{id: `${p}_arcane`, points: 2}, {id: `${p}_void`, points: 2}] },

      // Row 7: Capstone
      { id: `${p}_capstone`, name: "Knowledge Eternal", type: "capstone", maxPoints: 1, row: 7, col: 2,
        desc: "All words: REREAD √ó1", bonusPerPoint: 1, bonusType: "capstone", requires: [{id: `${p}_arcana`, points: 1}, {id: `${p}_duality`, points: 1}] },
    ]
  };
}

function createAlexandriaTree() {
  const p = 'ac';
  return {
    capstone: { id: 'sacred_flame', name: "Sacred Flame", desc: "Fire/Light are interchangeable elements" },
    nodes: [
      // Row 0: Start
      { id: `${p}_oath`, name: "Devotion", type: "minor", maxPoints: 1, row: 0, col: 2,
        desc: "+1 AP to Noun slot", bonusPerPoint: 1, bonusType: "nounAP", requires: [] },

      // Row 1: First split
      { id: `${p}_blessed`, name: "Faith I", type: "minor", maxPoints: 3, row: 1, col: 1,
        desc: "+0.5 AP to Noun slot per point", bonusPerPoint: 0.5, bonusType: "nounAP", requires: [{id: `${p}_oath`, points: 1}] },
      { id: `${p}_valiant`, name: "Valor I", type: "minor", maxPoints: 3, row: 1, col: 3,
        desc: "+0.5 AP to Adjective slot per point", bonusPerPoint: 0.5, bonusType: "adjAP", requires: [{id: `${p}_oath`, points: 1}] },

      // Row 2: Branch expansion
      { id: `${p}_halo1`, name: "Faith II", type: "minor", maxPoints: 3, row: 2, col: 0,
        desc: "+0.5 AP to Noun slot per point", bonusPerPoint: 0.5, bonusType: "nounAP", requires: [{id: `${p}_blessed`, points: 2}] },
      { id: `${p}_judgment`, name: "Zeal I", type: "minor", maxPoints: 3, row: 2, col: 2,
        desc: "+0.5 AP to Weapon slot per point", bonusPerPoint: 0.5, bonusType: "weaponAP", requires: [{id: `${p}_blessed`, points: 2}, {id: `${p}_valiant`, points: 2}] },
      { id: `${p}_might1`, name: "Valor II", type: "minor", maxPoints: 3, row: 2, col: 4,
        desc: "+0.5 AP to Adjective slot per point", bonusPerPoint: 0.5, bonusType: "adjAP", requires: [{id: `${p}_valiant`, points: 2}] },

      // Row 3: Major nodes
      { id: `${p}_holylight`, name: "Light Mastery", type: "major", maxPoints: 2, row: 3, col: 0,
        desc: "+2 AP per Light word per point", bonusPerPoint: 2, bonusType: "lightAP", requires: [{id: `${p}_halo1`, points: 2}] },
      { id: `${p}_devout`, name: "Devout", type: "minor", maxPoints: 3, row: 3, col: 2,
        desc: "+3 Starting Gold per point", bonusPerPoint: 3, bonusType: "startGold", requires: [{id: `${p}_judgment`, points: 2}] },
      { id: `${p}_righteous`, name: "Physical Mastery", type: "major", maxPoints: 2, row: 3, col: 4,
        desc: "+2 AP per Physical word per point", bonusPerPoint: 2, bonusType: "physAP", requires: [{id: `${p}_might1`, points: 2}] },

      // Row 4: Continue branches
      { id: `${p}_halo2`, name: "Faith III", type: "minor", maxPoints: 3, row: 4, col: 0,
        desc: "+0.5 AP to Noun slot per point", bonusPerPoint: 0.5, bonusType: "nounAP", requires: [{id: `${p}_holylight`, points: 1}] },
      { id: `${p}_smite1`, name: "Zeal II", type: "minor", maxPoints: 3, row: 4, col: 1,
        desc: "+0.5 AP to Weapon slot per point", bonusPerPoint: 0.5, bonusType: "weaponAP", requires: [{id: `${p}_holylight`, points: 1}] },
      { id: `${p}_gilded`, name: "Gilded", type: "minor", maxPoints: 3, row: 4, col: 2,
        desc: "+5 Starting Gold per point", bonusPerPoint: 5, bonusType: "startGold", requires: [{id: `${p}_devout`, points: 2}] },
      { id: `${p}_smite2`, name: "Zeal III", type: "minor", maxPoints: 3, row: 4, col: 3,
        desc: "+0.5 AP to Weapon slot per point", bonusPerPoint: 0.5, bonusType: "weaponAP", requires: [{id: `${p}_righteous`, points: 1}] },
      { id: `${p}_might2`, name: "Valor III", type: "minor", maxPoints: 3, row: 4, col: 4,
        desc: "+0.5 AP to Adjective slot per point", bonusPerPoint: 0.5, bonusType: "adjAP", requires: [{id: `${p}_righteous`, points: 1}] },

      // Row 5: Pre-major
      { id: `${p}_divine`, name: "Gem Focus I", type: "minor", maxPoints: 3, row: 5, col: 0,
        desc: "+0.5 AP to Gem slot per point", bonusPerPoint: 0.5, bonusType: "gemAP", requires: [{id: `${p}_halo2`, points: 2}] },
      { id: `${p}_zeal`, name: "Zeal IV", type: "minor", maxPoints: 3, row: 5, col: 2,
        desc: "+0.5 AP to Weapon slot per point", bonusPerPoint: 0.5, bonusType: "weaponAP", requires: [{id: `${p}_gilded`, points: 2}] },
      { id: `${p}_fervor`, name: "Gem Focus II", type: "minor", maxPoints: 3, row: 5, col: 4,
        desc: "+0.5 AP to Gem slot per point", bonusPerPoint: 0.5, bonusType: "gemAP", requires: [{id: `${p}_might2`, points: 2}] },

      // Row 6: Final major nodes before capstone
      { id: `${p}_crusader`, name: "Blunt Mastery", type: "major", maxPoints: 1, row: 6, col: 1,
        desc: "+3 AP with Blunt weapons", bonusPerPoint: 3, bonusType: "bluntAP", requires: [{id: `${p}_divine`, points: 2}, {id: `${p}_zeal`, points: 2}] },
      { id: `${p}_sermon`, name: "Weakness Exploit", type: "major", maxPoints: 1, row: 6, col: 3,
        desc: "+2 AP per weakness hit", bonusPerPoint: 2, bonusType: "weaknessAP", requires: [{id: `${p}_zeal`, points: 2}, {id: `${p}_fervor`, points: 2}] },

      // Row 7: Capstone
      { id: `${p}_capstone`, name: "Sacred Flame", type: "capstone", maxPoints: 1, row: 7, col: 2,
        desc: "Fire/Light interchangeable", bonusPerPoint: 1, bonusType: "capstone", requires: [{id: `${p}_crusader`, points: 1}, {id: `${p}_sermon`, points: 1}] },
    ]
  };
}

function createCaesuraTree() {
  const p = 'cs';
  return {
    capstone: { id: 'final_silence', name: "Final Silence", desc: "Words after an empty slot: √ó2" },
    nodes: [
      // Row 0: Start
      { id: `${p}_whisper`, name: "Stealth", type: "minor", maxPoints: 1, row: 0, col: 2,
        desc: "+1 AP to Adjective slot", bonusPerPoint: 1, bonusType: "adjAP", requires: [] },

      // Row 1: First split
      { id: `${p}_shadow`, name: "Cunning I", type: "minor", maxPoints: 3, row: 1, col: 1,
        desc: "+0.5 AP to Adjective slot per point", bonusPerPoint: 0.5, bonusType: "adjAP", requires: [{id: `${p}_whisper`, points: 1}] },
      { id: `${p}_corrupt`, name: "Malice I", type: "minor", maxPoints: 3, row: 1, col: 3,
        desc: "+0.5 AP to Noun slot per point", bonusPerPoint: 0.5, bonusType: "nounAP", requires: [{id: `${p}_whisper`, points: 1}] },

      // Row 2: Branch expansion
      { id: `${p}_shade1`, name: "Cunning II", type: "minor", maxPoints: 3, row: 2, col: 0,
        desc: "+0.5 AP to Adjective slot per point", bonusPerPoint: 0.5, bonusType: "adjAP", requires: [{id: `${p}_shadow`, points: 2}] },
      { id: `${p}_lethal`, name: "Lethality I", type: "minor", maxPoints: 3, row: 2, col: 2,
        desc: "+0.5 AP to Weapon slot per point", bonusPerPoint: 0.5, bonusType: "weaponAP", requires: [{id: `${p}_shadow`, points: 2}, {id: `${p}_corrupt`, points: 2}] },
      { id: `${p}_toxin1`, name: "Malice II", type: "minor", maxPoints: 3, row: 2, col: 4,
        desc: "+0.5 AP to Noun slot per point", bonusPerPoint: 0.5, bonusType: "nounAP", requires: [{id: `${p}_corrupt`, points: 2}] },

      // Row 3: Major nodes
      { id: `${p}_nightshade`, name: "Dark Mastery", type: "major", maxPoints: 2, row: 3, col: 0,
        desc: "+2 AP per Dark word per point", bonusPerPoint: 2, bonusType: "darkAP", requires: [{id: `${p}_shade1`, points: 2}] },
      { id: `${p}_silence`, name: "Silent", type: "minor", maxPoints: 3, row: 3, col: 2,
        desc: "+3 Starting Gold per point", bonusPerPoint: 3, bonusType: "startGold", requires: [{id: `${p}_lethal`, points: 2}] },
      { id: `${p}_venom`, name: "Poison Mastery", type: "major", maxPoints: 2, row: 3, col: 4,
        desc: "+2 AP per Poison word per point", bonusPerPoint: 2, bonusType: "poisonAP", requires: [{id: `${p}_toxin1`, points: 2}] },

      // Row 4: Continue branches
      { id: `${p}_shade2`, name: "Cunning III", type: "minor", maxPoints: 3, row: 4, col: 0,
        desc: "+0.5 AP to Adjective slot per point", bonusPerPoint: 0.5, bonusType: "adjAP", requires: [{id: `${p}_nightshade`, points: 1}] },
      { id: `${p}_stab1`, name: "Lethality II", type: "minor", maxPoints: 3, row: 4, col: 1,
        desc: "+0.5 AP to Weapon slot per point", bonusPerPoint: 0.5, bonusType: "weaponAP", requires: [{id: `${p}_nightshade`, points: 1}] },
      { id: `${p}_gilded`, name: "Gilded", type: "minor", maxPoints: 3, row: 4, col: 2,
        desc: "+5 Starting Gold per point", bonusPerPoint: 5, bonusType: "startGold", requires: [{id: `${p}_silence`, points: 2}] },
      { id: `${p}_stab2`, name: "Lethality III", type: "minor", maxPoints: 3, row: 4, col: 3,
        desc: "+0.5 AP to Weapon slot per point", bonusPerPoint: 0.5, bonusType: "weaponAP", requires: [{id: `${p}_venom`, points: 1}] },
      { id: `${p}_toxin2`, name: "Malice III", type: "minor", maxPoints: 3, row: 4, col: 4,
        desc: "+0.5 AP to Noun slot per point", bonusPerPoint: 0.5, bonusType: "nounAP", requires: [{id: `${p}_venom`, points: 1}] },

      // Row 5: Pre-major
      { id: `${p}_void`, name: "Gem Focus I", type: "minor", maxPoints: 3, row: 5, col: 0,
        desc: "+0.5 AP to Gem slot per point", bonusPerPoint: 0.5, bonusType: "gemAP", requires: [{id: `${p}_shade2`, points: 2}] },
      { id: `${p}_precise`, name: "Lethality IV", type: "minor", maxPoints: 3, row: 5, col: 2,
        desc: "+0.5 AP to Weapon slot per point", bonusPerPoint: 0.5, bonusType: "weaponAP", requires: [{id: `${p}_gilded`, points: 2}] },
      { id: `${p}_blight`, name: "Gem Focus II", type: "minor", maxPoints: 3, row: 5, col: 4,
        desc: "+0.5 AP to Gem slot per point", bonusPerPoint: 0.5, bonusType: "gemAP", requires: [{id: `${p}_toxin2`, points: 2}] },

      // Row 6: Final major nodes before capstone
      { id: `${p}_assassinate`, name: "Pierce Mastery", type: "major", maxPoints: 1, row: 6, col: 1,
        desc: "+3 AP with Pierce weapons", bonusPerPoint: 3, bonusType: "pierceAP", requires: [{id: `${p}_void`, points: 2}, {id: `${p}_precise`, points: 2}] },
      { id: `${p}_execute`, name: "Execute", type: "major", maxPoints: 1, row: 6, col: 3,
        desc: "+5 AP vs low HP enemies", bonusPerPoint: 5, bonusType: "executeAP", requires: [{id: `${p}_precise`, points: 2}, {id: `${p}_blight`, points: 2}] },

      // Row 7: Capstone
      { id: `${p}_capstone`, name: "Final Silence", type: "capstone", maxPoints: 1, row: 7, col: 2,
        desc: "Words after empty slot: √ó2", bonusPerPoint: 1, bonusType: "capstone", requires: [{id: `${p}_assassinate`, points: 1}, {id: `${p}_execute`, points: 1}] },
    ]
  };
}

function createReedTree() {
  const p = 'rd';
  return {
    capstone: { id: 'one_with_nature', name: "One With Nature", desc: "Earth words buff Water +50%, vice versa" },
    nodes: [
      // Row 0: Start
      { id: `${p}_seedling`, name: "Growth", type: "minor", maxPoints: 1, row: 0, col: 2,
        desc: "+1 AP to Noun slot", bonusPerPoint: 1, bonusType: "nounAP", requires: [] },

      // Row 1: First split
      { id: `${p}_ancient`, name: "Nature I", type: "minor", maxPoints: 3, row: 1, col: 1,
        desc: "+0.5 AP to Noun slot per point", bonusPerPoint: 0.5, bonusType: "nounAP", requires: [{id: `${p}_seedling`, points: 1}] },
      { id: `${p}_flowing`, name: "Flow I", type: "minor", maxPoints: 3, row: 1, col: 3,
        desc: "+0.5 AP to Adjective slot per point", bonusPerPoint: 0.5, bonusType: "adjAP", requires: [{id: `${p}_seedling`, points: 1}] },

      // Row 2: Branch expansion
      { id: `${p}_root1`, name: "Nature II", type: "minor", maxPoints: 3, row: 2, col: 0,
        desc: "+0.5 AP to Noun slot per point", bonusPerPoint: 0.5, bonusType: "nounAP", requires: [{id: `${p}_ancient`, points: 2}] },
      { id: `${p}_primal`, name: "Primal I", type: "minor", maxPoints: 3, row: 2, col: 2,
        desc: "+0.5 AP to Weapon slot per point", bonusPerPoint: 0.5, bonusType: "weaponAP", requires: [{id: `${p}_ancient`, points: 2}, {id: `${p}_flowing`, points: 2}] },
      { id: `${p}_tide1`, name: "Flow II", type: "minor", maxPoints: 3, row: 2, col: 4,
        desc: "+0.5 AP to Adjective slot per point", bonusPerPoint: 0.5, bonusType: "adjAP", requires: [{id: `${p}_flowing`, points: 2}] },

      // Row 3: Major nodes
      { id: `${p}_terraform`, name: "Earth Mastery", type: "major", maxPoints: 2, row: 3, col: 0,
        desc: "+2 AP per Earth word per point", bonusPerPoint: 2, bonusType: "earthAP", requires: [{id: `${p}_root1`, points: 2}] },
      { id: `${p}_guardian`, name: "Guardian", type: "minor", maxPoints: 3, row: 3, col: 2,
        desc: "+3 Starting Gold per point", bonusPerPoint: 3, bonusType: "startGold", requires: [{id: `${p}_primal`, points: 2}] },
      { id: `${p}_deluge`, name: "Water Mastery", type: "major", maxPoints: 2, row: 3, col: 4,
        desc: "+2 AP per Water word per point", bonusPerPoint: 2, bonusType: "waterAP", requires: [{id: `${p}_tide1`, points: 2}] },

      // Row 4: Continue branches
      { id: `${p}_root2`, name: "Nature III", type: "minor", maxPoints: 3, row: 4, col: 0,
        desc: "+0.5 AP to Noun slot per point", bonusPerPoint: 0.5, bonusType: "nounAP", requires: [{id: `${p}_terraform`, points: 1}] },
      { id: `${p}_thorn1`, name: "Primal II", type: "minor", maxPoints: 3, row: 4, col: 1,
        desc: "+0.5 AP to Weapon slot per point", bonusPerPoint: 0.5, bonusType: "weaponAP", requires: [{id: `${p}_terraform`, points: 1}] },
      { id: `${p}_gilded`, name: "Gilded", type: "minor", maxPoints: 3, row: 4, col: 2,
        desc: "+5 Starting Gold per point", bonusPerPoint: 5, bonusType: "startGold", requires: [{id: `${p}_guardian`, points: 2}] },
      { id: `${p}_thorn2`, name: "Primal III", type: "minor", maxPoints: 3, row: 4, col: 3,
        desc: "+0.5 AP to Weapon slot per point", bonusPerPoint: 0.5, bonusType: "weaponAP", requires: [{id: `${p}_deluge`, points: 1}] },
      { id: `${p}_tide2`, name: "Flow III", type: "minor", maxPoints: 3, row: 4, col: 4,
        desc: "+0.5 AP to Adjective slot per point", bonusPerPoint: 0.5, bonusType: "adjAP", requires: [{id: `${p}_deluge`, points: 1}] },

      // Row 5: Pre-major
      { id: `${p}_mountain`, name: "Gem Focus I", type: "minor", maxPoints: 3, row: 5, col: 0,
        desc: "+0.5 AP to Gem slot per point", bonusPerPoint: 0.5, bonusType: "gemAP", requires: [{id: `${p}_root2`, points: 2}] },
      { id: `${p}_wild`, name: "Primal IV", type: "minor", maxPoints: 3, row: 5, col: 2,
        desc: "+0.5 AP to Weapon slot per point", bonusPerPoint: 0.5, bonusType: "weaponAP", requires: [{id: `${p}_gilded`, points: 2}] },
      { id: `${p}_ocean`, name: "Gem Focus II", type: "minor", maxPoints: 3, row: 5, col: 4,
        desc: "+0.5 AP to Gem slot per point", bonusPerPoint: 0.5, bonusType: "gemAP", requires: [{id: `${p}_tide2`, points: 2}] },

      // Row 6: Final major nodes before capstone
      { id: `${p}_wildgrowth`, name: "Blunt Mastery", type: "major", maxPoints: 1, row: 6, col: 1,
        desc: "+3 AP with Blunt weapons", bonusPerPoint: 3, bonusType: "bluntAP", requires: [{id: `${p}_mountain`, points: 2}, {id: `${p}_wild`, points: 2}] },
      { id: `${p}_harmony`, name: "Earth/Water Duality", type: "major", maxPoints: 1, row: 6, col: 3,
        desc: "+3 AP if both Earth and Water", bonusPerPoint: 3, bonusType: "dualAP", requires: [{id: `${p}_wild`, points: 2}, {id: `${p}_ocean`, points: 2}] },

      // Row 7: Capstone
      { id: `${p}_capstone`, name: "One With Nature", type: "capstone", maxPoints: 1, row: 7, col: 2,
        desc: "Earth/Water buff each other +50%", bonusPerPoint: 1, bonusType: "capstone", requires: [{id: `${p}_wildgrowth`, points: 1}, {id: `${p}_harmony`, points: 1}] },
    ]
  };
}

const SKILL_TREES = {
  "Graham Moor": createGrahamTree(),
  "Quivera": createQuiveraTree(),
  "Belle Lettres": createBelleTree(),
  "Alexandria Constanza": createAlexandriaTree(),
  "Caesura": createCaesuraTree(),
  "Reed": createReedTree()
};

// === 6 HEROES ===
const HEROES=[
  {
    id:"warrior",
    name:"Graham Moor",
    str:[E.PHYS,E.EARTH],
    weak:[E.POISON,E.DARK],
    good:"slash",
    bad:"magic",
    desc:"Captain of the Guard. Professional, precise. You've armed him for years‚Äîhe trusts your craft.",
    dialogue:[
      "Wordsmith. You know the drill.",
      "Sloppy grammar gets soldiers killed."
    ],
    victoryDialogue:"Job's done. Same as always. Reliable.",
    defeatDialogue:"I failed them. I failed... everyone.",
    runStartDialogue:"Wordsmith. Let's write some wrongs.",
    chapterDialogue:"One chapter down. But the book isn't finished.",
    shopDialogue:[
      "Restock. Regroup. We move at dawn.",
      "Gold well spent is lives saved.",
      "Don't waste my time. Or the kingdom's coin.",
      "The armory awaits. Choose wisely.",
      "Every tool has a purpose. Find yours.",
      "...Your selection. Not mine.",
      "The Guard trained me to prepare. So prepare.",
      "I've seen soldiers fall for want of a decent blade.",
      "Quivera always said I shop like I fight. Efficiently."
    ],
    passive:{
      name:"Intimidating",
      desc:"Enemy's HP decreased by 20%",
      phase:"ENEMY_SETUP",
      apply:(ctx)=>{
        ctx.enemy.hp = Math.round(ctx.enemy.hp * 0.8);
        return {message:"Intimidating: -20% Enemy HP"};
      }
    }
  },
  {
    id:"ranger",
    name:"Quivera",
    str:[E.LIGHTNING,E.EARTH],
    weak:[E.WATER,E.DARK],
    good:"pierce",
    bad:"blunt",
    desc:"Ex-Guard turned vigilante bard. You worked together before she left Verbia. Good to reunite.",
    dialogue:[
      "Just like old times, Wordsmith.",
      "Every battle has a tempo. Find it."
    ],
    victoryDialogue:"Still got it. Glad our paths crossed again.",
    defeatDialogue:"The song ends here. But the melody... it continues without me.",
    runStartDialogue:"The stage is set. One, two, three... begin.",
    chapterDialogue:"The tempo shifts. A new movement begins.",
    shopDialogue:[
      "A brief rest. One, two, three... ready.",
      "The merchants here still know my name. Good.",
      "Every arrow counts. Choose wisely.",
      "I've traveled far. These wares are familiar.",
      "Stock up. The rhythm waits for no one.",
      "Four beats to decide. Make them count.",
      "Beyond the Margin, shops like this saved my life. Twice.",
      "Graham would overthink this. I trust my instincts.",
      "The tempo of commerce. Quick, decisive, done."
    ],
    passive:{
      name:"Resourceful",
      desc:"Draw +1 T2 Word every round",
      phase:"SHOP_ENTRY",
      apply:(ctx)=>{
        const visibleCount = ctx.state.inv.filter(w => !w.hiddenInBank).length;
        if(visibleCount < INV_LIMIT){
          const t2Words = WORDS.filter(w => w.rarity === T.T1 && !w.hiddenInBank);
          if(t2Words.length > 0){
            const randomT2 = t2Words[Math.floor(Math.random() * t2Words.length)];
            ctx.state.inv.push({...randomT2});
            return {message:"Resourceful: Drew T2 Word"};
          }
        }
        return null;
      }
    }
  },
  {
    id:"mage",
    name:"Belle Lettres",
    str:[E.LIGHT,E.DARK,E.POISON], // Fixed strengths
    weak:[], // Weaknesses randomize each battle (set by passive)
    good:"magic",
    bad:"slash",
    desc:"Princess of Verbia. The Erratum attacked while her parents were in Prosa‚Äîtheir fate unknown. Her first real fight.",
    dialogue:[
      "Reality is a rough draft. Let's make revisions.",
      "I've read this story before. Time to edit the ending."
    ],
    victoryDialogue:"We won this chapter, Wordsmith. But the story isn't over. Not until I know.",
    defeatDialogue:"Another draft... discarded. Mother... Father...",
    runStartDialogue:"A new chapter begins. Let's hope for a better ending this time.",
    chapterDialogue:"We've turned the page. What comes next... I've read it. It gets worse.",
    shopDialogue:[
      "So this is what commerce looks like outside the Library...",
      "Fascinating inventory. I've only read about half of these.",
      "Shopping! Like a normal person! ...Is this normal?",
      "The royal treasury could buy all of this. ...Could have.",
      "I should take notes. For... academic purposes.",
      "Choose something. Anything. I trust your judgment more than mine.",
      "Chapter twelve of 'Commerce for Beginners' did NOT prepare me for this.",
      "I've read about haggling. Do we haggle? Should I haggle?",
      "Mother would be horrified to see me here. ...Good."
    ],
    passive:{
      name:"Sheltered",
      desc:"2 random weaknesses each battle",
      phase:"ENEMY_SETUP",
      apply:(ctx)=>{
        // Pick 2 random elements as weaknesses (excluding her strengths)
        const possibleWeaks = [E.PHYS, E.FIRE, E.WATER, E.EARTH, E.LIGHTNING];
        const shuffled = possibleWeaks.sort(() => Math.random() - 0.5);
        const weaknesses = shuffled.slice(0, 2);
        // Store on hero for this battle
        if(ctx.hero) ctx.hero.weak = weaknesses;
        const weakNames = weaknesses.map(e => EN[e]).join(', ');
        return {message:`Sheltered: Weak to ${weakNames}`};
      }
    }
  },
  {
    id:"paladin",
    name:"Alexandria Constanza",
    str:[E.LIGHT,E.PHYS],
    weak:[E.DARK,E.POISON],
    good:"blunt",
    bad:"pierce",
    desc:"Fresh from the Academy. Trained with your weapons, but this is her first real test of faith.",
    dialogue:[
      "By The Word, this entry shall be preserved.",
      "My oath binds me. My conviction drives me."
    ],
    victoryDialogue:"Another page preserved. The lexicon endures.",
    defeatDialogue:"My oath... I couldn't keep it. Forgive me, Word.",
    runStartDialogue:"By The Word, I am ready. Forge me a weapon, Wordsmith.",
    chapterDialogue:"A chapter preserved! By The Word, we advance!",
    shopDialogue:[
      "The Word provides. We must be worthy of it.",
      "Even templars require tools. No shame in preparation.",
      "Let us make haste. The Erratum do not rest.",
      "The Library's coffers fund our sacred work.",
      "Each purchase, a verse in our hymn of preservation.",
      "I defer to your wisdom, Wordsmith.",
      "The Academy taught us to be resourceful. This qualifies.",
      "By my oath, I shall not waste what The Word provides.",
      "My instructors spoke of you. They were not wrong."
    ],
    passive:{
      name:"Vigilant",
      desc:"The hero has +1 life during a run, can be defeated and continue",
      phase:"HERO_INIT",
      apply:(ctx)=>{
        ctx.state.lives = 2;
        return {message:"Vigilant: +1 life"};
      }
    }
  },
  {
    id:"assassin",
    name:"Caesura",
    str:[E.DARK,E.POISON],
    weak:[E.LIGHT,E.FIRE],
    good:"pierce",
    bad:"blunt",
    desc:"Emissary from Prosa. Brought warning of the Erratum‚Äîand news that the King and Queen's fate is unknown.",
    dialogue:[
      "...",
      "...So you're the Wordsmith."
    ],
    victoryDialogue:"... Prosa feared your name. ... Perhaps they were wrong to.",
    defeatDialogue:"...Prosa warned them. ...They didn't listen.",
    runStartDialogue:"...",
    chapterDialogue:"...One step closer. ...To the truth.",
    shopDialogue:[
      "...",
      "...Choose.",
      "...Time is short.",
      "...Prosa had better.",
      "...This will do.",
      "...",
      "...Verbian gold. ...It spends the same.",
      "...The silence here is... different.",
      "..."
    ],
    passive:{
      name:"Meticulous",
      desc:"Adjective slots: +0.25 W per Word",
      phase:"WORD_COUNT",
      apply:(ctx)=>{
        const adjectiveSlots = ['adj1', 'adj2', 'adj3', 'adj4'];
        if(adjectiveSlots.includes(ctx.slotKey)){
          const bonus = ctx.wCountDelta * 0.25;
          if(ctx.breakdown) ctx.breakdown.wordCount += bonus;
          return {message:`Meticulous: +0.25 Word count (${ctx.word.name})`, wordCountBonus: bonus};
        }
        return null;
      }
    }
  },
  {
    id:"druid",
    name:"Reed",
    str:[E.EARTH,E.WATER],
    weak:[E.FIRE,E.LIGHTNING],
    good:"blunt",
    bad:"magic",
    desc:"Ancient druid of Etymos. You've worked together across the ages. Old friends.",
    dialogue:[
      "The roots remember, old friend.",
      "Etymos calls us once more."
    ],
    victoryDialogue:"Another cycle together, Wordsmith. Our roots hold strong.",
    defeatDialogue:"The roots... wither. But new growth... will come.",
    runStartDialogue:"The roots call. Let us answer.",
    chapterDialogue:"The seasons turn. Growth continues.",
    shopDialogue:[
      "The land provides what we need, if we listen.",
      "Gold is a strange root. But it grows things.",
      "Rest now. The next storm approaches.",
      "Even ancient trees need nourishment.",
      "Patience. The right seed will present itself.",
      "The cycle continues. As it always has.",
      "I remember when these goods had no price. Only need.",
      "Etymos stirs. Even in commerce, I feel it.",
      "The young ones rush. I have learned to wait."
    ],
    passive:{
      name:"Rooted",
      desc:"The enemy becomes weak to the gem slot's element (disregarding resistances)",
      phase:"CALC_INIT",
      apply:(ctx)=>{
        if(ctx.sel.noun1 && ctx.sel.noun1.elem !== undefined){
          const gemElem = ctx.sel.noun1.elem;
          // Ensure weak array is properly copied and element is added if not present
          if(!ctx.enemy.weak.includes(gemElem)){
            ctx.enemy.weak = [...ctx.enemy.weak, gemElem];
          } else {
            // Even if element is already in weak, create a new array to avoid mutations
            ctx.enemy.weak = [...ctx.enemy.weak];
          }
          // Remove element from resistances
          ctx.enemy.res = ctx.enemy.res.filter(el => el !== gemElem);
          return {message:`Rooted: Enemy weak to ${EN[gemElem]}`};
        }
        return null;
      }
    }
  }
];

// === MODIFIER SYSTEM ===
// Phase-based modifier execution for hero passives, talents, and future boss modifiers
function applyModifiers(phase, context){
  const results = [];

  // Hero passive
  if(context.hero && context.hero.passive && context.hero.passive.phase === phase){
    const result = context.hero.passive.apply(context);
    if(result) results.push(result);
  }

  // Future: Talents, Boss modifiers, Status effects can be added here

  return results;
}

// Get the effective enemy state after applying display modifiers (e.g., Reed's gem weakness)
function getEffectiveEnemy(){
  if(!S.hero || !S.enemy) return S.enemy;
  const {hero: h, enemy: e} = getCombatants();
  // Apply CALC_INIT modifiers to get the modified enemy state for display
  applyModifiers('CALC_INIT', {hero: h, enemy: e, sel: S.sel, state: S});
  return e;
}

// === 15 REGULAR ENEMIES ===
// Each enemy has SET weaknesses and resistances for learnable patterns
// All enemies can appear in any round (selected randomly)
const ENEMIES = [
  // Balanced for ~4 weaknesses and ~4 resistances per element across 15 enemies
  // PHYS: 4 weak, 4 res | POISON: 4 weak, 4 res | FIRE: 4 weak, 4 res | WATER: 4 weak, 4 res
  // LIGHT: 4 weak, 4 res | DARK: 4 weak, 4 res | EARTH: 4 weak, 3 res | LIGHTNING: 4 weak, 3 res
  {
    id: "vowel_goblin",
    name: "Vowel Goblin",
    hp: 45,
    desc: "Hoards vowels, leaving words voiceless.",
    dialogue: ["Ay, eee... I owe you? Why?", "Gv m yr vwls!"],
    weak: [E.FIRE, E.DARK],       // Goblins fear fire and darkness
    res: [E.EARTH, E.POISON]     // Cave dwellers, toxic resilience
  },
  {
    id: "ghost",
    name: "Ghost",
    hp: 40,
    desc: "A phantom word that refused to be erased.",
    dialogue: ["Dord... dord... the dictionary deleted me, but I'm still here...", "I was real once... wasn't I? Someone used me... someone must have..."],
    weak: [E.LIGHT, E.LIGHTNING], // Light dispels, lightning disrupts
    res: [E.PHYS, E.DARK]        // Intangible, shadow creature
  },
  {
    id: "synonym_roll",
    name: "Synonym Roll",
    hp: 50,
    desc: "Says everything twice. Differently. Redundantly.",
    dialogue: ["I'm on a roll! A bun! A bread thing!", "Prepare to die! Perish! Expire! Cease!"],
    weak: [E.FIRE, E.POISON],    // Burns easily, molds quickly
    res: [E.WATER, E.LIGHT]      // Keeps fresh with water, warm bread
  },
  {
    id: "comma_chameleon",
    name: "Comma Chameleon",
    hp: 45,
    desc: "Causes hesitation, and pauses, everywhere.",
    dialogue: ["Pause, for, effect...", "Let's, take, a, break, shall, we?"],
    weak: [E.PHYS, E.EARTH],     // Direct hits, grounded
    res: [E.LIGHT, E.POISON]     // Camouflage in light, toxic skin
  },
  {
    id: "webster_spiderling",
    name: "Webster Spiderling",
    hp: 55,
    desc: "Spins webs of tangled definitions.",
    dialogue: ["Per the dictionary, you're doomed!", "Let me define your defeat!"],
    weak: [E.FIRE, E.WATER],     // Burns webs, drowns easily
    res: [E.POISON, E.DARK]      // Venomous, lurks in shadows
  },
  {
    id: "hyphen_hyena",
    name: "Hyphen-Hyena",
    hp: 60,
    desc: "A two-faced, double-dealing, compound beast.",
    dialogue: ["Heh-heh-heh-heh!", "I'm well-armed and battle-ready!"],
    weak: [E.POISON, E.WATER],   // Vulnerable to toxins and water
    res: [E.PHYS, E.FIRE]        // Tough hide, hot savanna creature
  },
  {
    id: "pun_goblin",
    name: "Pun Goblin",
    hp: 55,
    desc: "Thinks it's punny. Desperately.",
    dialogue: ["I'm dead seri-puns!", "Prepare to pun-ish you! Get it? GET IT?!"],
    weak: [E.PHYS, E.LIGHT],     // Direct attacks and illumination
    res: [E.LIGHTNING, E.EARTH] // Quick reflexes, earthy nature
  },
  {
    id: "apostro_fiend",
    name: "Apostro-Fiend",
    hp: 60,
    desc: "Take's what's your's. Possessive demon.",
    dialogue: ["Your'e making a mistake!", "Its' time to die! Your's truly!"],
    weak: [E.LIGHT, E.WATER],    // Holy water purifies demons
    res: [E.DARK, E.FIRE]        // Demonic, hellfire resistant
  },
  {
    id: "idiomatic_undead",
    name: "Idiomatic Undead",
    hp: 70,
    desc: "Shambling corpse animated by dead metaphors.",
    dialogue: ["You've opened a can of worms, and I've got a bone to pick!", "When it rains, it pours... YOUR BLOOD!"],
    weak: [E.FIRE, E.LIGHTNING], // Burns and disrupts undeath
    res: [E.POISON, E.PHYS]      // Already rotting, can't hurt bones
  },
  {
    id: "vulgar_vandal",
    name: "Vulgar Vandal",
    hp: 65,
    desc: "Creature of censored rage. Unfit for print.",
    dialogue: ["#@$%*!!!", "I'll @#$%ing end you, you piece of @#$%!"],
    weak: [E.EARTH, E.DARK],     // Street punk vs nature and shadows
    res: [E.LIGHTNING, E.PHYS]   // Quick, tough street fighter
  },
  {
    id: "double_negative",
    name: "Double Negative",
    hp: 70,
    desc: "A paradox that can't not exist.",
    dialogue: ["I ain't not gonna not destroy you!", "You can't never win nothing!"],
    weak: [E.POISON, E.LIGHTNING], // Logic poison, electrical disruption
    res: [E.WATER, E.EARTH]      // Flows around, grounded in confusion
  },
  {
    id: "run_on_sentence",
    name: "Run-On Sentence",
    hp: 75,
    desc: "Never stops never pauses keeps going and going and‚Äî",
    dialogue: ["And then I'll hit you and then I'll hit you again and also‚Äî", "Wait I'm not done because there's more to say and‚Äî"],
    weak: [E.PHYS, E.DARK],      // Cut it short, silence it
    res: [E.FIRE, E.LIGHT]       // Energetic, bright personality
  },
  {
    id: "split_infinitive",
    name: "Split Infinitive",
    hp: 70,
    desc: "To boldly split what should never be split.",
    dialogue: ["I'm going to completely destroy you!", "Prepare to fully and utterly experience defeat!"],
    weak: [E.EARTH, E.WATER],    // Ground the split, wash away
    res: [E.DARK, E.POISON]      // Shadowy grammar, toxic constructs
  },
  {
    id: "mixed_metaphor",
    name: "Mixed Metaphor",
    hp: 75,
    desc: "A chaotic mashup of incompatible imagery.",
    dialogue: ["We'll burn that bridge when we cross it!", "You've let the cat out of the frying pan now!"],
    weak: [E.PHYS, E.POISON],    // Direct hits cut through, toxic logic
    res: [E.WATER, E.LIGHT]      // Fluid meaning, bright confusion
  },
  {
    id: "passive_voice",
    name: "Passive Voice",
    hp: 80,
    desc: "Mistakes were made. By whom? It is unclear.",
    dialogue: ["Your defeat has been predetermined. By forces. Unnamed forces.", "Responsibility will not be taken. Blame will be deflected. You will be defeated."],
    weak: [E.LIGHTNING, E.DARK], // Active energy, shadow obscures
    res: [E.PHYS, E.EARTH]       // Intangible agency, grounded inaction
  }
];

// Legacy function for backwards compatibility - now uses preset values
function randomizeEnemyElements(enemy) {
  // Enemies now have preset weaknesses/resistances for learnable patterns
  // This function is kept for any dynamic enemy generation needs
  if (enemy.weak && enemy.res) return; // Already has presets

  const allElements = [E.PHYS, E.POISON, E.FIRE, E.WATER, E.LIGHT, E.DARK, E.EARTH, E.LIGHTNING];
  const shuffled = [...allElements].sort(() => Math.random() - 0.5);

  const numWeak = 2;
  const numRes = 2;

  enemy.weak = shuffled.slice(0, numWeak);
  enemy.res = shuffled.slice(numWeak, numWeak + numRes);

  // Attack element from remaining elements
  const remaining = shuffled.slice(numWeak + numRes);
  enemy.atk = remaining[0] || E.PHYS;
}

// === CHAPTER BOSSES ===
// Unique bosses that appear at round 9, 18, 27, etc. (end of each chapter)
// They cycle without repeating until the pool is exhausted
const CHAPTER_BOSSES = [
  {
    id: 'cinna_antony',
    name: 'Cinna & Antony',
    desc: 'Warring siblings of opposite meaning. Forever arguing.',
    ability: {
      name: 'Duality',
      desc: 'All the same element or two opposite elements only'
    },
    dialogue: [
      "Cinna: The Wordsmith! / Antony: The so-called Wordsmith.",
      "Cinna: We'll destroy you! / Antony: Or maybe we won't."
    ],
  },
  {
    id: 'red_aktins',
    name: 'Red Aktins',
    desc: 'The Censor. Strikes words from existence.',
    ability: {
      name: 'Redacted',
      desc: 'One random adjective slot is [REDACTED] for this fight'
    },
    dialogue: [
      "This conversation has been flagged for [REDACTED]. Your [REDACTED] will be [REDACTED].",
      "Some words are better left... unwritten. Yours, for example. All of them."
    ],
  },
  {
    id: 'plague_doctor',
    name: 'The Plague Doctor',
    desc: 'Stealer of styles. Wears others\' words like masks.',
    ability: {
      name: 'Plagiarized',
      desc: 'Immune to your strongest Element'
    },
    dialogue: [
      "Your style... I'll take it.",
      "Imitation is the sincerest form of... theft."
    ],
  },
  {
    id: 'oxy',
    name: 'Oxy',
    desc: 'A living oxymoron. Clearly confused. Deafeningly silent.',
    ability: {
      name: 'Contradiction',
      desc: 'Opposing Elements (Fire/Water, Light/Dark, etc.) deal 0 damage'
    },
    dialogue: [
      "Awfully good to meet you, Wordsmith...",
      "Your living death awaits. Bittersweet, isn't it?"
    ],
  },
  {
    id: 'dotdotdot',
    name: 'Dotdotdot',
    desc: 'Never finishes a thought... or lets you finish...',
    ability: {
      name: 'Trailing Off',
      desc: 'Gem slot is ignored...',
      icon: '...'
    },
    dialogue: [
      "Ah, the famous Wordsmith! I've heard so much about... wait, I had something for this...",
      "This is the part where I... where I... hmm, it was right on the tip of my..."
    ],
  }
];

// === SECRET CHAPTER BOSS: THE SILENT KNIGHT ===
// 5% chance to replace the normal chapter boss on any chapter boss round
// Achievement: "Knight to Remember"
const SECRET_CHAPTER_BOSS = {
  id: 'silent_knight',
  name: 'The Silent Knight',
  desc: 'The K is silent. So is he.',
  dialogue: ["...", "......"],
  weak: [],
  res: [E.PHYS, E.POISON, E.FIRE, E.WATER, E.LIGHT, E.DARK, E.EARTH, E.LIGHTNING],
  isSecretBoss: true,
  hpMultiplier: 1.5, // 50% more HP than normal chapter bosses
  ability: {
    name: 'Wordless',
    desc: 'Immune to words with fewer than 6 letters',
    icon: 'ü§´'
  }
};
const SECRET_BOSS_SPAWN_CHANCE = 0.05; // 5% chance on chapter boss rounds

// === CHARACTER PORTRAITS (Abstract Side Profile Silhouettes) ===
// Minimalist side profiles facing right, no outlines, 2-3 colors blended, intricate layered shapes
const PORTRAITS = {
  // Heroes - Completely unique silhouettes for each character
  // Graham Moor (Warrior) - Blocky, heavy armored with flat-top helmet and thick neck
  warrior: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-w"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="w-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#1f2937"/><stop offset="100%" stop-color="#0f172a"/></linearGradient><linearGradient id="w1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#6b7280"/><stop offset="100%" stop-color="#374151"/></linearGradient><linearGradient id="w2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#4b5563"/><stop offset="100%" stop-color="#1f2937"/></linearGradient></defs><rect width="120" height="120" fill="url(#w-bg)"/><g clip-path="url(#c-w)"><rect width="120" height="120" fill="url(#w-bg)"/><path d="M0,120 L0,75 Q8,68 18,65 L40,68 Q48,78 52,100 L55,120 Z" fill="url(#w1)" opacity="0.5"/><path d="M18,65 Q15,55 18,45 L22,38 L30,32 L75,32 L82,40 Q86,50 84,62 Q78,70 65,75 L45,78 Q30,78 18,65 Z" fill="url(#w1)"/><path d="M30,32 L75,32 L78,25 L72,18 L35,18 L28,25 L30,32 Z" fill="url(#w2)"/><path d="M35,18 L72,18 L70,12 L38,12 L35,18 Z" fill="url(#w1)" opacity="0.7"/><path d="M75,32 L82,40 Q90,48 92,60 Q92,72 85,82 L78,78 Q82,70 82,60 Q82,50 75,32 Z" fill="url(#w2)" opacity="0.6"/><path d="M65,52 Q75,50 85,58 Q92,68 86,80 Q78,86 68,82 Q62,76 65,52 Z" fill="url(#w1)"/><path d="M68,82 Q76,92 70,105 Q62,115 50,110 Q60,100 66,90 Q68,86 68,82 Z" fill="url(#w2)"/><path d="M50,110 Q42,115 30,112 Q26,108 36,104 Q46,103 50,110 Z" fill="url(#w1)" opacity="0.8"/><path d="M30,50 Q42,44 55,48 Q52,60 48,72 Q44,82 38,78 Q32,72 30,50 Z" fill="url(#w2)" opacity="0.4"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#4b5563" stroke-width="3"/></svg>`,

  // Quivera (Ranger) - Sleek hooded figure with prominent bow curve extending right
  ranger: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-r"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="r-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#14532d"/><stop offset="100%" stop-color="#052e16"/></linearGradient><linearGradient id="r1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#22c55e"/><stop offset="100%" stop-color="#15803d"/></linearGradient><linearGradient id="r2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#16a34a"/><stop offset="100%" stop-color="#166534"/></linearGradient></defs><rect width="120" height="120" fill="url(#r-bg)"/><g clip-path="url(#c-r)"><rect width="120" height="120" fill="url(#r-bg)"/><path d="M5,120 L5,85 Q12,75 22,72 L32,74 Q36,84 38,100 L40,120 Z" fill="url(#r1)" opacity="0.4"/><path d="M18,70 Q14,55 18,40 Q24,25 42,18 L48,8 L52,18 Q48,28 46,40 Q44,52 50,65 Q44,74 34,78 L22,76 Q18,74 18,70 Z" fill="url(#r1)"/><path d="M42,18 L48,8 L52,18 Q50,25 48,35 Q46,45 52,58 L46,62 Q44,52 44,40 Q44,28 42,18 Z" fill="url(#r2)"/><path d="M52,18 Q58,12 65,18 Q68,28 68,42 Q64,35 60,30 Q56,22 52,18 Z" fill="url(#r1)" opacity="0.5"/><path d="M55,52 Q62,48 72,54 Q78,64 72,74 Q66,78 58,74 Q52,68 55,52 Z" fill="url(#r1)"/><path d="M58,74 Q64,82 60,92 Q54,98 46,96 Q52,88 56,80 Q58,77 58,74 Z" fill="url(#r2)"/><path d="M46,96 Q40,100 32,100 Q28,96 36,92 Q42,91 46,96 Z" fill="url(#r1)" opacity="0.8"/><path d="M26,45 Q34,38 44,40 Q42,50 38,60 Q34,68 30,64 Q26,58 26,45 Z" fill="url(#r2)" opacity="0.5"/><path d="M72,54 Q82,42 95,35 Q108,32 115,45 Q118,60 110,78 Q100,95 85,100 Q95,85 100,70 Q105,55 100,45 Q95,40 85,48 Q78,54 72,54 Z" fill="url(#r1)" opacity="0.5"/><path d="M95,35 Q102,30 108,35 Q112,42 108,52 Q104,45 98,42 Q95,38 95,35 Z" fill="url(#r2)" opacity="0.4"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#22c55e" stroke-width="3"/></svg>`,

  // Belle Lettres (Mage) - Elegant flowing silhouette with elaborate upswept hair and delicate features
  mage: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-m"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="m-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#431407"/><stop offset="100%" stop-color="#1c0a00"/></linearGradient><linearGradient id="m1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#fb923c"/><stop offset="100%" stop-color="#ea580c"/></linearGradient><linearGradient id="m2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#f97316"/><stop offset="100%" stop-color="#c2410c"/></linearGradient></defs><rect width="120" height="120" fill="url(#m-bg)"/><g clip-path="url(#c-m)"><rect width="120" height="120" fill="url(#m-bg)"/><path d="M8,120 L8,95 Q14,85 24,82 L34,84 Q38,94 40,108 L42,120 Z" fill="url(#m1)" opacity="0.35"/><path d="M22,80 Q18,65 24,50 Q32,35 50,30 Q62,28 72,35 Q66,45 64,58 Q62,72 68,85 Q62,92 50,95 L30,92 Q24,88 22,80 Z" fill="url(#m1)"/><path d="M50,30 Q62,25 74,32 L78,42 Q72,36 66,35 Q58,35 52,42 L50,30 Z" fill="url(#m2)"/><path d="M40,12 Q48,8 58,12 Q52,20 50,30 L46,32 Q44,22 40,12 Z" fill="url(#m1)" opacity="0.7"/><path d="M58,12 Q68,6 80,15 Q88,25 85,40 Q80,32 75,28 Q68,22 58,12 Z" fill="url(#m2)" opacity="0.6"/><path d="M80,15 Q92,20 98,35 Q95,28 88,24 Q82,20 80,15 Z" fill="url(#m1)" opacity="0.4"/><path d="M68,55 Q78,52 88,62 Q94,74 86,86 Q78,92 68,86 Q62,78 68,55 Z" fill="url(#m1)"/><path d="M68,86 Q76,96 70,108 Q62,116 52,112 Q62,102 66,92 Q68,89 68,86 Z" fill="url(#m2)"/><path d="M52,112 Q44,116 34,114 Q30,110 40,106 Q48,105 52,112 Z" fill="url(#m1)" opacity="0.8"/><path d="M32,55 Q42,48 54,52 Q50,64 46,76 Q42,86 36,82 Q30,76 32,55 Z" fill="url(#m2)" opacity="0.45"/><path d="M5,70 Q8,55 15,45 Q12,58 10,72 Q8,82 5,70 Z" fill="url(#m1)" opacity="0.25"/><path d="M4,88 Q6,75 12,65 Q10,78 8,90 Q6,98 4,88 Z" fill="url(#m2)" opacity="0.2"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#f97316" stroke-width="3"/></svg>`,

  // Alexandria Constanza (Paladin) - Regal profile with large radiant halo behind head
  paladin: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-p"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="p-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#fef3c7"/><stop offset="100%" stop-color="#fde68a"/></linearGradient><linearGradient id="p1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#fbbf24"/><stop offset="100%" stop-color="#f59e0b"/></linearGradient><linearGradient id="p2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#f59e0b"/><stop offset="100%" stop-color="#d97706"/></linearGradient></defs><rect width="120" height="120" fill="url(#p-bg)"/><g clip-path="url(#c-p)"><rect width="120" height="120" fill="url(#p-bg)"/><circle cx="55" cy="45" r="35" fill="url(#p1)" opacity="0.25"/><circle cx="55" cy="45" r="28" fill="url(#p2)" opacity="0.2"/><path d="M15,120 L15,95 Q22,85 32,82 L42,84 Q46,94 48,108 L50,120 Z" fill="url(#p1)" opacity="0.4"/><path d="M28,80 Q24,65 30,50 Q38,35 55,30 Q70,28 80,40 Q74,52 72,65 Q70,78 76,90 Q70,98 58,102 L38,98 Q32,94 28,80 Z" fill="url(#p1)"/><path d="M55,30 Q70,24 82,36 L86,48 Q80,40 72,38 Q64,38 58,46 L55,30 Z" fill="url(#p2)"/><path d="M55,30 Q60,22 68,20 Q62,26 58,32 L55,30 Z" fill="url(#p1)" opacity="0.6"/><path d="M76,58 Q86,54 96,65 Q102,78 94,92 Q86,98 76,92 Q70,84 76,58 Z" fill="url(#p1)"/><path d="M76,92 Q84,102 78,114 Q70,120 60,118 Q70,108 74,98 Q76,95 76,92 Z" fill="url(#p2)"/><path d="M60,118 Q52,120 42,118 Q38,114 48,110 Q56,109 60,118 Z" fill="url(#p1)" opacity="0.8"/><path d="M38,55 Q48,48 60,52 Q56,65 52,78 Q48,88 42,84 Q36,78 38,55 Z" fill="url(#p2)" opacity="0.45"/><path d="M86,48 Q96,58 98,75 Q98,90 90,102 Q84,96 86,86 Q88,75 86,48 Z" fill="url(#p1)" opacity="0.3"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#fbbf24" stroke-width="3"/></svg>`,

  // Caesura (Assassin) - Minimal, subtle profile with face-covering mask/scarf, lower positioned
  assassin: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-a"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="a-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#1e1b4b"/><stop offset="100%" stop-color="#0f0a1e"/></linearGradient><linearGradient id="a1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#a855f7"/><stop offset="100%" stop-color="#7e22ce"/></linearGradient><linearGradient id="a2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#9333ea"/><stop offset="100%" stop-color="#581c87"/></linearGradient></defs><rect width="120" height="120" fill="url(#a-bg)"/><g clip-path="url(#c-a)"><rect width="120" height="120" fill="url(#a-bg)"/><path d="M20,120 L20,100 Q26,92 34,88 L42,90 Q46,98 48,110 L50,120 Z" fill="url(#a1)" opacity="0.3"/><path d="M32,86 Q28,72 34,58 Q42,44 58,40 Q72,38 82,50 Q76,60 74,72 Q72,84 78,96 Q72,104 60,108 L42,104 Q36,100 32,86 Z" fill="url(#a1)"/><path d="M58,40 Q72,34 84,46 L88,58 Q82,50 74,48 Q66,48 60,56 L58,40 Z" fill="url(#a2)"/><path d="M58,40 Q64,32 72,30 Q78,36 80,45 L84,46 Q80,38 74,34 Q66,32 58,40 Z" fill="url(#a1)" opacity="0.5"/><path d="M34,75 Q28,85 20,88 L15,82 Q22,78 28,70 L34,75 Z" fill="url(#a2)" opacity="0.4"/><path d="M78,65 Q88,62 98,72 Q104,84 96,98 Q88,104 78,98 Q72,90 78,65 Z" fill="url(#a1)"/><path d="M78,98 Q86,108 80,118 L62,120 Q72,112 76,104 Q78,101 78,98 Z" fill="url(#a2)"/><path d="M42,62 Q52,56 64,60 Q60,72 56,84 Q52,94 46,90 Q40,84 42,62 Z" fill="url(#a2)" opacity="0.4"/><path d="M88,58 Q98,68 100,85 Q100,100 92,110 Q86,104 88,94 Q90,82 88,58 Z" fill="url(#a1)" opacity="0.25"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#a855f7" stroke-width="3"/></svg>`,

  // Reed (Druid) - Wild organic shape with large prominent antlers/branches
  druid: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-d"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="d-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#134e4a"/><stop offset="100%" stop-color="#042f2e"/></linearGradient><linearGradient id="d1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#2dd4bf"/><stop offset="100%" stop-color="#14b8a6"/></linearGradient><linearGradient id="d2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#14b8a6"/><stop offset="100%" stop-color="#0d9488"/></linearGradient></defs><rect width="120" height="120" fill="url(#d-bg)"/><g clip-path="url(#c-d)"><rect width="120" height="120" fill="url(#d-bg)"/><path d="M12,120 L12,95 Q18,85 28,82 L38,84 Q42,94 44,108 L46,120 Z" fill="url(#d1)" opacity="0.35"/><path d="M26,80 Q22,65 28,50 Q36,35 52,30 Q66,28 76,40 Q70,52 68,65 Q66,78 72,90 Q66,98 54,102 L36,98 Q30,94 26,80 Z" fill="url(#d1)"/><path d="M52,30 Q66,24 78,36 L82,48 Q76,40 68,38 Q60,38 54,46 L52,30 Z" fill="url(#d2)"/><path d="M45,30 Q42,20 35,12 Q28,5 18,8 Q12,15 15,25 Q20,20 28,18 Q38,18 45,30 Z" fill="url(#d1)" opacity="0.7"/><path d="M35,12 Q30,5 22,5 Q15,8 18,18 Q22,12 28,10 Q32,10 35,12 Z" fill="url(#d2)" opacity="0.5"/><path d="M18,8 Q10,5 5,12 Q5,20 12,22 Q8,15 12,12 Q15,10 18,8 Z" fill="url(#d1)" opacity="0.4"/><path d="M52,30 Q58,22 68,18 Q80,15 92,22 Q100,32 95,45 Q88,35 78,32 Q68,32 58,40 L52,30 Z" fill="url(#d1)" opacity="0.6"/><path d="M68,18 Q78,12 90,15 Q98,22 95,35 Q90,25 82,22 Q74,20 68,18 Z" fill="url(#d2)" opacity="0.45"/><path d="M90,15 Q100,12 108,20 Q112,30 105,38 Q102,28 96,22 Q92,18 90,15 Z" fill="url(#d1)" opacity="0.35"/><path d="M72,58 Q82,55 92,65 Q98,78 90,92 Q82,98 72,92 Q66,84 72,58 Z" fill="url(#d1)"/><path d="M72,92 Q80,102 74,114 Q66,120 56,118 Q66,108 70,98 Q72,95 72,92 Z" fill="url(#d2)"/><path d="M56,118 Q48,120 38,118 Q34,114 44,110 Q52,109 56,118 Z" fill="url(#d1)" opacity="0.8"/><path d="M36,55 Q46,48 58,52 Q54,65 50,78 Q46,88 40,84 Q34,78 36,55 Z" fill="url(#d2)" opacity="0.45"/><path d="M82,48 Q92,58 94,75 Q94,90 86,102 Q80,96 82,86 Q84,75 82,48 Z" fill="url(#d1)" opacity="0.3"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#14b8a6" stroke-width="3"/></svg>`,

  // Enemies - Abstract side profile silhouettes (facing right, no outlines, 2-3 gradient colors)
  vowel_goblin: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-vg"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="vg-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#3d5c1f"/><stop offset="100%" stop-color="#1a2e0d"/></linearGradient><linearGradient id="vg1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#7cb342"/><stop offset="100%" stop-color="#558b2f"/></linearGradient><linearGradient id="vg2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#689f38"/><stop offset="100%" stop-color="#33691e"/></linearGradient></defs><rect width="120" height="120" fill="url(#vg-bg)"/><g clip-path="url(#c-vg)"><rect width="120" height="120" fill="url(#vg-bg)"/><path d="M25,85 Q20,75 22,65 Q28,55 40,50 Q50,48 55,55 Q52,62 48,70 Q45,78 40,82 L28,84 Q26,85 25,85 Z" fill="url(#vg1)"/><path d="M40,50 Q52,42 65,48 Q58,55 55,62 Q52,70 55,78 L48,82 Q45,75 44,65 Q43,55 40,50 Z" fill="url(#vg2)"/><path d="M55,65 Q62,60 70,64 Q74,70 70,76 Q65,78 60,74 Q56,70 55,65 Z" fill="url(#vg1)"/><path d="M60,74 Q65,80 62,88 Q58,92 52,90 Q55,85 57,80 Q59,77 60,74 Z" fill="url(#vg2)"/><path d="M52,90 Q48,94 42,95 Q38,92 44,88 Q49,87 52,90 Z" fill="url(#vg1)" opacity="0.8"/><path d="M35,58 Q42,52 50,52 Q48,58 45,65 Q42,72 38,70 Q35,66 35,58 Z" fill="url(#vg2)" opacity="0.6"/><path d="M45,35 Q55,28 65,35 Q60,40 55,48 L50,48 Q48,42 45,35 Z" fill="url(#vg1)" opacity="0.7"/><path d="M55,28 Q65,22 75,30 Q70,38 65,42 L60,40 Q58,34 55,28 Z" fill="url(#vg2)" opacity="0.5"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#7cb342" stroke-width="3"/></svg>`,

  ghost: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-gh"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="gh-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#1e293b"/><stop offset="100%" stop-color="#0f172a"/></linearGradient><linearGradient id="gh1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#e2e8f0"/><stop offset="100%" stop-color="#94a3b8"/></linearGradient><linearGradient id="gh2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#cbd5e1"/><stop offset="100%" stop-color="#64748b"/></linearGradient></defs><rect width="120" height="120" fill="url(#gh-bg)"/><g clip-path="url(#c-gh)"><rect width="120" height="120" fill="url(#gh-bg)"/><path d="M20,120 Q18,100 22,80 Q28,60 45,45 Q58,35 70,40 Q62,52 58,68 Q55,85 60,100 L55,120 Z" fill="url(#gh1)" opacity="0.6"/><path d="M45,45 Q60,32 78,42 Q68,55 64,72 Q60,88 65,105 L58,110 Q55,95 54,78 Q53,60 45,45 Z" fill="url(#gh2)" opacity="0.5"/><path d="M65,60 Q72,55 80,60 Q85,68 80,76 Q74,78 68,74 Q64,68 65,60 Z" fill="url(#gh1)" opacity="0.7"/><path d="M68,74 Q75,82 70,92 Q64,98 58,95 Q62,88 65,80 Q67,77 68,74 Z" fill="url(#gh2)" opacity="0.6"/><path d="M30,65 Q38,55 48,54 Q45,65 42,78 Q38,88 32,85 Q28,78 30,65 Z" fill="url(#gh1)" opacity="0.4"/><path d="M78,42 Q90,48 95,65 Q95,82 88,95 Q82,88 80,76 Q82,62 78,42 Z" fill="url(#gh2)" opacity="0.3"/><path d="M35,110 Q38,95 42,115 Q45,120 40,120 L35,120 Z" fill="url(#gh1)" opacity="0.5"/><path d="M70,108 Q75,98 80,115 L80,120 L72,120 Q70,115 70,108 Z" fill="url(#gh2)" opacity="0.4"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#94a3b8" stroke-width="3"/></svg>`,

  synonym_roll: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-sr"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="sr-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#78350f"/><stop offset="100%" stop-color="#451a03"/></linearGradient><linearGradient id="sr1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#fbbf24"/><stop offset="100%" stop-color="#d97706"/></linearGradient><linearGradient id="sr2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#f59e0b"/><stop offset="100%" stop-color="#b45309"/></linearGradient></defs><rect width="120" height="120" fill="url(#sr-bg)"/><g clip-path="url(#c-sr)"><rect width="120" height="120" fill="url(#sr-bg)"/><path d="M25,75 Q20,60 28,45 Q40,30 60,28 Q75,28 82,40 Q72,50 68,62 Q65,75 70,88 L58,92 Q50,82 48,68 Q46,55 38,50 Q30,55 28,68 Q28,78 32,88 L25,90 Q22,82 25,75 Z" fill="url(#sr1)"/><path d="M60,28 Q78,25 90,38 Q82,52 78,68 Q75,82 80,95 L72,98 Q68,85 68,70 Q68,55 60,28 Z" fill="url(#sr2)"/><path d="M70,58 Q78,52 88,58 Q92,66 88,74 Q82,78 75,74 Q70,68 70,58 Z" fill="url(#sr1)"/><path d="M75,74 Q82,82 78,92 Q72,98 65,95 Q70,88 72,80 Q74,77 75,74 Z" fill="url(#sr2)"/><path d="M38,42 Q48,35 58,38 Q55,48 50,58 Q45,68 40,65 Q36,58 38,42 Z" fill="url(#sr2)" opacity="0.7"/><path d="M45,25 Q55,18 68,22 Q62,32 58,28 Q52,25 45,25 Z" fill="url(#sr1)" opacity="0.5"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#fbbf24" stroke-width="3"/></svg>`,

  comma_chameleon: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-cc"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="cc-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#134e4a"/><stop offset="100%" stop-color="#042f2e"/></linearGradient><linearGradient id="cc1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#2dd4bf"/><stop offset="100%" stop-color="#0d9488"/></linearGradient><linearGradient id="cc2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#14b8a6"/><stop offset="100%" stop-color="#0f766e"/></linearGradient></defs><rect width="120" height="120" fill="url(#cc-bg)"/><g clip-path="url(#c-cc)"><rect width="120" height="120" fill="url(#cc-bg)"/><path d="M18,78 Q12,62 18,45 Q28,28 50,22 Q68,18 80,30 Q70,45 65,62 Q60,78 68,92 L52,98 Q45,85 45,68 Q45,52 38,45 Q30,50 28,65 Q28,80 35,95 L22,95 Q15,88 18,78 Z" fill="url(#cc1)"/><path d="M50,22 Q72,15 88,32 Q78,50 72,68 Q68,85 75,100 L62,105 Q58,90 58,72 Q58,55 50,22 Z" fill="url(#cc2)"/><path d="M72,55 Q80,48 92,55 Q98,65 92,75 Q84,80 76,75 Q70,68 72,55 Z" fill="url(#cc1)"/><path d="M76,75 Q85,85 80,98 Q72,105 64,102 Q70,94 74,84 Q76,80 76,75 Z" fill="url(#cc2)"/><path d="M35,38 Q48,30 60,35 Q55,48 50,60 Q44,72 38,68 Q32,60 35,38 Z" fill="url(#cc2)" opacity="0.6"/><path d="M92,55 Q100,48 108,55 Q105,62 100,58 Q95,54 92,55 Z" fill="url(#cc1)" opacity="0.7"/><path d="M5,65 Q12,55 8,70 Q6,78 5,75 L5,65 Z" fill="url(#cc2)" opacity="0.4"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#2dd4bf" stroke-width="3"/></svg>`,

  webster_spiderling: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-ws"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="ws-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#1c1917"/><stop offset="100%" stop-color="#0c0a09"/></linearGradient><linearGradient id="ws1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#57534e"/><stop offset="100%" stop-color="#292524"/></linearGradient><linearGradient id="ws2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#44403c"/><stop offset="100%" stop-color="#1c1917"/></linearGradient></defs><rect width="120" height="120" fill="url(#ws-bg)"/><g clip-path="url(#c-ws)"><rect width="120" height="120" fill="url(#ws-bg)"/><path d="M30,70 Q25,55 32,42 Q42,30 58,28 Q72,28 80,42 Q72,52 68,65 Q65,78 72,90 L58,95 Q52,82 52,68 Q52,55 45,48 Q38,52 35,65 Q35,78 42,92 L30,92 Q25,82 30,70 Z" fill="url(#ws1)"/><path d="M58,28 Q78,25 92,42 Q82,58 78,75 Q75,90 82,105 L68,108 Q64,92 65,75 Q66,58 58,28 Z" fill="url(#ws2)"/><path d="M70,58 Q78,50 90,58 Q95,68 90,78 Q82,82 74,78 Q68,70 70,58 Z" fill="url(#ws1)"/><path d="M74,78 Q82,88 78,100 Q70,108 62,105 Q68,96 72,86 Q74,82 74,78 Z" fill="url(#ws2)"/><path d="M8,45 Q18,35 28,45 Q22,55 15,50 Q10,48 8,45 Z" fill="url(#ws1)" opacity="0.6"/><path d="M5,70 Q15,60 25,72 Q18,82 10,78 Q5,75 5,70 Z" fill="url(#ws2)" opacity="0.5"/><path d="M95,35 Q105,28 112,40 Q108,50 100,48 Q96,42 95,35 Z" fill="url(#ws1)" opacity="0.5"/><path d="M100,60 Q110,55 115,68 Q112,78 105,75 Q100,70 100,60 Z" fill="url(#ws2)" opacity="0.4"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#57534e" stroke-width="3"/></svg>`,

  hyphen_hyena: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-hh"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="hh-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#44403c"/><stop offset="100%" stop-color="#1c1917"/></linearGradient><linearGradient id="hh1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#d6d3d1"/><stop offset="100%" stop-color="#a8a29e"/></linearGradient><linearGradient id="hh2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#a8a29e"/><stop offset="100%" stop-color="#78716c"/></linearGradient></defs><rect width="120" height="120" fill="url(#hh-bg)"/><g clip-path="url(#c-hh)"><rect width="120" height="120" fill="url(#hh-bg)"/><path d="M15,85 Q10,70 15,55 Q22,38 40,30 Q55,25 68,35 Q58,48 55,62 Q52,78 60,92 L45,98 Q38,85 38,70 Q38,55 30,48 Q22,55 20,70 Q20,85 28,98 L15,98 Q10,92 15,85 Z" fill="url(#hh1)"/><path d="M40,30 Q60,22 78,35 Q68,52 64,70 Q60,88 68,105 L52,110 Q48,95 48,78 Q48,60 40,30 Z" fill="url(#hh2)"/><path d="M64,55 Q74,48 88,58 Q95,72 88,85 Q78,90 68,82 Q62,72 64,55 Z" fill="url(#hh1)"/><path d="M68,82 Q78,95 72,108 Q62,115 54,110 Q62,100 66,90 Q68,86 68,82 Z" fill="url(#hh2)"/><path d="M28,42 Q40,32 52,38 Q48,50 42,62 Q35,72 30,68 Q25,60 28,42 Z" fill="url(#hh2)" opacity="0.6"/><path d="M50,18 Q62,10 75,18 Q68,28 60,25 Q55,22 50,18 Z" fill="url(#hh1)" opacity="0.7"/><path d="M70,20 Q80,12 92,22 Q85,32 78,28 Q72,24 70,20 Z" fill="url(#hh2)" opacity="0.5"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#a8a29e" stroke-width="3"/></svg>`,

  pun_goblin: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-pg"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="pg-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#365314"/><stop offset="100%" stop-color="#1a2e05"/></linearGradient><linearGradient id="pg1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#84cc16"/><stop offset="100%" stop-color="#65a30d"/></linearGradient><linearGradient id="pg2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#a3e635"/><stop offset="100%" stop-color="#4d7c0f"/></linearGradient></defs><rect width="120" height="120" fill="url(#pg-bg)"/><g clip-path="url(#c-pg)"><rect width="120" height="120" fill="url(#pg-bg)"/><path d="M22,82 Q18,68 22,52 Q30,35 48,28 Q62,24 75,35 Q65,48 62,65 Q58,80 65,95 L50,100 Q42,88 42,72 Q42,58 35,50 Q28,55 25,70 Q25,85 32,98 L20,98 Q16,90 22,82 Z" fill="url(#pg1)"/><path d="M48,28 Q68,20 85,35 Q75,52 70,70 Q66,88 74,105 L58,110 Q52,95 54,78 Q56,60 48,28 Z" fill="url(#pg2)"/><path d="M68,58 Q78,50 92,60 Q98,72 92,84 Q82,90 72,84 Q66,74 68,58 Z" fill="url(#pg1)"/><path d="M72,84 Q82,96 76,110 Q66,118 58,112 Q66,102 70,92 Q72,88 72,84 Z" fill="url(#pg2)"/><path d="M32,45 Q44,35 56,42 Q52,55 46,68 Q40,78 34,74 Q28,65 32,45 Z" fill="url(#pg2)" opacity="0.6"/><path d="M55,22 Q68,15 80,25 Q72,35 65,30 Q60,26 55,22 Z" fill="url(#pg1)" opacity="0.7"/><path d="M45,15 Q55,8 68,15 Q60,24 52,20 Q48,18 45,15 Z" fill="url(#pg2)" opacity="0.5"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#84cc16" stroke-width="3"/></svg>`,

  apostro_fiend: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-af"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="af-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#450a0a"/><stop offset="100%" stop-color="#1c0505"/></linearGradient><linearGradient id="af1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#dc2626"/><stop offset="100%" stop-color="#991b1b"/></linearGradient><linearGradient id="af2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#b91c1c"/><stop offset="100%" stop-color="#7f1d1d"/></linearGradient></defs><rect width="120" height="120" fill="url(#af-bg)"/><g clip-path="url(#c-af)"><rect width="120" height="120" fill="url(#af-bg)"/><path d="M20,80 Q15,65 20,48 Q28,30 48,22 Q65,18 78,30 Q68,45 64,62 Q60,80 68,95 L52,102 Q44,88 44,72 Q44,56 36,48 Q28,54 25,70 Q25,85 32,100 L18,100 Q14,92 20,80 Z" fill="url(#af1)"/><path d="M48,22 Q70,14 88,30 Q78,50 72,70 Q68,88 76,108 L60,112 Q54,96 56,78 Q58,58 48,22 Z" fill="url(#af2)"/><path d="M70,55 Q80,46 95,58 Q102,72 95,86 Q84,92 74,85 Q68,74 70,55 Z" fill="url(#af1)"/><path d="M74,85 Q85,98 78,112 Q68,120 60,115 Q68,104 72,94 Q74,90 74,85 Z" fill="url(#af2)"/><path d="M32,42 Q45,32 58,40 Q54,54 48,68 Q42,80 35,76 Q28,66 32,42 Z" fill="url(#af2)" opacity="0.6"/><path d="M55,12 Q65,5 80,12 Q72,22 65,18 Q60,15 55,12 Z" fill="url(#af1)" opacity="0.8"/><path d="M70,8 Q82,2 95,12 Q88,22 80,18 Q74,12 70,8 Z" fill="url(#af2)" opacity="0.6"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#dc2626" stroke-width="3"/></svg>`,

  idiomatic_undead: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-iu"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="iu-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#1e1b18"/><stop offset="100%" stop-color="#0d0c0a"/></linearGradient><linearGradient id="iu1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#d4c8be"/><stop offset="100%" stop-color="#a39585"/></linearGradient><linearGradient id="iu2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#c4b5a5"/><stop offset="100%" stop-color="#8b7b68"/></linearGradient></defs><rect width="120" height="120" fill="url(#iu-bg)"/><g clip-path="url(#c-iu)"><rect width="120" height="120" fill="url(#iu-bg)"/><path d="M18,82 Q12,65 18,48 Q28,28 50,20 Q68,16 82,30 Q72,48 68,68 Q64,88 72,105 L55,112 Q46,96 46,78 Q46,60 38,50 Q28,56 24,74 Q24,92 32,108 L16,108 Q10,98 18,82 Z" fill="url(#iu1)"/><path d="M50,20 Q72,12 92,30 Q80,52 76,75 Q72,98 80,115 L62,120 Q56,102 58,82 Q60,62 50,20 Z" fill="url(#iu2)"/><path d="M72,58 Q84,48 100,62 Q108,78 100,94 Q88,100 76,92 Q68,80 72,58 Z" fill="url(#iu1)"/><path d="M76,92 Q88,106 80,120 L62,120 Q70,108 74,98 Q76,95 76,92 Z" fill="url(#iu2)"/><path d="M34,42 Q48,30 62,40 Q58,56 52,72 Q44,86 38,82 Q30,72 34,42 Z" fill="url(#iu2)" opacity="0.5"/><path d="M58,12 Q72,4 88,14 Q80,26 72,22 Q65,18 58,12 Z" fill="url(#iu1)" opacity="0.7"/><path d="M22,60 Q18,50 25,55 Q28,62 22,60 Z" fill="url(#iu2)" opacity="0.4"/><path d="M20,75 Q16,68 22,72 Q26,80 20,78 L20,75 Z" fill="url(#iu1)" opacity="0.3"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#a39585" stroke-width="3"/></svg>`,

  vulgar_vandal: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-vv"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="vv-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#3f3f46"/><stop offset="100%" stop-color="#18181b"/></linearGradient><linearGradient id="vv1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#fbbf24"/><stop offset="100%" stop-color="#f59e0b"/></linearGradient><linearGradient id="vv2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#f59e0b"/><stop offset="100%" stop-color="#d97706"/></linearGradient></defs><rect width="120" height="120" fill="url(#vv-bg)"/><g clip-path="url(#c-vv)"><rect width="120" height="120" fill="url(#vv-bg)"/><path d="M20,85 Q14,68 20,50 Q30,30 52,22 Q70,18 85,32 Q74,50 70,70 Q66,90 74,108 L56,114 Q48,98 48,80 Q48,62 40,52 Q30,58 26,76 Q26,94 34,110 L18,110 Q12,100 20,85 Z" fill="url(#vv1)"/><path d="M52,22 Q75,14 95,32 Q84,54 78,78 Q74,100 82,118 L64,120 Q58,104 60,84 Q62,64 52,22 Z" fill="url(#vv2)"/><path d="M74,60 Q86,50 102,64 Q110,80 102,96 Q90,102 78,94 Q70,82 74,60 Z" fill="url(#vv1)"/><path d="M78,94 Q90,108 82,120 L66,120 Q74,110 78,100 Q80,97 78,94 Z" fill="url(#vv2)"/><path d="M36,44 Q50,32 65,42 Q60,58 54,74 Q46,88 40,84 Q32,74 36,44 Z" fill="url(#vv2)" opacity="0.6"/><path d="M60,14 Q74,6 90,16 Q82,28 74,24 Q68,20 60,14 Z" fill="url(#vv1)" opacity="0.7"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#fbbf24" stroke-width="3"/></svg>`,

  double_negative: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-dn"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="dn-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#312e81"/><stop offset="100%" stop-color="#1e1b4b"/></linearGradient><linearGradient id="dn1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#818cf8"/><stop offset="100%" stop-color="#6366f1"/></linearGradient><linearGradient id="dn2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#6366f1"/><stop offset="100%" stop-color="#4f46e5"/></linearGradient></defs><rect width="120" height="120" fill="url(#dn-bg)"/><g clip-path="url(#c-dn)"><rect width="120" height="120" fill="url(#dn-bg)"/><path d="M18,80 Q12,62 18,44 Q28,24 50,18 Q68,14 82,28 Q72,46 68,66 Q64,86 72,104 L54,110 Q46,94 46,76 Q46,58 38,48 Q28,54 24,72 Q24,90 32,106 L16,106 Q10,96 18,80 Z" fill="url(#dn1)"/><path d="M50,18 Q72,10 92,28 Q80,50 76,72 Q72,94 80,114 L62,118 Q56,100 58,80 Q60,60 50,18 Z" fill="url(#dn2)"/><path d="M72,56 Q84,46 100,60 Q108,76 100,92 Q88,98 76,90 Q68,78 72,56 Z" fill="url(#dn1)"/><path d="M76,90 Q88,104 80,118 L64,118 Q72,106 76,96 Q78,93 76,90 Z" fill="url(#dn2)"/><path d="M34,40 Q48,28 62,38 Q58,54 52,70 Q44,84 38,80 Q30,70 34,40 Z" fill="url(#dn2)" opacity="0.5"/><path d="M58,10 Q72,2 88,12 Q80,24 72,20 Q66,16 58,10 Z" fill="url(#dn1)" opacity="0.7"/><path d="M10,55 Q18,48 15,60 Q12,68 10,62 L10,55 Z" fill="url(#dn2)" opacity="0.4"/><path d="M8,72 Q16,65 14,78 Q10,85 8,80 L8,72 Z" fill="url(#dn1)" opacity="0.35"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#818cf8" stroke-width="3"/></svg>`,

  run_on_sentence: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-ros"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="ros-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#0c4a6e"/><stop offset="100%" stop-color="#082f49"/></linearGradient><linearGradient id="ros1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#38bdf8"/><stop offset="100%" stop-color="#0ea5e9"/></linearGradient><linearGradient id="ros2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#0ea5e9"/><stop offset="100%" stop-color="#0284c7"/></linearGradient></defs><rect width="120" height="120" fill="url(#ros-bg)"/><g clip-path="url(#c-ros)"><rect width="120" height="120" fill="url(#ros-bg)"/><path d="M5,78 Q0,60 8,42 Q18,22 42,16 Q62,12 78,28 Q68,46 64,68 Q60,90 68,110 L50,116 Q42,98 42,78 Q42,58 34,48 Q24,54 20,74 Q20,94 28,112 L10,112 Q2,100 5,78 Z" fill="url(#ros1)"/><path d="M42,16 Q66,8 88,28 Q76,52 72,78 Q68,102 76,120 L58,120 Q52,104 54,82 Q56,60 42,16 Z" fill="url(#ros2)"/><path d="M70,58 Q82,48 98,62 Q106,78 98,94 Q86,100 74,92 Q66,80 70,58 Z" fill="url(#ros1)"/><path d="M74,92 Q86,106 78,120 L62,120 Q70,108 74,98 Q76,95 74,92 Z" fill="url(#ros2)"/><path d="M30,38 Q44,26 60,38 Q56,54 50,72 Q42,86 36,82 Q28,72 30,38 Z" fill="url(#ros2)" opacity="0.5"/><path d="M55,8 Q70,0 88,12 Q78,24 70,20 Q62,16 55,8 Z" fill="url(#ros1)" opacity="0.7"/><path d="M98,62 Q108,55 115,68 Q112,78 105,74 Q100,70 98,62 Z" fill="url(#ros2)" opacity="0.5"/><path d="M100,78 Q110,72 116,86 Q114,95 108,92 Q102,88 100,78 Z" fill="url(#ros1)" opacity="0.4"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#38bdf8" stroke-width="3"/></svg>`,

  split_infinitive: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-si"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="si-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#581c87"/><stop offset="100%" stop-color="#3b0764"/></linearGradient><linearGradient id="si1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#c084fc"/><stop offset="100%" stop-color="#a855f7"/></linearGradient><linearGradient id="si2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#a855f7"/><stop offset="100%" stop-color="#9333ea"/></linearGradient></defs><rect width="120" height="120" fill="url(#si-bg)"/><g clip-path="url(#c-si)"><rect width="120" height="120" fill="url(#si-bg)"/><path d="M15,82 Q8,64 15,45 Q26,24 50,18 Q70,14 85,30 Q74,50 70,72 Q66,94 74,114 L56,120 Q48,102 48,82 Q48,62 40,52 Q30,58 26,78 Q26,98 34,116 L14,116 Q6,104 15,82 Z" fill="url(#si1)"/><path d="M50,18 Q74,10 95,30 Q84,54 78,80 Q74,104 82,120 L64,120 Q58,106 60,84 Q62,62 50,18 Z" fill="url(#si2)"/><path d="M72,62 Q85,52 102,66 Q110,82 102,98 Q90,104 78,96 Q70,84 72,62 Z" fill="url(#si1)"/><path d="M78,96 Q90,110 82,120 L66,120 Q74,112 78,102 Q80,99 78,96 Z" fill="url(#si2)"/><path d="M32,44 Q48,32 64,44 Q58,62 52,80 Q44,96 38,92 Q30,82 32,44 Z" fill="url(#si2)" opacity="0.5"/><path d="M58,10 Q74,2 92,14 Q82,28 74,24 Q66,18 58,10 Z" fill="url(#si1)" opacity="0.7"/><path d="M48,60 L52,60 L52,64 L48,64 Z" fill="url(#si-bg)" opacity="0.8"/><path d="M62,70 L66,70 L66,74 L62,74 Z" fill="url(#si-bg)" opacity="0.6"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#c084fc" stroke-width="3"/></svg>`,

  mixed_metaphor: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-mm"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="mm-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#7c2d12"/><stop offset="100%" stop-color="#431407"/></linearGradient><linearGradient id="mm1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#fb923c"/><stop offset="100%" stop-color="#f97316"/></linearGradient><linearGradient id="mm2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#f97316"/><stop offset="100%" stop-color="#ea580c"/></linearGradient></defs><rect width="120" height="120" fill="url(#mm-bg)"/><g clip-path="url(#c-mm)"><rect width="120" height="120" fill="url(#mm-bg)"/><path d="M18,84 Q10,66 18,46 Q30,24 55,18 Q75,14 90,32 Q78,52 74,76 Q70,98 78,118 L60,120 Q52,104 52,84 Q52,64 44,54 Q34,60 30,80 Q30,100 38,118 L18,118 Q8,106 18,84 Z" fill="url(#mm1)"/><path d="M55,18 Q80,10 100,32 Q88,58 84,84 Q80,108 88,120 L68,120 Q62,108 64,86 Q66,64 55,18 Z" fill="url(#mm2)"/><path d="M76,64 Q90,54 106,70 Q114,88 106,104 Q94,110 82,102 Q74,90 76,64 Z" fill="url(#mm1)"/><path d="M82,102 Q94,116 86,120 L70,120 Q78,114 82,106 Q84,103 82,102 Z" fill="url(#mm2)"/><path d="M36,46 Q52,34 68,46 Q62,66 56,86 Q48,102 42,98 Q34,88 36,46 Z" fill="url(#mm2)" opacity="0.5"/><path d="M62,10 Q78,2 96,16 Q86,30 78,26 Q70,20 62,10 Z" fill="url(#mm1)" opacity="0.7"/><path d="M20,58 Q28,50 35,60 Q30,70 24,65 Q20,62 20,58 Z" fill="url(#mm2)" opacity="0.4"/><path d="M15,75 Q22,68 28,78 Q24,88 18,84 Q15,80 15,75 Z" fill="url(#mm1)" opacity="0.35"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#fb923c" stroke-width="3"/></svg>`,

  passive_voice: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-pv"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="pv-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#374151"/><stop offset="100%" stop-color="#1f2937"/></linearGradient><linearGradient id="pv1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#9ca3af"/><stop offset="100%" stop-color="#6b7280"/></linearGradient><linearGradient id="pv2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#6b7280"/><stop offset="100%" stop-color="#4b5563"/></linearGradient></defs><rect width="120" height="120" fill="url(#pv-bg)"/><g clip-path="url(#c-pv)"><rect width="120" height="120" fill="url(#pv-bg)"/><path d="M16,82 Q8,64 16,44 Q28,22 54,16 Q74,12 90,30 Q78,50 74,74 Q70,98 78,118 L58,120 Q50,104 50,82 Q50,62 42,52 Q32,58 28,78 Q28,98 36,116 L16,116 Q6,104 16,82 Z" fill="url(#pv1)" opacity="0.7"/><path d="M54,16 Q78,8 98,30 Q86,56 82,82 Q78,106 86,120 L66,120 Q60,106 62,84 Q64,62 54,16 Z" fill="url(#pv2)" opacity="0.6"/><path d="M74,62 Q88,52 104,68 Q112,86 104,102 Q92,108 80,100 Q72,88 74,62 Z" fill="url(#pv1)" opacity="0.75"/><path d="M80,100 Q92,114 84,120 L68,120 Q76,112 80,104 Q82,101 80,100 Z" fill="url(#pv2)" opacity="0.65"/><path d="M34,44 Q50,32 66,44 Q60,64 54,84 Q46,100 40,96 Q32,86 34,44 Z" fill="url(#pv2)" opacity="0.4"/><path d="M60,8 Q76,0 94,14 Q84,28 76,24 Q68,18 60,8 Z" fill="url(#pv1)" opacity="0.55"/><path d="M18,56 Q26,48 32,58 Q28,68 22,64 Q18,60 18,56 Z" fill="url(#pv2)" opacity="0.35"/><path d="M14,74 Q22,66 28,78 Q24,88 18,84 Q14,80 14,74 Z" fill="url(#pv1)" opacity="0.3"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#9ca3af" stroke-width="3"/></svg>`,

  silent_knight: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-sk"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="sk-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#1f2937"/><stop offset="100%" stop-color="#111827"/></linearGradient><linearGradient id="sk1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#d1d5db"/><stop offset="100%" stop-color="#9ca3af"/></linearGradient><linearGradient id="sk2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#9ca3af"/><stop offset="100%" stop-color="#6b7280"/></linearGradient></defs><rect width="120" height="120" fill="url(#sk-bg)"/><g clip-path="url(#c-sk)"><rect width="120" height="120" fill="url(#sk-bg)"/><path d="M15,90 Q8,72 15,52 Q26,28 55,20 Q78,16 95,38 Q84,58 80,82 Q76,106 84,120 L62,120 Q54,106 54,86 Q54,66 46,56 Q36,62 32,82 Q32,102 40,120 L18,120 Q8,108 15,90 Z" fill="url(#sk1)"/><path d="M55,20 Q82,12 102,38 Q92,66 88,94 Q84,118 92,120 L70,120 Q64,110 66,88 Q68,64 55,20 Z" fill="url(#sk2)"/><path d="M80,55 Q92,44 108,58 Q116,76 110,94 Q100,102 88,96 Q80,84 80,55 Z" fill="url(#sk1)"/><path d="M88,96 Q100,110 92,120 L74,120 Q82,112 88,102 Q90,99 88,96 Z" fill="url(#sk2)"/><path d="M38,48 Q54,36 70,48 Q64,70 58,92 Q50,108 44,104 Q36,94 38,48 Z" fill="url(#sk2)" opacity="0.5"/><path d="M62,12 Q80,4 98,20 Q88,36 80,32 Q72,26 62,12 Z" fill="url(#sk1)" opacity="0.8"/><path d="M50,8 Q62,2 78,10 Q70,20 62,16 Q56,12 50,8 Z" fill="url(#sk2)" opacity="0.6"/><path d="M90,60 Q95,55 102,60 L100,65 Q95,62 90,65 L90,60 Z" fill="url(#sk-bg)" opacity="0.8"/><path d="M22,65 Q30,58 38,68 Q34,78 28,74 Q22,70 22,65 Z" fill="url(#sk1)" opacity="0.4"/><path d="M18,85 Q26,78 34,88 Q30,98 24,94 Q18,90 18,85 Z" fill="url(#sk2)" opacity="0.35"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#d1d5db" stroke-width="3"/></svg>`,

  // Bosses - Abstract side profile silhouettes
  cinna_antony: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-ca"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="ca-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#1e1b4b"/><stop offset="100%" stop-color="#0f0a1e"/></linearGradient><linearGradient id="ca1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#f472b6"/><stop offset="100%" stop-color="#db2777"/></linearGradient><linearGradient id="ca2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#60a5fa"/><stop offset="100%" stop-color="#2563eb"/></linearGradient></defs><rect width="120" height="120" fill="url(#ca-bg)"/><g clip-path="url(#c-ca)"><rect width="120" height="120" fill="url(#ca-bg)"/><path d="M8,85 Q4,70 10,55 Q18,38 35,32 Q48,28 58,38 Q52,50 50,65 Q48,80 54,95 L42,100 Q36,88 36,74 Q36,60 30,52 Q22,58 20,72 Q20,88 26,102 L10,102 Q4,94 8,85 Z" fill="url(#ca1)"/><path d="M35,32 Q52,24 68,38 Q60,54 58,72 Q56,90 62,108 L48,112 Q44,96 46,78 Q48,60 35,32 Z" fill="url(#ca1)" opacity="0.7"/><path d="M58,60 Q68,52 82,62 Q88,76 82,88 Q74,94 64,88 Q58,78 58,60 Z" fill="url(#ca1)"/><path d="M62,88 Q72,100 66,112 L52,112 Q58,102 62,94 Q64,91 62,88 Z" fill="url(#ca1)" opacity="0.8"/><path d="M65,85 Q60,70 65,55 Q72,40 88,35 Q100,32 110,42 Q102,54 100,68 Q98,82 104,96 L92,100 Q88,88 88,74 Q88,60 82,52 Q74,58 72,72 Q72,88 78,102 L65,102 Q60,94 65,85 Z" fill="url(#ca2)"/><path d="M88,35 Q104,28 115,42 Q108,58 105,75 Q102,92 108,110 L95,114 Q92,98 94,80 Q96,62 88,35 Z" fill="url(#ca2)" opacity="0.7"/><path d="M100,60 Q108,54 118,62 Q120,76 115,86 Q108,90 102,86 Q98,78 100,60 Z" fill="url(#ca2)"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#a855f7" stroke-width="3"/></svg>`,

  red_aktins: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-ra"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="ra-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#1c1917"/><stop offset="100%" stop-color="#0c0a09"/></linearGradient><linearGradient id="ra1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#ef4444"/><stop offset="100%" stop-color="#b91c1c"/></linearGradient><linearGradient id="ra2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#dc2626"/><stop offset="100%" stop-color="#991b1b"/></linearGradient></defs><rect width="120" height="120" fill="url(#ra-bg)"/><g clip-path="url(#c-ra)"><rect width="120" height="120" fill="url(#ra-bg)"/><path d="M18,82 Q10,64 18,44 Q30,22 55,16 Q75,12 92,30 Q80,52 76,76 Q72,100 80,120 L60,120 Q52,104 52,82 Q52,62 44,52 Q34,58 30,78 Q30,98 38,118 L18,118 Q8,106 18,82 Z" fill="url(#ra1)"/><path d="M55,16 Q80,8 100,30 Q88,58 84,86 Q80,112 88,120 L68,120 Q62,108 64,84 Q66,60 55,16 Z" fill="url(#ra2)"/><path d="M76,62 Q90,52 106,68 Q114,86 106,102 Q94,108 82,100 Q74,88 76,62 Z" fill="url(#ra1)"/><path d="M82,100 Q94,114 86,120 L70,120 Q78,112 82,104 Q84,101 82,100 Z" fill="url(#ra2)"/><path d="M36,44 Q52,32 68,44 Q62,66 56,88 Q48,104 42,100 Q34,90 36,44 Z" fill="url(#ra2)" opacity="0.5"/><path d="M62,8 Q78,0 96,14 Q86,30 78,26 Q70,20 62,8 Z" fill="url(#ra1)" opacity="0.8"/><rect x="30" y="55" width="40" height="12" fill="url(#ra-bg)" opacity="0.9"/><rect x="32" y="57" width="36" height="8" fill="url(#ra1)" opacity="0.6"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#ef4444" stroke-width="3"/></svg>`,

  plague_doctor: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-pd"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="pd-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#1a1a1a"/><stop offset="100%" stop-color="#0a0a0a"/></linearGradient><linearGradient id="pd1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#525252"/><stop offset="100%" stop-color="#262626"/></linearGradient><linearGradient id="pd2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#404040"/><stop offset="100%" stop-color="#171717"/></linearGradient></defs><rect width="120" height="120" fill="url(#pd-bg)"/><g clip-path="url(#c-pd)"><rect width="120" height="120" fill="url(#pd-bg)"/><path d="M15,85 Q8,68 15,48 Q26,26 52,20 Q72,16 88,34 Q78,54 74,78 Q70,102 78,120 L58,120 Q50,104 50,82 Q50,62 42,52 Q32,58 28,78 Q28,100 36,118 L15,118 Q6,106 15,85 Z" fill="url(#pd1)"/><path d="M52,20 Q78,12 98,34 Q88,62 84,90 Q80,116 88,120 L68,120 Q62,108 64,85 Q66,62 52,20 Z" fill="url(#pd2)"/><path d="M74,50 Q82,42 95,48 Q102,56 100,68 Q96,78 92,85 Q88,92 82,95 Q75,92 72,85 Q68,76 70,65 Q72,55 74,50 Z" fill="url(#pd1)"/><path d="M92,85 Q100,78 110,85 Q115,95 108,105 Q98,110 92,102 Q88,95 92,85 Z" fill="url(#pd2)"/><path d="M82,95 Q90,105 85,115 L70,120 Q78,112 82,104 Q84,100 82,95 Z" fill="url(#pd1)"/><path d="M34,44 Q50,32 66,44 Q60,66 54,88 Q46,104 40,100 Q32,90 34,44 Z" fill="url(#pd2)" opacity="0.5"/><path d="M60,12 Q76,4 94,18 Q84,32 76,28 Q68,22 60,12 Z" fill="url(#pd1)" opacity="0.7"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#525252" stroke-width="3"/></svg>`,

  oxy: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-ox"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="ox-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#18181b"/><stop offset="100%" stop-color="#09090b"/></linearGradient><linearGradient id="ox1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#fafafa"/><stop offset="100%" stop-color="#a1a1aa"/></linearGradient><linearGradient id="ox2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#27272a"/><stop offset="100%" stop-color="#09090b"/></linearGradient></defs><rect width="120" height="120" fill="url(#ox-bg)"/><g clip-path="url(#c-ox)"><rect width="120" height="120" fill="url(#ox-bg)"/><path d="M16,82 Q8,64 16,44 Q28,22 54,16 Q74,12 90,30 Q80,52 76,76 Q72,100 80,120 L60,120 Q52,104 52,82 Q52,62 44,52 Q34,58 30,78 Q30,98 38,118 L16,118 Q6,106 16,82 Z" fill="url(#ox1)"/><path d="M54,16 Q78,8 98,30 Q88,58 84,86 Q80,112 88,120 L68,120 Q62,108 64,84 Q66,60 54,16 Z" fill="url(#ox2)"/><path d="M76,60 Q90,50 106,66 Q114,84 106,100 Q94,106 82,98 Q74,86 76,60 Z" fill="url(#ox1)"/><path d="M82,98 Q94,112 86,120 L70,120 Q78,112 82,102 Q84,99 82,98 Z" fill="url(#ox2)"/><path d="M36,44 Q52,32 68,44 Q62,66 56,88 Q48,104 42,100 Q34,90 36,44 Z" fill="url(#ox2)" opacity="0.6"/><path d="M62,8 Q78,0 96,14 Q86,30 78,26 Q70,20 62,8 Z" fill="url(#ox1)" opacity="0.8"/><path d="M20,60 Q28,52 35,62 Q30,72 24,68 Q20,64 20,60 Z" fill="url(#ox1)" opacity="0.5"/><path d="M16,78 Q24,70 32,80 Q28,90 22,86 Q16,82 16,78 Z" fill="url(#ox2)" opacity="0.4"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#71717a" stroke-width="3"/></svg>`,

  dotdotdot: `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><clipPath id="c-dd"><circle cx="60" cy="60" r="56"/></clipPath><linearGradient id="dd-bg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#1e3a5f"/><stop offset="100%" stop-color="#0c1929"/></linearGradient><linearGradient id="dd1" x1="0%" y1="0%" x2="100%" y2="80%"><stop offset="0%" stop-color="#7dd3fc"/><stop offset="100%" stop-color="#38bdf8"/></linearGradient><linearGradient id="dd2" x1="20%" y1="0%" x2="80%" y2="100%"><stop offset="0%" stop-color="#38bdf8"/><stop offset="100%" stop-color="#0284c7"/></linearGradient></defs><rect width="120" height="120" fill="url(#dd-bg)"/><g clip-path="url(#c-dd)"><rect width="120" height="120" fill="url(#dd-bg)"/><path d="M16,82 Q8,64 16,44 Q28,22 54,16 Q74,12 90,30 Q80,52 76,76 Q72,100 80,120 L60,120 Q52,104 52,82 Q52,62 44,52 Q34,58 30,78 Q30,98 38,118 L16,118 Q6,106 16,82 Z" fill="url(#dd1)" opacity="0.7"/><path d="M54,16 Q78,8 98,30 Q88,58 84,86 Q80,112 88,120 L68,120 Q62,108 64,84 Q66,60 54,16 Z" fill="url(#dd2)" opacity="0.6"/><path d="M76,60 Q90,50 106,66 Q114,84 106,100 Q94,106 82,98 Q74,86 76,60 Z" fill="url(#dd1)" opacity="0.8"/><path d="M82,98 Q94,112 86,120 L70,120 Q78,112 82,102 Q84,99 82,98 Z" fill="url(#dd2)" opacity="0.7"/><path d="M36,44 Q52,32 68,44 Q62,66 56,88 Q48,104 42,100 Q34,90 36,44 Z" fill="url(#dd2)" opacity="0.45"/><path d="M62,8 Q78,0 96,14 Q86,30 78,26 Q70,20 62,8 Z" fill="url(#dd1)" opacity="0.6"/><circle cx="88" cy="95" r="4" fill="url(#dd1)" opacity="0.9"/><circle cx="98" cy="100" r="4" fill="url(#dd1)" opacity="0.7"/><circle cx="108" cy="105" r="4" fill="url(#dd1)" opacity="0.5"/></g><circle cx="60" cy="60" r="56" fill="none" stroke="#7dd3fc" stroke-width="3"/></svg>`
};

// Get portrait SVG for a character by ID, optionally adding a suffix to IDs to prevent conflicts
function getPortraitSVG(id, suffix = '') {
  let svg = PORTRAITS[id] || PORTRAITS.ghost; // Fallback to ghost

  if (suffix) {
    // Inject suffix into IDs (e.g., id="c-w" -> id="c-w-shop")
    svg = svg.replace(/id="([^"]+)"/g, `id="$1-${suffix}"`);
    // Inject suffix into references (e.g., url(#c-w) -> url(#c-w-shop))
    svg = svg.replace(/url\(#([^)]+)\)/g, `url(#$1-${suffix})`);
  }

  return svg;
}

// Render portrait into a container element
function renderPortrait(container, characterId, borderColor) {
  if (!container) return;
  const svg = getPortraitSVG(characterId);
  container.innerHTML = svg;
  if (borderColor) {
    const circle = container.querySelector('circle:last-child');
    if (circle) circle.setAttribute('stroke', borderColor);
  }
}

// Opposite element pairs for boss mechanics
const OPPOSITE_ELEMENTS = {
  [E.FIRE]: E.WATER, [E.WATER]: E.FIRE,
  [E.EARTH]: E.LIGHTNING, [E.LIGHTNING]: E.EARTH,
  [E.LIGHT]: E.DARK, [E.DARK]: E.LIGHT,
  [E.PHYS]: E.POISON, [E.POISON]: E.PHYS
};

// === HERO VS ENEMY DIALOGUE ===
// Each hero has unique lines for each enemy type (2 variations per regular enemy, 1 extended for bosses)
const HERO_ENEMY_DIALOGUE = {
  // GRAHAM MOOR - The Weathered Sentinel
  warrior: {
    // Regular Enemies (2 variations each)
    vowel_goblin: ["This generation can't even spell. Hand over those vowels.", "Hoarding letters now? You're everything wrong with this world."],
    ghost: ["Dord? That's not even a real word. Move on already.", "You're haunting us with nonsense. Typical."],
    synonym_roll: ["You're bread. I'm a blade. Do the math.", "All those words for the same thing, and none of them are 'survivor.'"],
    comma_chameleon: ["Stop... pausing... and... fight.", "I've no patience for your punctuation games."],
    webster_spiderling: ["I don't care what the dictionary says. You're dying either way.", "Spin all the semantics you want. My blade doesn't negotiate definitions."],
    hyphen_hyena: ["Two-faced? I'll give you two halves.", "Your hyphenated laughs end here."],
    pun_goblin: ["I've heard better wordplay from corpses.", "Puns won't save you from steel."],
    apostro_fiend: ["Your grammar is as bad as your life choices.", "Possessive little demon, aren't you?"],
    idiomatic_undead: ["Great. A corpse that speaks in clich√©s. Just my luck.", "I've buried better conversationalists than you."],
    vulgar_vandal: ["I've heard enough. Shut up and fight.", "Back in my day, we had the decency to swear properly."],
    double_negative: ["You can't not die. Wait‚Äîyou know what I mean.", "Two wrongs don't make you right."],
    run_on_sentence: ["Get to the point or I'll make one for you.", "Enough. Just... enough."],
    split_infinitive: ["I'm going to completely end you.", "Your grammar crimes end here."],
    mixed_metaphor: ["That doesn't even make sense. Neither will your corpse.", "You've burned your last bridge. Or crossed it. Whatever."],
    passive_voice: ["Mistakes were made. By you. Fatally.", "Let me put this in active voice: I kill you."],
    // Bosses (1 extended line each)
    silent_knight: "Finally. An enemy who doesn't talk. Your silence is the only respectable thing about you‚Äîbut even respect won't save you from my blade.",
    cinna_antony: "I've seen a hundred soldiers tear each other apart over nothing. You two are just louder about it. Pick a side or get out of my way.",
    red_aktins: "You think hiding behind black bars makes you powerful? I've fought real tyrants. You're just a coward with a marker.",
    plague_doctor: "Copying my stance? My technique? Years of blood and training, and you think you can just take it? Earn something for once.",
    oxy: "Jumbo shrimp. Military intelligence. You. None of it makes sense, and I'm too old to pretend otherwise. Let's just fight.",
    dotdotdot: "Spit it out or shut up. I don't have time for someone who can't even commit to a sentence..."
  },

  // QUIVERA - The Legend Between the Trees
  ranger: {
    vowel_goblin: ["You used all five at once... wasteful.", "A, E, I, O, U‚Äîand none put to purpose."],
    ghost: ["You linger without purpose. That's the true haunting.", "Even spirits must know when to let go."],
    synonym_roll: ["Many words for the same meaning. Inefficient.", "You could say it once. You chose excess."],
    comma_chameleon: ["Pausing won't save you. Arrows don't wait.", "Your hesitation is your undoing."],
    webster_spiderling: ["Eight legs and still you've caught nothing useful in that web.", "Your trap is intricate. Your purpose is not."],
    hyphen_hyena: ["Compound words won't compound your strength.", "Laugh while you can. It echoes shorter than you think."],
    pun_goblin: ["Wordplay is no substitute for wisdom.", "You waste breath that could be your last."],
    apostro_fiend: ["What you steal, you cannot keep.", "Possession is temporary. Especially yours."],
    idiomatic_undead: ["Dead men should rest. You're wasting everyone's time.", "You've overstayed your welcome by several lifetimes."],
    vulgar_vandal: ["All that noise, and nothing said.", "You mistake volume for vocabulary."],
    double_negative: ["Two denials don't create truth.", "Contradiction consumes itself."],
    run_on_sentence: ["Learn when to stop. This is that moment.", "Endless words catch no prey."],
    split_infinitive: ["Divided purpose, divided strength.", "You cannot split what I make whole."],
    mixed_metaphor: ["Your confusion spreads to your strategy.", "Mixed messages end in clear defeat."],
    passive_voice: ["Things happen to you. You don't make them happen.", "Your passivity is your grave."],
    silent_knight: "Silence. At least you understand that much. A quiet foe is rare‚Äîand still prey. Your armor cannot hide from my arrows.",
    cinna_antony: "You fight each other instead of the real enemy. That's why you'll both fall‚Äîdivided resources, divided purpose, divided fate.",
    red_aktins: "You redact what you fear. But truth doesn't disappear‚Äîit waits. And I've gotten very good at waiting.",
    plague_doctor: "Imitation is theft dressed as flattery. You've taken the surface and missed the substance entirely.",
    oxy: "You call yourself a paradox, but you're just confused. Nature doesn't tolerate contradiction‚Äîit resolves it.",
    dotdotdot: "You trail off because you fear endings. But everything ends. Everything. Even..."
  },

  // BELLE LETTRES - The Unreadable Tome (Disney princess demeanor hiding steel underneath)
  mage: {
    vowel_goblin: ["Oh my, what darling little letters you've collected! Though I wonder... do they make you feel less empty inside?", "Such pretty vowels! It's almost a shame what I'm about to do. Almost."],
    ghost: ["A phantom! How romantic, how tragic, how‚Äî wait, you're actually trying to hurt me? That's... that's quite rude, actually.", "Poor lost spirit. I'd offer sympathy, but you're in my way, and I don't have time for this."],
    synonym_roll: ["So many words for the same thing! I do that too, you know‚Äîwhen I'm avoiding something.", "Darling, repetition won't hide what you really mean. Trust me, I've tried."],
    comma_chameleon: ["What a lovely creature! Though I notice you pause a lot. Avoiding something, perhaps? ...Not that I'd know anything about that.", "Your hesitation is adorable. Mine is calculated. There's a difference."],
    webster_spiderling: ["Oh, how industrious! Weaving definitions to trap meaning. I appreciate the craft, truly. But I'm not getting caught today.", "Such intricate work! It's almost a shame to burn it all down. Almost."],
    hyphen_hyena: ["Your laughter is charming! Though it does seem a bit... forced? No judgment, I understand performance.", "Joined together yet still incomplete. Hm. That's not a metaphor I want to examine too closely."],
    pun_goblin: ["Oh, how clever! Wordplay to deflect! I would never‚Äî okay, fine, maybe I would. But I'm better at it.", "Your jokes are a lovely shield, darling. I wear one too. Shall we see whose cracks first?"],
    apostro_fiend: ["Possessive little thing, aren't you? Taking what isn't yours. I wouldn't know anything about that. Moving on.", "You cling to what you've claimed. I understand. But some things must be let go."],
    idiomatic_undead: ["Still clinging to old phrases? How quaint. Some of us evolve, you know. Some of us have to.", "Dead words walking. There's poetry in that, if you squint. Now hold still."],
    vulgar_vandal: ["Such language! I'm absolutely scandalized. ...Okay, no I'm not. I've said worse when no one's listening.", "All that anger, thrown at the world. I keep mine somewhere else. Somewhere it can't be used against me."],
    double_negative: ["Two negatives making... nothing? That's not how it works, dear. Though I wish it were.", "Your math is wrong and your existence is an error. Let me correct both."],
    run_on_sentence: ["Oh my, you just keep going! It's almost impressive. When do you breathe? When do you stop and actually feel‚Äînever mind.", "All those words and none of them say what you really mean. I know the feeling."],
    split_infinitive: ["Grammatically speaking, you're a disaster. Emotionally speaking... well, glass houses and all that.", "Divided against yourself. Not that I would understand that at all. *nervous laugh*"],
    mixed_metaphor: ["Your metaphors are all tangled up, dear. Your feelings too, I imagine. Not that I‚Äî this isn't about me.", "Such confusion! It's almost relatable. I said almost."],
    passive_voice: ["Things just happen to you, don't they? You never choose. Must be nice, actually. Simpler.", "No agency, no responsibility. There's a freedom in that I sometimes envy."],
    silent_knight: "Oh, the strong silent type! How mysterious, how brooding, how‚Äî you know what, I don't have to fill your silence for you. I do enough of that for myself.",
    cinna_antony: "Fascinating, you two. So busy fighting each other you never have to look at yourselves. That's not a strategy I recognize at all. Nope. Never done that.",
    red_aktins: "Redacting the parts you don't like? How delightfully avoidant. I prefer illusion myself, but we all have our methods. Now get out of my way.",
    plague_doctor: "You copy what you see, but not what's underneath. Smart, actually. The underneath is where it gets messy. Trust me.",
    oxy: "Contradictions everywhere! Living death, sweet sorrow, confident princess who definitely has her life together‚Äî wait, forget that last one. Just. Forget it.",
    dotdotdot: "Trailing off before you have to finish the thought? Before you have to commit? ...I respect the technique, honestly."
  },

  // ALEXANDRIA CONSTANZA - The Stanza in Shining Armor (poetic, justice-driven, hint of insecurity without purpose)
  paladin: {
    vowel_goblin: ["What hollow hoard is this, that grasps yet never gives? / My purpose calls: to free the voice that in your shadow lives.", "You clutch at letters like a drowning soul clutches driftwood. / Let go. I shall be your shore‚Äîas I was always meant to be."],
    ghost: ["O shade who walks 'tween meaning and the void‚Äî / My blade shall write the ending you've too long avoided.", "A whisper caught in amber, neither here nor hence. / My purpose is your peace. Without it, what am I?"],
    synonym_roll: ["A thousand words for one, yet silence speaks the truth. / My duty is to cut through noise‚Äîto carve meaning from uncouth.", "You spin your wheels of sameness, never moving, never still. / Stand aside, or learn what purpose means through steel and will."],
    comma_chameleon: ["Between the pause and breath, you hide from what must come. / But I? I am the sentence's end‚Äîthe final, righteous sum.", "You hesitate where I cannot. The path is clear, the duty plain. / What would I be without this charge? ...No. Forward. Strike again."],
    webster_spiderling: ["You weave your web of meaning, trap truth in silken lies. / But justice cuts through gossamer‚Äîmy oath shall be your demise.", "Definition is your prison, but purpose sets one free. / Without my sacred charge to keep... who would I even be?"],
    hyphen_hyena: ["Joined yet incomplete, your laughter rings so hollow. / I know the shape of purpose‚Äîand your emptiness I will not follow.", "Two halves a whole do not make when the center knows no creed. / My mission is my meaning. Yours? Just hunger. Just need."],
    pun_goblin: ["Behind each jest, a wound that wit cannot conceal. / I'll break your shield of laughter‚Äîlet my righteous hammer heal.", "You deflect with cleverness, but duty knows no jest. / I am defined by sacred oath. You? By running from the rest."],
    apostro_fiend: ["What you possess was never yours to claim. / My oath demands I strip you bare‚Äîrestore the unnamed to their name.", "You cling to stolen syllables like they give you form. / Without my charge, I too might grasp... No. I am the storm."],
    idiomatic_undead: ["Dead phrases walk through you, a vessel for the past. / My purpose burns eternal‚Äîyours shall never last.", "You are what repetition makes: a hollow, echoing shell. / I am what duty forges. Without it? ...I cannot tell."],
    vulgar_vandal: ["Your curses fall like rain upon a righteous shore. / I am the cleansing tide‚Äîand I was made for nothing more.", "Beneath your fury hides a soul that lost its way. / I'll show you what true purpose means‚Äîthen end your wretched day."],
    double_negative: ["Two wrongs entwined still cannot make a right. / My oath is singular and pure‚Äîa lone and guiding light.", "You cancel out yourself, becoming less than nil. / I am defined by sacred charge. You? By lack of will."],
    run_on_sentence: ["Your story sprawls unending, formless, without grace. / I am the final period‚Äîthe pause that ends the race.", "On and on you ramble, never finding rest. / My purpose is conclusion. I shall give you my best."],
    split_infinitive: ["Divided, you stand weakened‚Äîtorn from your own core. / My oath keeps me together. Without it... what's worth fighting for?", "To boldly cleave what should be whole‚Äîyour sin is written clear. / I'll mend what you have broken. That is why I'm here."],
    mixed_metaphor: ["Your thoughts are tangled verses with no rhythm, rhyme, or reason. / My duty is to clarify‚Äîand end your muddled treason.", "Confusion clouds your purpose, if you ever had one true. / I know exactly what I am. ...Most days. Most days, I do."],
    passive_voice: ["Fate acts upon you, never by your hand. / I choose my path each morning. I rise because I stand.", "To be moved by forces unknown, never to decide‚Äî / There's freedom in that absence. ...No. No. I take pride."],
    silent_knight: "Your silence speaks in verses my ears alone can hear‚Äî / A dirge of duty's burden, of purpose bought with tears. / I understand you, brother, more than words could ever say. / For what are we without our charge? What's left when oaths decay?",
    cinna_antony: "Two voices raised in discord, when harmony could reign! / My oath demands I end this strife‚Äîthough victory brings pain. / For siblings should lift each other toward the poet's light. / Without my charge to guide me... I too might lose the fight.",
    red_aktins: "Each word you strike from history is a soul you've left unsung! / My sacred duty speaks for those whose voices you have wrung. / Censorship is violence dressed in editorial black. / I'll write back every syllable. That's an oath I'll never slack.",
    plague_doctor: "You wear a hundred voices, yet speak with none your own. / Beneath the masks of mimicry, I hear a hollow tone. / Find your own verse, plagiarist, or face my righteous rhyme. / Without my purpose... I might wander, lost, through time.",
    oxy: "You think in contradictions, as if paradox were shield. / But unity of purpose is the weapon I shall wield! / Living death, sweet sorrow‚Äîpretty words that mean nothing true. / I am defined by sacred charge. And I shall un-define you.",
    dotdotdot: "Each thought you leave unfinished is a promise cast aside! / The world deserves its closure‚Äîand I shall be its guide. / For what is purpose but completion? What is oath but end? / ...And what am I without this charge? A stanza without end..."
  },

  // CAESURA - The Silence Between Words
  assassin: {
    vowel_goblin: ["...", "Ditto."],
    ghost: ["Ditto.", "..."],
    synonym_roll: ["...", "Redundant."],
    comma_chameleon: ["...", "..."],
    webster_spiderling: ["...", "*cuts web*"],
    hyphen_hyena: ["...", "‚Äî"],
    pun_goblin: ["...", "*sighs*"],
    apostro_fiend: ["...", "'"],
    idiomatic_undead: ["...", "*waits*"],
    vulgar_vandal: ["......", "*faint smirk*"],
    double_negative: ["...", "Yes."],
    run_on_sentence: [".", "..."],
    split_infinitive: ["...", "*blade drawn*"],
    mixed_metaphor: ["...", "*tilts head*"],
    passive_voice: ["...", "Act."],
    silent_knight: "*respectful nod*",
    cinna_antony: "Two halves... neither whole... I understand.",
    red_aktins: "[REDACTED]... becomes remembered.",
    plague_doctor: "You copy... but cannot feel... the weight behind the words.",
    oxy: "Opposite truths... can coexist... in silence.",
    dotdotdot: "..."
  },

  // REED - The Voice of Etymos
  druid: {
    vowel_goblin: ["Nature's gifts are powerful, but not finite. Those vowels belong to Etymos.", "The forest does not hoard its seeds. Why do you?"],
    ghost: ["Even the forgotten have roots. Etymos remembers what you were meant to be.", "You drift because you've lost your etymology. Return to the source."],
    synonym_roll: ["Many branches, one tree. You have forgotten the trunk.", "Variety is nature's way‚Äîbut you have lost your roots."],
    comma_chameleon: ["Nature breathes without pause. You interrupt the rhythm.", "The world speaks in flow. You stutter."],
    webster_spiderling: ["Even spiders serve the web of Etymos. You have forgotten your place within it.", "You define to control. Nature defines to connect."],
    hyphen_hyena: ["Connection should strengthen, not divide.", "Your bonds are chains. The forest knows freedom."],
    pun_goblin: ["Wordplay is the wind through leaves‚Äîbrief and forgotten.", "Your jokes scatter like seeds on stone."],
    apostro_fiend: ["What you take from words, Etymos reclaims.", "Possession is illusion. Return what you borrowed."],
    idiomatic_undead: ["The cycle demands you return to soil. You resist nature's grammar.", "Decay is a form of speech. You have forgotten how to finish your sentence."],
    vulgar_vandal: ["You poison the air with entropy. Etymos will cleanse what you've corrupted.", "Language is a gift. You use it as a weapon against itself."],
    double_negative: ["Nature knows only truth. Your contradictions wither.", "Even negatives feed the cycle‚Äîbut two starve it."],
    run_on_sentence: ["The river knows when to reach the sea. Learn from it.", "Endless flow without destination is a flood."],
    split_infinitive: ["What is divided must be rejoined. The roots teach this.", "You have split the seedling. It cannot grow."],
    mixed_metaphor: ["The forest speaks clearly. You have tangled its voice.", "Nature's metaphors are singular. Yours are noise."],
    passive_voice: ["The wind does not wait to be blown. Act, or be acted upon.", "Etymos speaks through those who move."],
    silent_knight: "Silence is the language of the earth. You wear it well, but understand nothing. The stones are silent too‚Äîthey outlast all knights. Etymos remembers what you have forgotten.",
    cinna_antony: "Etymos teaches that opposition and unity are both paths to truth. You've chosen neither‚Äîonly noise. The world grows tired of your argument.",
    red_aktins: "Etymos knows every word you've erased. The roots remain, buried but alive. You cannot unwrite what the world has already spoken.",
    plague_doctor: "A seed planted in stolen soil will never truly bloom. Etymos knows the difference between a root and a graft. You are no gardener.",
    oxy: "Fire and water, light and dark‚ÄîEtymos holds all opposites in balance. You are not balance. You are a wound that refuses to close.",
    dotdotdot: "Even Etymos knows that some thoughts must end for new ones to grow. You hoard potential and call it depth. It is only..."
  }
};

// Get hero dialogue for specific enemy encounter
function getHeroEnemyDialogue(heroId, enemyId) {
  const heroDialogues = HERO_ENEMY_DIALOGUE[heroId];
  if (!heroDialogues) return null;

  const dialogue = heroDialogues[enemyId];
  if (!dialogue) return null;

  // For regular enemies (arrays), pick random. For bosses (strings), return directly
  if (Array.isArray(dialogue)) {
    return dialogue[Math.floor(Math.random() * dialogue.length)];
  }
  return dialogue;
}

// === BOSS VICTORY DIALOGUE ===
// Unique lines heroes say after defeating specific bosses
const BOSS_VICTORY_DIALOGUE = {
  warrior: {
    cinna_antony: "They were at odds. Now, they are at peace.",
    red_aktins: "Your redactions are over. The record is restored.",
    plague_doctor: "An imitation is not the original. Your form was poor.",
    oxy: "Contradiction is illogical. Now it is resolved.",
    dotdotdot: "An unfinished sentence is not a life. Be complete.",
    silent_knight: "The 'K' is silent. Now, so are you. Your duty is done."
  },
  ranger: {
    cinna_antony: "Two notes make dissonance. One note makes peace. The song is over.",
    red_aktins: "One, two, three, your words fall away. My count is done.",
    plague_doctor: "You can follow my steps, but you can't find my rhythm. The dance is over.",
    oxy: "A tune sung high and low at once. Now... there is only quiet.",
    dotdotdot: "One beat, two beats, three beats... no four. An unfinished measure finds no melody.",
    silent_knight: "The quietest footstep makes the loudest echo. Listen."
  },
  mage: {
    cinna_antony: "A story pulling in two directions needs a firm editor. This draft is done.",
    red_aktins: "Your redactions were clumsy and cruel. Consider this my final, published revision.",
    plague_doctor: "A footnote trying to be the main text. Your plagiarism has earned you a full stop.",
    oxy: "This character's motivations were a first-draft mess. May you find consistency in the epilogue.",
    dotdotdot: "A promising opening, but no follow-through. Let us just write 'The End.'",
    silent_knight: "A character with no dialogue is a tragedy. May you find your voice in the margins."
  },
  paladin: {
    cinna_antony: "By my Oath, your discord is mended. Find harmony in the Archives of what-has-been.",
    red_aktins: "The Word cannot be chained or erased. May you find the passages you were missing.",
    plague_doctor: "To steal a Word is to profane it! Be cleansed of your borrowed, hollow speech.",
    oxy: "O, fractured soul, a paradox made manifest. The Word is Truth, not contradiction. Be whole again.",
    dotdotdot: "The Great Story must not be left unfinished. May you find your conclusion in the silence.",
    silent_knight: "Let The Word fill your void. Your silence was a prayer answered with peace."
  },
  assassin: {
    cinna_antony: "Arguing... then not.",
    red_aktins: "[REDACTED]... is un-redacted.",
    plague_doctor: "My moves... not yours.",
    oxy: "Contradiction... resolves.",
    dotdotdot: "You trailed off... I finished it.",
    silent_knight: "..."
  },
  druid: {
    cinna_antony: "Two branches fighting the wind. Now, they return to the same soil.",
    red_aktins: "You cannot prune a forest into a single, bare tree. Growth is inevitable.",
    plague_doctor: "A vine that mimics the shape of an oak is still just a vine. Find your own roots.",
    oxy: "A winter blossom, a sunless dawn. Nature does not abide such things for long. Be at ease.",
    dotdotdot: "A seed that never sprouts, a river that never reaches the sea. All things must complete their cycle.",
    silent_knight: "Even the oldest stone is worn down by patient moss. Your silence can finally feed the soil."
  }
};

// Get boss victory dialogue for hero-boss combination
function getBossVictoryDialogue(heroId, bossId) {
  const heroDialogues = BOSS_VICTORY_DIALOGUE[heroId];
  if (!heroDialogues) return null;
  return heroDialogues[bossId] || null;
}

// Talents are retired for this build to simplify balance.
// === ELEMENT FAMILIES ===
const WORLD_SKY = [E.FIRE, E.WATER, E.EARTH, E.LIGHTNING];
const BODY_SOUL = [E.PHYS, E.POISON, E.LIGHT, E.DARK];

// === TALENT HELPER FUNCTIONS ===
// Check if word is in a specific element family
function isWorldSky(elem) { return WORLD_SKY.includes(elem); }
function isBodySoul(elem) { return BODY_SOUL.includes(elem); }

// Check if weapon contains a specific element
function hasElement(words, elem) {
  return words.some(w => w.elem === elem);
}

// Check if weapon contains multiple specific elements
function hasElements(words, elems) {
  const wordElems = new Set(words.filter(w => w.elem !== undefined).map(w => w.elem));
  return elems.every(e => wordElems.has(e));
}

// Count words of a specific element
function countElement(words, elem) {
  return words.filter(w => w.elem === elem).length;
}

// Count words of a specific tier
function countTier(words, tier) {
  return words.filter(w => !w.isStick && w.rarity === tier).length;
}

// Count words of a specific type
function countType(words, type) {
  return words.filter(w => w.type === type).length;
}

// Count filled adjective slots (for Hendiadys - counts ANY word in adj slots)
function countAdjSlots(sel) {
  let count = 0;
  if (sel && sel.adj1) count++;
  if (sel && sel.adj2) count++;
  if (sel && sel.adj3) count++;
  if (sel && sel.adj4) count++;
  return count;
}

// Check if weapon has a specific damage type
function hasDamageType(weapon, damageType) {
  return weapon && weapon.category === damageType;
}

// Exponential chapter scaling - talents grow faster in later chapters
// For +W talents: Chapter 1: base, Chapter 2: base √ó 2.5, Chapter 3: base √ó 6, etc.
function chapterScale(base, chapter) {
  if (chapter <= 1) return base;
  return Math.round(base * Math.pow(2.5, chapter - 1) * 10) / 10;
}

// +W talents are now flat (no chapter scaling) - W is already a multiplier
function chapterScaleW(base, chapter) {
  return base;
}

// === TALENTS DATABASE (Consolidated - 40 Talents) ===
const TALENTS = [
  // ========================================
  // CATEGORY 1: GENERATORS (+W Base) - 8 Talents
  // Build your W pool. Fuel for thresholds.
  // ========================================

  // T2 - Per-word scaling
  {
    id: 'world_sky_focus',
    name: 'World & Sky Focus',
    desc: 'Each World & Sky Word: <span class="mod-badge word">+5 W</span>',
    flavor: "Fire, Water, Earth, Lightning empowered.",
    rarity: 'uncommon',
    category: 'generator',
    apply: (ctx) => 0 // Handled in computeWordCountBonuses()
  },
  {
    id: 'body_soul_focus',
    name: 'Body & Soul Focus',
    desc: 'Each Body & Soul Word: <span class="mod-badge word">+5 W</span>',
    flavor: "Physical, Poison, Light, Dark empowered.",
    rarity: 'uncommon',
    category: 'generator',
    apply: (ctx) => 0 // Handled in computeWordCountBonuses()
  },
  // T1 - Flat bonus, easy proc (MOVED from T2)
  {
    id: 'proficiency_focus',
    name: 'Proficiency Focus',
    desc: "Proficient Weapon in Forge: <span class=\"mod-badge word\">+6 W</span>",
    rarity: 'common',
    category: 'generator',
    apply: (ctx) => 0 // Handled in computeWordCountBonuses()
  },
  {
    id: 'weakness_exploit',
    name: 'Weakness Exploit',
    desc: 'Each Word hitting Weakness: <span class="mod-badge word">+6 W</span>',
    rarity: 'uncommon',
    category: 'generator',
    apply: (ctx) => 0 // Handled in computeWordCountBonuses()
  },
  // T2 - Hard condition (BUFFED from +10 to +15)
  {
    id: 'isocolon',
    name: 'Isocolon',
    desc: 'All Words same Tier: <span class="mod-badge word">+10 W</span>',
    flavor: "Parallel structure with equal length and rhythm.",
    rarity: 'uncommon',
    category: 'generator',
    apply: (ctx) => 0 // Handled in computeWordCountBonuses()
  },
  // T1 - Flat bonus, easy proc (MOVED from T2)
  {
    id: 'hendiadys',
    name: 'Hendiadys',
    desc: '2+ Adjective slots filled: <span class="mod-badge word">+6 W</span>',
    flavor: "Expression of a single idea using two words joined by 'and'.",
    rarity: 'common',
    category: 'generator',
    apply: (ctx) => 0 // Handled in computeWordCountBonuses()
  },
  // T1 - Flat element combo (MOVED from T2)
  {
    id: 'stony_brook',
    name: 'Stony Brook',
    desc: 'Water + Earth in Forge: <span class="mod-badge word">+12 W</span>',
    flavor: "Where rivers meet stone.",
    rarity: 'common',
    category: 'generator',
    apply: (ctx) => hasElements(ctx.allWords, [E.WATER, E.EARTH]) ? 12 : 0
  },
  {
    id: 'alliteration',
    name: 'Alliteration',
    desc: 'Each Word with 2+ consecutive same first letters: <span class="mod-badge word">+8 W</span>',
    flavor: "Peter Piper picked a peck...",
    rarity: 'uncommon',
    category: 'generator',
    apply: (ctx) => 0 // Handled in computeWordCountBonuses()
  },

  // ========================================
  // CATEGORY 2: MULTIPLIERS (√óM) - 12 Talents
  // Multiply final damage when conditions are met.
  // ========================================

  // --- Dual Element Synergies (7) ---
  {
    id: 'magma_core',
    name: 'Magma Core',
    desc: 'Fire + Earth in Forge: <span class="mod-badge scale">√ó2</span>',
    rarity: 'uncommon',
    category: 'multiplier',
    apply: (ctx) => hasElements(ctx.allWords, [E.FIRE, E.EARTH]) ? 2.0 : 1.0
  },
  {
    id: 'tempest',
    name: 'Tempest',
    desc: 'Lightning + Water in Forge: <span class="mod-badge scale">√ó2</span>',
    rarity: 'uncommon',
    category: 'multiplier',
    apply: (ctx) => hasElements(ctx.allWords, [E.LIGHTNING, E.WATER]) ? 2.0 : 1.0
  },
  // T2 - Element combo synergy (MOVED from T3, NERFED from √ó2.5 to √ó2)
  {
    id: 'eclipse',
    name: 'Umbral Dawn',
    desc: 'Light + Dark in Forge: <span class="mod-badge scale">√ó2</span>',
    rarity: 'uncommon',
    category: 'multiplier',
    apply: (ctx) => hasElements(ctx.allWords, [E.LIGHT, E.DARK]) ? 2.0 : 1.0
  },
  {
    id: 'necrotoxin',
    name: 'Thanatos',
    desc: 'Dark + Poison in Forge: <span class="mod-badge scale">√ó2</span>',
    rarity: 'uncommon',
    category: 'multiplier',
    apply: (ctx) => hasElements(ctx.allWords, [E.DARK, E.POISON]) ? 2.0 : 1.0
  },
  {
    id: 'blessed_steel',
    name: 'Helios',
    desc: 'Light + Physical in Forge: <span class="mod-badge scale">√ó2</span>',
    rarity: 'uncommon',
    category: 'multiplier',
    apply: (ctx) => hasElements(ctx.allWords, [E.LIGHT, E.PHYS]) ? 2.0 : 1.0
  },
  {
    id: 'static_earth',
    name: 'Gaia',
    desc: 'Lightning + Earth in Forge: <span class="mod-badge scale">√ó2</span>',
    rarity: 'uncommon',
    category: 'multiplier',
    apply: (ctx) => hasElements(ctx.allWords, [E.LIGHTNING, E.EARTH]) ? 2.0 : 1.0
  },

  // --- Structural Multipliers ---
  // T2 - Very hard condition (MOVED from T3, NERFED from √ó6 to √ó4)
  {
    id: 'synecdoche',
    name: 'Synecdoche',
    desc: '4+ Words same Element: <span class="mod-badge scale">√ó4</span>',
    flavor: "A part representing the whole, or the whole for a part.",
    rarity: 'uncommon',
    category: 'multiplier',
    apply: (ctx) => {
      const elemental = ctx.allWords.filter(w => w.elem !== undefined);
      if (elemental.length < 4) return 1.0;
      const firstElem = elemental[0].elem;
      if (!elemental.every(w => w.elem === firstElem)) return 1.0;
      return 4;
    }
  },
  // T2 - Restrictive condition (MOVED from T3, NERFED from √ó4 to √ó3)
  {
    id: 'minimalist',
    name: 'Brevity',
    desc: 'Exactly 2 Words in Forge: <span class="mod-badge scale">√ó3</span>',
    rarity: 'uncommon',
    category: 'multiplier',
    apply: (ctx) => ctx.allWords.length === 2 ? 3 : 1.0
  },
  // T2 - Medium condition (MOVED from T3)
  {
    id: 'maximalist',
    name: 'Maximalist',
    desc: 'All 6 slots filled: <span class="mod-badge scale">√ó2.5</span>',
    rarity: 'uncommon',
    category: 'multiplier',
    apply: (ctx) => ctx.allWords.length >= 6 ? 2.5 : 1.0
  },
  // T2 - Synergy card
  {
    id: 'dual_spec',
    name: 'Dual Spec',
    desc: "Both Hero's Strong Elements in Forge: <span class=\"mod-badge scale\">√ó2</span>",
    rarity: 'uncommon',
    category: 'multiplier',
    apply: (ctx) => {
      const heroStr = ctx.hero.str || [];
      if (heroStr.length < 2) return 1.0;
      if (!hasElements(ctx.allWords, heroStr)) return 1.0;
      return 2;
    }
  },
  // T1 - Easy condition (MOVED from T2, NERFED from √ó2 to √ó1.5)
  {
    id: 'weak_point',
    name: 'Weak Point',
    desc: "Hit Enemy Weakness: <span class=\"mod-badge scale\">√ó1.5</span>",
    rarity: 'common',
    category: 'multiplier',
    apply: (ctx) => {
      const hasWeakness = ctx.allWords.some(w =>
        w.elem !== undefined && ctx.enemy.weak.includes(w.elem)
      );
      return hasWeakness ? 1.5 : 1.0;
    }
  },
  // T2 - Very hard condition (MOVED from T3)
  {
    id: 'monolith',
    name: 'Monolith',
    desc: 'All Words T3: <span class="mod-badge scale">√ó4</span>',
    rarity: 'uncommon',
    category: 'multiplier',
    apply: (ctx) => {
      const nonStick = ctx.allWords.filter(w => !w.isStick);
      if (nonStick.length === 0 || !nonStick.every(w => w.rarity === 3)) return 1.0;
      return 4;
    }
  },

  // ========================================
  // CATEGORY 3: RETRIGGERS (REREAD)
  // Add word contributions again (AP + W). Feed the combo engine.
  // ========================================

  // T3 - Easy REREAD, always have first word
  {
    id: 'anaphora',
    name: 'Anaphora',
    desc: 'First Word in Forge: <span class="mod-badge reread">REREAD</span>',
    flavor: "Repetition of a word at the beginning of successive clauses.",
    rarity: 'rare',
    category: 'retrigger',
    apply: (ctx) => 0
  },
  // T3 - Easy REREAD, always have last word
  {
    id: 'epistrophe',
    name: 'Epistrophe',
    desc: 'Last Word in Forge: <span class="mod-badge reread">REREAD</span>',
    flavor: "Repetition of a word at the end of successive clauses.",
    rarity: 'rare',
    category: 'retrigger',
    apply: (ctx) => 0
  },
  // T2 - Medium condition (MOVED from T3)
  {
    id: 'gemination',
    name: 'Gemination',
    desc: '2+ Words same Tier: <span class="mod-badge reread">REREAD</span> all matching',
    flavor: "The doubling of a consonant sound.",
    rarity: 'uncommon',
    category: 'retrigger',
    apply: (ctx) => 0
  },
  // T2 - Very hard condition (MOVED from T3)
  {
    id: 'diacope',
    name: 'Diacope',
    desc: 'All 4 Elements from one Family: <span class="mod-badge reread">REREAD ALL</span>',
    flavor: "Repetition separated by intervening words.",
    rarity: 'uncommon',
    category: 'retrigger',
    apply: (ctx) => 0
  },
  // T2 - Conditional per-word (MOVED from T3)
  {
    id: 'resonance',
    name: 'Resonance',
    desc: "Each Hero's Strong Element Word: <span class=\"mod-badge reread\">REREAD</span>",
    rarity: 'uncommon',
    category: 'retrigger',
    apply: (ctx) => 0
  },
  // T3 - Easy REREAD, always have weapon
  {
    id: 'amplify',
    name: 'Khopesh',
    desc: 'Weapon Slot: <span class="mod-badge reread">REREAD</span>',
    rarity: 'rare',
    category: 'retrigger',
    apply: (ctx) => 0
  },
  // T1 - Easy but single word only (MOVED from T3)
  {
    id: 'gem_resonance',
    name: 'Gem Resonance',
    desc: 'Gem Slot filled: <span class="mod-badge reread">REREAD</span>',
    flavor: "The gem echoes with stored power.",
    rarity: 'common',
    category: 'retrigger',
    apply: (ctx) => 0
  },
  // T2 - Very conditional (MOVED from T3)
  {
    id: 'execute',
    name: 'Execute',
    desc: 'Enemy survives at ‚â§15% HP: <span class="mod-badge reread">REREAD ALL</span>',
    rarity: 'uncommon',
    category: 'retrigger',
    apply: (ctx) => 0
  },

  // ========================================
  // CATEGORY 4: CONVERTERS (Domino Fuel)
  // Transform one resource into another. Create chains.
  // ========================================

  // T3 - Loop enabler, scales with REREADs
  {
    id: 'echo_chamber',
    name: 'Echo Chamber',
    desc: 'Each <span class="mod-badge reread">REREAD</span>: <span class="mod-badge word">+5 W</span>',
    flavor: "Words echo through the chamber, amplifying their power.",
    rarity: 'rare',
    category: 'converter',
    apply: (ctx) => 0 // Handled in converter phase
  },
  // T2 - Conditional converter (MOVED from T3)
  {
    id: 'residual',
    name: 'Residual',
    desc: 'Each <span class="mod-badge word">+W</span> bonus: <span class="mod-badge add">+0.2 AP</span>',
    flavor: "The afterglow of powerful words.",
    rarity: 'uncommon',
    category: 'converter',
    apply: (ctx) => 0 // Handled in converter phase
  },
  // T1 - Simple always-on (MOVED from T2)
  {
    id: 'golden_tongue',
    name: 'Golden Tongue',
    desc: 'Each Adj: <span class="mod-badge word">+1 W</span> per 20 Gold',
    flavor: "Money speaks volumes.",
    rarity: 'common',
    category: 'converter',
    apply: (ctx) => 0 // Handled in converter phase
  },
  // T1 - Utility, not damage (MOVED from T3)
  {
    id: 'overkill_dividend',
    name: 'Overkill Dividend',
    desc: 'Overkill damage becomes Gold (10:1, max 50)',
    flavor: "Excessive force has its rewards.",
    rarity: 'common',
    category: 'converter',
    apply: (ctx) => 0 // Handled post-combat
  },
  // T1 - Gold from rereads
  {
    id: 'echo_profits',
    name: 'Echo Profits',
    desc: 'Each <span class="mod-badge reread">REREAD</span>: <span class="mod-badge gold">+2 Gold</span> after victory',
    flavor: "Every echo pays dividends.",
    rarity: 'common',
    category: 'converter',
    apply: (ctx) => 0,
    goldBonus: (ctx) => (ctx.state.lastCombatRereads || 0) * 2
  },
  // T2 - Gold from element diversity
  {
    id: 'elemental_bounty',
    name: 'Elemental Bounty',
    desc: 'Each unique Element: <span class="mod-badge gold">+3 Gold</span> after victory',
    flavor: "Nature rewards diversity.",
    rarity: 'uncommon',
    category: 'converter',
    apply: (ctx) => 0,
    goldBonus: (ctx) => {
      const words = ctx.allWords || [];
      const uniqueElems = new Set(words.filter(w => w.elem !== undefined).map(w => w.elem));
      return uniqueElems.size * 3;
    }
  },
  // T1 - Gold from T3 words
  {
    id: 'treasure_hunter',
    name: 'Treasure Hunter',
    desc: 'Each T3 Word in Forge: <span class="mod-badge gold">+5 Gold</span> after victory',
    flavor: "The rare are worth hunting.",
    rarity: 'common',
    category: 'converter',
    apply: (ctx) => 0,
    goldBonus: (ctx) => {
      const words = ctx.allWords || [];
      const t3Count = words.filter(w => w.rarity === T.T3).length;
      return t3Count * 5;
    }
  },
  // T1 - Gold from rarity words
  {
    id: 'appraisers_eye',
    name: "Appraiser's Eye",
    desc: 'Each Rarity Word: <span class="mod-badge gold">+5 Gold</span> after victory',
    flavor: "A trained eye knows true value.",
    rarity: 'common',
    category: 'converter',
    apply: (ctx) => 0,
    goldBonus: (ctx) => {
      const words = ctx.allWords || [];
      const rarityCount = words.filter(w => w.type === 'rarity').length;
      return rarityCount * 5;
    }
  },
  // T3 - Scaling multiplier, loop enabler
  {
    id: 'reread_amplifier',
    name: 'Reread Amplifier',
    desc: 'Each <span class="mod-badge reread">REREAD</span>: <span class="mod-badge scale">√ó1.5</span> (stacks)',
    flavor: "Repetition breeds power.",
    rarity: 'rare',
    category: 'converter',
    apply: (ctx) => 0 // Handled in converter phase
  },
  // T2 - Scaling per-word
  {
    id: 'lexicon_growth',
    name: 'Lexicon Growth',
    desc: 'Each Word per Boss defeated: <span class="mod-badge word">+1 W</span>',
    flavor: "Your vocabulary expands with each victory.",
    rarity: 'uncommon',
    category: 'converter',
    apply: (ctx) => 0 // Handled in converter phase
  },
  // T1 - Reliable scaling
  {
    id: 'momentum',
    name: 'Momentum',
    desc: 'Each Word: <span class="mod-badge word">+1 W</span> per Round completed',
    flavor: "Victory begets victory.",
    rarity: 'common',
    category: 'converter',
    apply: (ctx) => 0 // Handled in converter phase
  },
  // T3 - Scaling multiplier
  {
    id: 'compound_interest',
    name: 'Compound Interest',
    desc: 'Per 50 Gold: <span class="mod-badge scale">√ó1.15</span>',
    flavor: "Money makes money.",
    rarity: 'rare',
    category: 'converter',
    apply: (ctx) => 0 // Handled in converter phase
  },
  // T2 - Cumulative run tracker (words)
  {
    id: 'word_historian',
    name: 'Word Historian',
    desc: 'Gem: <span class="mod-badge word">+0.25 W</span> per Word used this run',
    flavor: "Every word you've spoken echoes forward.",
    rarity: 'uncommon',
    category: 'converter',
    apply: (ctx) => 0 // Handled in converter phase
  },
  // T2 - Cumulative run tracker (rereads)
  {
    id: 'reverberation',
    name: 'Reverberation',
    desc: 'Each Adj: <span class="mod-badge word">+2 W</span> per <span class="mod-badge reread">REREAD</span> this run',
    flavor: "Past echoes amplify future resonance.",
    rarity: 'uncommon',
    category: 'converter',
    apply: (ctx) => 0 // Handled in converter phase
  },

  // ========================================
  // W OVERFLOW BUILD - Quadratic Scaling
  // ========================================

  // T2 - Quadratic W scaling (word count √ó word count)
  {
    id: 'verbose_surplus',
    name: 'Verbose Surplus',
    desc: 'Each Adj: <span class="mod-badge word">+10 W</span> √ó Word count',
    flavor: "More words means more power! Each word amplifies the total.",
    rarity: 'uncommon',
    category: 'converter',
    apply: (ctx) => 0 // Handled in converter phase
  },
  // T2 - Rewards filling slots (4+ words)
  {
    id: 'linguistic_density',
    name: 'Linguistic Density',
    desc: '4+ Words: Each gains <span class="mod-badge word">+5 W</span> √ó Word count',
    flavor: "Dense language packs tremendous force.",
    rarity: 'uncommon',
    category: 'converter',
    apply: (ctx) => 0 // Handled in converter phase
  },

  // ========================================
  // ELEMENTAL BUILD - Cross-Combat Stacking
  // ========================================

  // T2 - Elemental W tracker (persists across combats)
  {
    id: 'elemental_mastery',
    name: 'Elemental Mastery',
    desc: 'Each Elemental Word played this run: <span class="mod-badge word">+1 W</span> to ALL Words',
    flavor: "Mastery grows with practice.",
    rarity: 'uncommon',
    category: 'converter',
    apply: (ctx) => 0 // Handled in converter phase + post-combat
  },
  // T3 - Exponential multiplier based on accumulated Word Count
  {
    id: 'prismatic_resonance',
    name: 'Prismatic Resonance',
    desc: 'Per <span class="mod-badge word">5 W</span> accumulated: <span class="mod-badge scale">√ó1.2</span>',
    flavor: "The rainbow weapon, forged across battles.",
    rarity: 'rare',
    category: 'converter',
    apply: (ctx) => 0 // Handled in converter phase
  },
  // T2 - Amplifier for elemental W (hitting weakness)
  {
    id: 'weakness_exploit_amp',
    name: 'Weakness Exploit Amp',
    desc: 'Each Word hitting Weakness this run: <span class="mod-badge word">+1 W</span> to ALL Words',
    flavor: "Exploit their flaws to master your craft.",
    rarity: 'uncommon',
    category: 'converter',
    apply: (ctx) => 0 // Handled in converter phase + post-combat
  },

  // ========================================
  // CATEGORY 5: THRESHOLDS (The Payoff)
  // Check accumulated values. Trigger big effects. Enable loops.
  // ========================================

  // T2 - Conditional REREAD (MOVED from T3)
  {
    id: 'critical_mass',
    name: 'Critical Mass',
    desc: 'Each T3 Word in Forge: <span class="mod-badge reread">REREAD</span>',
    flavor: "The tipping point.",
    rarity: 'uncommon',
    category: 'retrigger',
    apply: (ctx) => 0 // Handled in retrigger phase
  },
  // T2 - Rarity words get REREAD
  {
    id: 'rarity_cascade',
    name: 'Rarity Cascade',
    desc: 'Each Rarity Word in Forge: <span class="mod-badge reread">REREAD</span>',
    flavor: "Quality echoes through time.",
    rarity: 'uncommon',
    category: 'retrigger',
    apply: (ctx) => 0 // Handled in retrigger phase
  },
  // T3 - Scaling multiplier, rewards W building
  {
    id: 'overflow',
    name: 'Overflow',
    desc: 'Per <span class="mod-badge word">10 W</span> above 50: <span class="mod-badge scale">√ó1.5</span>',
    flavor: "More than the vessel can hold.",
    rarity: 'rare',
    category: 'converter',
    apply: (ctx) => 0 // Handled in converter phase
  },
  // T3 - Scaling multiplier, easy (just use elements)
  {
    id: 'cascade',
    name: 'Cascade',
    desc: 'Each unique Element in Forge: <span class="mod-badge scale">√ó1.5</span>',
    flavor: "An unstoppable torrent.",
    rarity: 'rare',
    category: 'multiplier',
    apply: (ctx) => {
      const elems = new Set(ctx.allWords.map(w => w.elem).filter(e => e !== undefined));
      return Math.pow(1.5, elems.size);
    }
  },
  // T3 - REREAD payoff threshold
  {
    id: 'chain_reaction',
    name: 'Chain Reaction',
    desc: '4+ <span class="mod-badge reread">REREAD</span>: <span class="mod-badge scale">√ó3</span>',
    flavor: "One triggers another.",
    rarity: 'rare',
    category: 'threshold',
    threshold: 4,
    resource: 'REREAD',
    apply: (ctx) => 0 // Handled in threshold phase
  },
  // T3 - Loop enabler
  {
    id: 'crescendo',
    name: 'Crescendo',
    desc: '6+ <span class="mod-badge reread">REREAD</span>: <span class="mod-badge reread">REREAD ALL</span> again',
    flavor: "Building to the climax.",
    rarity: 'rare',
    category: 'threshold',
    threshold: 6,
    resource: 'REREAD',
    apply: (ctx) => 0 // Handled in threshold phase
  },
  // T2 - Conditional threshold (MOVED from T3)
  {
    id: 'fortuna',
    name: 'Fortuna',
    desc: '100+ Gold: <span class="mod-badge scale">√ó2</span>',
    flavor: "Fortune favors the wealthy.",
    rarity: 'uncommon',
    category: 'threshold',
    threshold: 100,
    resource: 'GOLD',
    apply: (ctx) => (ctx.state.gold || 0) >= 100 ? 2 : 1.0
  },
  // T1 - Situational freebie (MOVED from T2)
  {
    id: 'capital_punishment',
    name: 'Capital Punishment',
    desc: 'Enemy is Boss or Miniboss: <span class="mod-badge scale">√ó2.5</span>',
    flavor: "Big letters for big enemies.",
    rarity: 'common',
    category: 'threshold',
    apply: (ctx) => (ctx.enemy.isBoss || ctx.enemy.isMiniboss) ? 2.5 : 1.0
  },
  // T3 - Easy condition, big payoff (late game always-on)
  {
    id: 'berserker',
    name: 'Berserker',
    desc: 'Per Chapter: <span class="mod-badge scale">√ó1.5</span>',
    flavor: "Rage builds with time.",
    rarity: 'rare',
    category: 'multiplier',
    apply: (ctx) => {
      const chapter = Math.floor(((ctx.state.roundIndex || 1) - 1) / 9) + 1;
      return Math.pow(1.5, chapter);
    }
  },
  // T2 - Hard condition (MOVED from T3)
  {
    id: 'perfectionist',
    name: 'Perfectionist',
    desc: 'All 6 slots filled, no Resisted Elements: <span class="mod-badge scale">√ó3</span>',
    flavor: "Flawless execution.",
    rarity: 'uncommon',
    category: 'threshold',
    apply: (ctx) => {
      // Check all 6 slots filled
      const slots = ['item', 'adj1', 'adj2', 'adj3', 'adj4', 'noun1'];
      const allFilled = slots.every(s => ctx.sel[s]);
      if (!allFilled) return 1.0;
      // Check no resisted elements
      const hasResisted = ctx.allWords.some(w =>
        w.elem !== undefined && ctx.enemy.res && ctx.enemy.res.includes(w.elem)
      );
      return !hasResisted ? 3 : 1.0;
    }
  },

  // ========================================
  // CATEGORY 6: EFFECTS (Rule Benders)
  // Unique mechanics that change how the game works.
  // ========================================

  // T2 - Build enabler (MOVED from T3)
  {
    id: 'signature_style',
    name: 'Signature Style',
    desc: "Proficient Weapon counts as both Hero's Strong Elements",
    rarity: 'uncommon',
    category: 'effect',
    disabled: true, // Too inconsistent to balance
    apply: (ctx) => 0
  },
  // T1 - Simple utility (MOVED from T2)
  {
    id: 'irony',
    name: 'Irony',
    desc: "One Enemy Resistance becomes Weakness",
    flavor: "A figure of speech where the intended meaning is opposite to the literal meaning.",
    rarity: 'common',
    category: 'effect',
    apply: (ctx) => 1.0
  },
  // T3 - Direct power boost
  {
    id: 'crown_jewel',
    name: 'Kohinoor',
    desc: 'Gem Slot: <span class="mod-badge word">√ó4 W</span> instead of √ó2',
    flavor: "Mountain of Light.",
    rarity: 'rare',
    category: 'effect',
    apply: (ctx) => 0
  },
  // T2 - Conditional effect (MOVED from T3)
  {
    id: 'hyperbole',
    name: 'Hyperbole',
    desc: 'Overkill √ó2 carries to next Round (max 25% HP)',
    flavor: "Exaggerated statements not meant to be taken literally.",
    rarity: 'uncommon',
    category: 'effect',
    apply: (ctx) => 1.0
  },

  // ========================================
  // EXISTING TALENTS - Rebalanced
  // ========================================

  // T1 - Simple flat-ish bonus (MOVED from T2)
  {
    id: 'word_hoard',
    name: 'Word Hoard',
    desc: 'Each Adj: <span class="mod-badge word">+0.2 W</span> per Inventory Word',
    flavor: "A dragon's treasure of language.",
    rarity: 'common',
    category: 'generator',
    apply: (ctx) => 0 // Handled in W calculation
  },
  // T1 - Always-on scaling (MOVED from T2)
  {
    id: 'slow_burn',
    name: 'Slow Burn',
    desc: 'Weapon: <span class="mod-badge word">+2 W</span> per Round',
    flavor: "Patience rewards the persistent.",
    rarity: 'common',
    category: 'generator',
    apply: (ctx) => 0 // Handled in W calculation
  },

  // T2 - Restrictive condition (MOVED from T3, NERFED from √ó3 to √ó2.5)
  {
    id: 'trinity',
    name: 'Trinity',
    desc: 'Exactly 3 Words in Forge: <span class="mod-badge scale">√ó2.5</span>',
    flavor: "Three is a magic number.",
    rarity: 'uncommon',
    category: 'multiplier',
    apply: (ctx) => ctx.allWords.length === 3 ? 2.5 : 1.0
  },
  // T2 - Very restrictive (MOVED from T3, NERFED from √ó6 to √ó5)
  {
    id: 'glass_cannon',
    name: 'Glass Cannon',
    desc: 'Exactly 1 Word in Forge: <span class="mod-badge scale">√ó5</span>',
    flavor: "One word to rule them all.",
    rarity: 'uncommon',
    category: 'multiplier',
    apply: (ctx) => ctx.allWords.length === 1 ? 5 : 1.0
  },
  // T2 - Medium condition (MOVED from T3)
  {
    id: 'focused_fire',
    name: 'Focused Fire',
    desc: "Only 1 of Hero's Strong Elements in Forge: <span class=\"mod-badge scale\">√ó2.5</span>",
    flavor: "Specialization over diversification.",
    rarity: 'uncommon',
    category: 'multiplier',
    apply: (ctx) => {
      const hero = ctx.hero;
      if (!hero || !hero.str) return 1.0;
      const elementsInWeapon = new Set(ctx.allWords.map(w => w.elem).filter(e => e !== undefined));
      const strongInWeapon = hero.str.filter(e => elementsInWeapon.has(e));
      return strongInWeapon.length === 1 ? 2.5 : 1.0;
    }
  },
  // T1 - Easy condition (MOVED from T2, NERFED from √ó2 to √ó1.5)
  {
    id: 'opening_strike',
    name: 'Opening Strike',
    desc: 'Weapon is first slot filled: <span class="mod-badge scale">√ó1.5</span>',
    flavor: "Lead with your blade.",
    rarity: 'common',
    category: 'multiplier',
    apply: (ctx) => {
      // Check if weapon slot exists and is the "first" word (leftmost filled slot)
      if (!ctx.sel.item) return 1.0;
      const slots = ['item', 'adj1', 'adj2', 'adj3', 'adj4', 'noun1'];
      const firstFilledSlot = slots.find(s => ctx.sel[s]);
      return firstFilledSlot === 'item' ? 1.5 : 1.0;
    }
  },

  // T2 - Conditional REREAD (MOVED from T3)
  {
    id: 'polysyndeton',
    name: 'Polysyndeton',
    desc: '3+ Elements in Forge: <span class="mod-badge reread">REREAD</span> highest AP Word',
    flavor: "Conjunction junction, what's your function?",
    rarity: 'uncommon',
    category: 'retrigger',
    apply: (ctx) => 0 // Handled in REREAD phase
  },
  // T2 - Hard condition (MOVED from T3)
  {
    id: 'anadiplosis',
    name: 'Anadiplosis',
    desc: 'Adjacent Words share Element: <span class="mod-badge reread">REREAD</span> both',
    flavor: "The end of one becomes the beginning of another.",
    rarity: 'uncommon',
    category: 'retrigger',
    apply: (ctx) => 0 // Handled in REREAD phase
  },
  // T2 - Hard condition (MOVED from T3)
  {
    id: 'chiasmus',
    name: 'Chiasmus',
    desc: 'First and Last elemental Words same Element: <span class="mod-badge reread">REREAD √ó2</span> both',
    flavor: "What begins, ends. What ends, begins.",
    rarity: 'uncommon',
    category: 'retrigger',
    apply: (ctx) => 0 // Handled in REREAD phase
  },

  // T2 - Conditional converter (MOVED from T3)
  {
    id: 'tithe',
    name: 'Tithe',
    desc: 'Each Adj: <span class="mod-badge word">+2 W</span> per 20 Gold spent',
    flavor: "Offerings beget power.",
    rarity: 'uncommon',
    category: 'converter',
    apply: (ctx) => 0 // Handled in W calculation
  },

  // ========================================
  // NEW T1 TALENTS - Simple, early game helpers
  // ========================================

  // T1 - Always-on flat bonus
  {
    id: 'steady_hand',
    name: 'Steady Hand',
    desc: 'Weapon: <span class="mod-badge word">+3 W</span>',
    flavor: "A firm grip yields consistent results.",
    rarity: 'common',
    category: 'generator',
    apply: (ctx) => 0 // Handled in W calculation
  },
  // T1 - Early game helper (falls off)
  {
    id: 'first_blood',
    name: 'First Blood',
    desc: 'Ch.1 - Weapon: <span class="mod-badge word">+10 W</span>',
    flavor: "Write when the iron is hot.",
    rarity: 'common',
    category: 'generator',
    apply: (ctx) => 0 // Handled in W calculation
  },
  // T1 - Simple condition
  {
    id: 'comfort_zone',
    name: 'Comfort Zone',
    desc: 'Only 1 Element type in Forge: <span class="mod-badge word">+6 W</span>',
    flavor: "Familiarity breeds confidence.",
    rarity: 'common',
    category: 'generator',
    apply: (ctx) => 0 // Handled in W calculation
  },
  // T1 - Deck diversity reward
  {
    id: 'linguist',
    name: 'Linguist',
    desc: '3+ Types: Each Word gains <span class="mod-badge word">+5 W</span>',
    flavor: "A polyglot of destruction.",
    rarity: 'common',
    category: 'generator',
    apply: (ctx) => 0 // Handled in W calculation
  },
  // T1 - Simple condition
  {
    id: 'condensed',
    name: 'Condensed',
    desc: '‚â§3 Words: Each gains <span class="mod-badge word">+8 W</span>',
    flavor: "Less is more.",
    rarity: 'common',
    category: 'generator',
    apply: (ctx) => 0 // Handled in W calculation
  },
  // T1 - Flat per-element (not per-word)
  {
    id: 'spectrum',
    name: 'Spectrum',
    desc: 'Each unique Element in Forge: <span class="mod-badge word">+2 W</span>',
    flavor: "A rainbow of destruction.",
    rarity: 'common',
    category: 'generator',
    apply: (ctx) => 0 // Handled in W calculation
  },
  // T1 - Flat element combo
  {
    id: 'inferno',
    name: 'Inferno',
    desc: 'Fire + Water in Forge: <span class="mod-badge word">+10 W</span>',
    flavor: "Steam and fury.",
    rarity: 'common',
    category: 'generator',
    apply: (ctx) => hasElements(ctx.allWords, [E.FIRE, E.WATER]) ? 10 : 0
  },
  // T1 - Flat element combo
  {
    id: 'verdant',
    name: 'Verdant',
    desc: 'Earth + Light in Forge: <span class="mod-badge word">+10 W</span>',
    flavor: "Growth under sunlight.",
    rarity: 'common',
    category: 'generator',
    apply: (ctx) => hasElements(ctx.allWords, [E.EARTH, E.LIGHT]) ? 10 : 0
  },
  // T1 - Flat element combo
  {
    id: 'venom_strike',
    name: 'Venom Strike',
    desc: 'Poison + Lightning in Forge: <span class="mod-badge word">+10 W</span>',
    flavor: "Shocking toxicity.",
    rarity: 'common',
    category: 'generator',
    apply: (ctx) => hasElements(ctx.allWords, [E.POISON, E.LIGHTNING]) ? 10 : 0
  },
  // T1 - Flat element combo
  {
    id: 'twilight',
    name: 'Twilight',
    desc: 'Dark + Physical in Forge: <span class="mod-badge word">+10 W</span>',
    flavor: "Shadows made manifest.",
    rarity: 'common',
    category: 'generator',
    apply: (ctx) => hasElements(ctx.allWords, [E.DARK, E.PHYS]) ? 10 : 0
  },
  // T1 - Simple per-word AP
  {
    id: 'bibliophile',
    name: 'Bibliophile',
    desc: 'Each Word in Forge: <span class="mod-badge word">+1 W</span>',
    flavor: "Knowledge is power.",
    rarity: 'common',
    category: 'generator',
    apply: (ctx) => 0 // Handled in AP calculation
  },

  // ========================================
  // GOLD BUILD TALENTS
  // In-combat gold generation and feedback loops
  // ========================================

  // T2 - In-combat gold generator (THE KEY ENABLER)
  {
    id: 'midas_touch',
    name: 'Midas Touch',
    desc: 'Each Elemental Word in Forge: <span class="mod-badge gold">+5 Gold</span> (in combat)',
    flavor: "Everything you touch turns to gold.",
    rarity: 'uncommon',
    category: 'converter',
    apply: (ctx) => 0 // Handled in converter phase
  },
  // T2 - Gold from REREADs
  {
    id: 'golden_reread',
    name: 'Golden Reread',
    desc: 'Each <span class="mod-badge reread">REREAD</span>: <span class="mod-badge gold">+10 Gold</span> (in combat)',
    flavor: "Repetition pays dividends.",
    rarity: 'uncommon',
    category: 'converter',
    apply: (ctx) => 0 // Handled in converter phase
  },
  // T3 - Gold threshold loop enabler
  {
    id: 'fortunes_favor',
    name: "Fortune's Favor",
    desc: '200+ Gold held: <span class="mod-badge reread">REREAD ALL</span>',
    flavor: "Fortune favors the wealthy.",
    rarity: 'rare',
    category: 'threshold',
    threshold: 200,
    resource: 'GOLD',
    apply: (ctx) => 0 // Handled in threshold phase
  },
  // T2 - W to Gold economy
  {
    id: 'liquidate',
    name: 'Liquidate',
    desc: 'After victory: <span class="mod-badge gold">+1 Gold</span> per <span class="mod-badge word">5 W</span>',
    flavor: "Cash out your assets.",
    rarity: 'uncommon',
    category: 'economy',
    goldBonus: (ctx) => {
      // Calculate total W from phrase
      const words = ctx.allWords || [];
      const totalW = words.reduce((sum, w) => sum + (w.word?.length || w.name?.length || 0), 0);
      return Math.floor(totalW / 5);
    }
  }
];
// === CONSUMABLES (one-time use) ===
const CONSUMABLES=[
  {id:"same_day_delivery",name:"Same-Day Delivery",cost:25,desc:"Generate a random T3 Word and add to inventory.",
   use:(S)=>{
     const pool=WORDS.filter(w=>w.rarity===T.T3);
     if(pool.length>0){
       const visibleCount = S.inv.filter(w => !w.hiddenInBank).length;
       if(visibleCount>=INV_LIMIT){
         return {success:false,message:"Inventory full! Cannot add new Word."};
       }
       const w=pool[Math.random()*pool.length|0];
       const newWord={...w};
       S.inv.push(newWord);
       return {success:true,message:`Generated ${w.name}!`,affectedWord:newWord,effectType:'generate'};
     }
     return {success:false,message:"No T3 Words available."};
   }},
  {id:"weapon_master_consumable",name:"Weapon Master",cost:15,desc:"All weapons get √ó3 proficiency bonus this battle.",
   use:(S)=>{S.tempEffects.weaponMaster=3;return {success:true,message:"Weapon Master active! All weapons √ó3!"}}},
  {id:"quality_assurance",name:"Quality Assurance",cost:15,desc:"Upgrade a selected Word's Tier by 1.",
   use:(S)=>{
     const target = S.pendingWord;
     if(!target) return {success:false,message:"Highlight a Word to upgrade."};
     // Special handling for the Stick - upgrade to hero's preferred weapon type
     if(target.isStick){
       const preferredCategory = S.hero?.good || 'slash';
       // Find a T1 weapon of the hero's preferred type
       const preferredWeapon = WORDS.find(w => w.type === 'weapon' && w.category === preferredCategory && w.rarity === T.T1);
       // Fallback to any T1 weapon if preferred not found
       const upgradeWeapon = preferredWeapon || WORDS.find(w => w.type === 'weapon' && w.rarity === T.T1);
       if(upgradeWeapon){
         // Create a fresh copy to ensure isStick is not preserved
         const upgradeCopy = {...upgradeWeapon};
         applyWordUpgrade(target, upgradeCopy);
         return {success:true,message:`Stick upgraded to ${upgradeCopy.name}!`,affectedWord:target,effectType:'upgrade'};
       }
       return {success:false,message:"Could not upgrade Stick."};
     }
     const rank = getTierRank(target);
     if(rank >= 3) return {success:false,message:`${target.name} is already at the highest rank.`};
     const nextTierWord=findNextTierWord(target);
     if(!nextTierWord){
       return {success:false,message:`${target.name} is already at the highest rank.`};
     }
     applyWordUpgrade(target,nextTierWord);
     return {success:true,message:`${target.name} refined!`,affectedWord:target,effectType:'upgrade'};
   }},
  {id:"polymorph",name:"Polymorph",cost:12,desc:"Transform the enemy and remove their Resistances.",
   use:(S)=>{S.tempEffects.polymorph=true;return {success:true,message:"Enemy resistances nullified!"}}},
  {id:"elemental_inversion",name:"Antithesis",cost:18,desc:"Replace a Word with its opposite Element equivalent.",
   use:(S)=>{
     const target = S.pendingWord;
     if(!target) return {success:false,message:"Highlight a Word to invert."};
     if(target.elem === undefined) return {success:false,message:`${target.name} has no element.`};
     // Define opposite element pairs
     const opposites = {
       [E.FIRE]: E.WATER,
       [E.WATER]: E.FIRE,
       [E.EARTH]: E.LIGHTNING,
       [E.LIGHTNING]: E.EARTH,
       [E.LIGHT]: E.DARK,
       [E.DARK]: E.LIGHT,
       [E.POISON]: E.PHYS,
       [E.PHYS]: E.POISON
     };
     const newElem = opposites[target.elem];
     if(newElem === undefined) return {success:false,message:"Element cannot be inverted."};

     const oldElemName = EN[target.elem];
     const newElemName = EN[newElem];

     // Find a replacement word of the same tier with the opposite element
     const targetTier = target.rarity;
     const replacementCandidates = WORDS.filter(w =>
       w.elem === newElem &&
       w.rarity === targetTier &&
       w.type === target.type &&
       !w.hiddenInBank
     );

     if(replacementCandidates.length > 0) {
       // Replace with a matching word from the pool
       const replacement = {...replacementCandidates[Math.floor(Math.random() * replacementCandidates.length)]};
       // Find and replace in inventory
       const idx = S.inv.indexOf(target);
       if(idx !== -1) {
         S.inv[idx] = replacement;
         // Also update if in a slot
         for(const slot of ['item','adj1','adj2','adj3','adj4','noun1']) {
           if(S.sel[slot] === target) S.sel[slot] = replacement;
         }
         return {success:true,message:`${target.name} ‚Üí ${replacement.name}! (${oldElemName} ‚Üí ${newElemName})`,affectedWord:replacement,effectType:'transform'};
       }
     }

     // Fallback: if no matching word found, just change element and name
     target.elem = newElem;
     target.name = newElemName; // Simple rename to element name
     if(target.desc) target.desc = target.desc.replace(oldElemName, newElemName);
     return {success:true,message:`${target.name} inverted! (${oldElemName} ‚Üí ${newElemName})`,affectedWord:target,effectType:'transform'};
   }},
  {id:"tautology",name:"Tautology",cost:20,desc:"Copy a selected Word from your inventory.",
   use:(S)=>{
     const target = S.pendingWord;
     if(!target) return {success:false,message:"Highlight a Word to copy."};
     // Check if we have room in inventory
     const visibleCount = S.inv.filter(w => !w.hiddenInBank).length;
     if(visibleCount >= INV_LIMIT){
       return {success:false,message:"Inventory full! Cannot add copy."};
     }
     // Create a deep copy of the word
     const copy = {...target};
     S.inv.push(copy);
     return {success:true,message:`Copied ${target.name}!`,affectedWord:copy,sourceWord:target,effectType:'copy'};
   }},
  {id:"shackles",name:"Shackles",cost:22,desc:"Bind the Boss and disable their special ability.",
   use:(S)=>{
     if(!S.chapterBoss){
       return {success:false,message:"No Boss to bind!"};
     }
     S.tempEffects.disableBossAbility=true;
     return {success:true,message:`${S.chapterBoss.name} bound! ${S.chapterBoss.ability?.name || 'Ability'} disabled!`};
   }}
];

// === WORDS ===
const WORDS=[
  // Weapons organized by category: Slash, Pierce, Blunt, Magic (3 tiers each)
  // Slash weapons (T1, T2, T3)
  {id:"sword",name:"Sword",type:"weapon",category:"slash",rarity:T.T1,desc:"A balanced blade."},
  {id:"greatsword",name:"Greatsword",type:"weapon",category:"slash",rarity:T.T2,desc:"A powerful two-handed sword."},
  {id:"claymore",name:"Claymore",type:"weapon",category:"slash",rarity:T.T3,desc:"A legendary Highland blade."},
  // Pierce weapons (T1, T2, T3)
  {id:"bow",name:"Bow",type:"weapon",category:"pierce",rarity:T.T1,desc:"A ranged weapon."},
  {id:"longbow",name:"Longbow",type:"weapon",category:"pierce",rarity:T.T2,desc:"A powerful ranged weapon."},
  {id:"warbow",name:"Warbow",type:"weapon",category:"pierce",rarity:T.T3,desc:"A masterwork bow of immense power."},
  // Magic weapons (T1, T2, T3)
  {id:"wand",name:"Wand",type:"weapon",category:"magic",rarity:T.T1,desc:"A simple magical focus."},
  {id:"staff",name:"Staff",type:"weapon",category:"magic",rarity:T.T2,desc:"A powerful channeling staff."},
  {id:"scepter",name:"Scepter",type:"weapon",category:"magic",rarity:T.T3,desc:"A royal arcane artifact."},
  // Blunt weapons (T1, T2, T3)
  {id:"mace",name:"Mace",type:"weapon",category:"blunt",rarity:T.T1,desc:"A heavy bludgeon."},
  {id:"warhammer",name:"Warhammer",type:"weapon",category:"blunt",rarity:T.T2,desc:"A crushing war weapon."},
  {id:"maul",name:"Maul",type:"weapon",category:"blunt",rarity:T.T3,desc:"A massive two-handed hammer."},
  // Rarity words - Pure multipliers (non-elemental)
  // Scaled for REREAD synergy: each tier roughly doubles with 2 REREADs
  {id:"adj_common",name:"Common",type:"rarity",mult:1.25,rarity:T.T1,desc:"√ó1.25 multiplier."},
  {id:"adj_uncommon",name:"Uncommon",type:"rarity",mult:1.5,rarity:T.T1,desc:"√ó1.5 multiplier."},
  {id:"adj_magic",name:"Magic",type:"rarity",mult:1.75,rarity:T.T2,desc:"√ó1.75 multiplier."},
  {id:"adj_rare",name:"Rare",type:"rarity",mult:2.0,rarity:T.T2,desc:"√ó2.0 multiplier."},
  {id:"adj_epic",name:"Epic",type:"rarity",mult:2.5,rarity:T.T3,desc:"√ó2.5 multiplier."},
  {id:"adj_legendary",name:"Legendary",type:"rarity",mult:3.0,rarity:T.T3,desc:"√ó3.0 multiplier."},
  // Elemental words (noun + adjective forms)
  // FIRE
  {id:"fire_n",name:"Fire",type:"elemental",elem:E.FIRE,rarity:T.T1,desc:"Fire",nounForm:"Fire",adjPrimary:"Fiery",adjAlt:"Fiery"},
  {id:"blaze_n",name:"Blaze",type:"elemental",elem:E.FIRE,rarity:T.T2,desc:"Fire",nounForm:"Blaze",adjPrimary:"Blazing",adjAlt:"Blazing"},
  {id:"phoenix_n",name:"Phoenix",type:"elemental",elem:E.FIRE,rarity:T.T3,desc:"Fire",nounForm:"Phoenix",adjPrimary:"Infernal",adjAlt:"Infernal"},
  // WATER
  {id:"water_n",name:"Water",type:"elemental",elem:E.WATER,rarity:T.T1,desc:"Water",nounForm:"Water",adjPrimary:"Watery",adjAlt:"Watery"},
  {id:"tide_n",name:"Tide",type:"elemental",elem:E.WATER,rarity:T.T2,desc:"Water",nounForm:"Tide",adjPrimary:"Tidal",adjAlt:"Tidal"},
  {id:"leviathan_n",name:"Leviathan",type:"elemental",elem:E.WATER,rarity:T.T3,desc:"Water",nounForm:"Leviathan",adjPrimary:"Torrential",adjAlt:"Torrential"},
  // LIGHTNING
  {id:"spark_n",name:"Spark",type:"elemental",elem:E.LIGHTNING,rarity:T.T1,desc:"Lightning",nounForm:"Spark",adjPrimary:"Sparking",adjAlt:"Sparking"},
  {id:"bolt_n",name:"Bolt",type:"elemental",elem:E.LIGHTNING,rarity:T.T2,desc:"Lightning",nounForm:"Bolt",adjPrimary:"Bolting",adjAlt:"Bolting"},
  {id:"thunderbird_n",name:"Thunderbird",type:"elemental",elem:E.LIGHTNING,rarity:T.T3,desc:"Lightning",nounForm:"Thunderbird",adjPrimary:"Thunderous",adjAlt:"Thunderous"},
  // EARTH
  {id:"stone_n",name:"Stone",type:"elemental",elem:E.EARTH,rarity:T.T1,desc:"Earth",nounForm:"Stone",adjPrimary:"Stony",adjAlt:"Stony"},
  {id:"quake_n",name:"Quake",type:"elemental",elem:E.EARTH,rarity:T.T2,desc:"Earth",nounForm:"Quake",adjPrimary:"Quaking",adjAlt:"Quaking"},
  {id:"behemoth_n",name:"Behemoth",type:"elemental",elem:E.EARTH,rarity:T.T3,desc:"Earth",nounForm:"Behemoth",adjPrimary:"Colossal",adjAlt:"Colossal"},
  // LIGHT
  {id:"light_n",name:"Light",type:"elemental",elem:E.LIGHT,rarity:T.T1,desc:"Light",nounForm:"Light",adjPrimary:"Bright",adjAlt:"Bright"},
  {id:"glow_n",name:"Glow",type:"elemental",elem:E.LIGHT,rarity:T.T2,desc:"Light",nounForm:"Glow",adjPrimary:"Glowing",adjAlt:"Glowing"},
  {id:"seraph_n",name:"Seraph",type:"elemental",elem:E.LIGHT,rarity:T.T3,desc:"Light",nounForm:"Seraph",adjPrimary:"Radiant",adjAlt:"Radiant"},
  // DARK
  {id:"shadow_n",name:"Shadow",type:"elemental",elem:E.DARK,rarity:T.T1,desc:"Dark",nounForm:"Shadow",adjPrimary:"Shadowy",adjAlt:"Shadowy"},
  {id:"gloom_n",name:"Gloom",type:"elemental",elem:E.DARK,rarity:T.T2,desc:"Dark",nounForm:"Gloom",adjPrimary:"Gloomy",adjAlt:"Gloomy"},
  {id:"nightmare_n",name:"Nightmare",type:"elemental",elem:E.DARK,rarity:T.T3,desc:"Dark",nounForm:"Nightmare",adjPrimary:"Voided",adjAlt:"Voided"},
  // POISON
  {id:"venom_n",name:"Venom",type:"elemental",elem:E.POISON,rarity:T.T1,desc:"Poison",nounForm:"Venom",adjPrimary:"Venomous",adjAlt:"Venomous"},
  {id:"toxin_n",name:"Toxin",type:"elemental",elem:E.POISON,rarity:T.T2,desc:"Poison",nounForm:"Toxin",adjPrimary:"Toxic",adjAlt:"Toxic"},
  {id:"basilisk_n",name:"Basilisk",type:"elemental",elem:E.POISON,rarity:T.T3,desc:"Poison",nounForm:"Basilisk",adjPrimary:"Plagued",adjAlt:"Plagued"},
  // PHYSICAL
  {id:"strike_n",name:"Strike",type:"elemental",elem:E.PHYS,rarity:T.T1,desc:"Physical",nounForm:"Strike",adjPrimary:"Striking",adjAlt:"Striking"},
  {id:"crush_n",name:"Crush",type:"elemental",elem:E.PHYS,rarity:T.T2,desc:"Physical",nounForm:"Crush",adjPrimary:"Crushing",adjAlt:"Crushing"},
  {id:"bear_n",name:"Bear",type:"elemental",elem:E.PHYS,rarity:T.T3,desc:"Physical",nounForm:"Bear",adjPrimary:"Furious",adjAlt:"Furious"}];

// === Word forms ===
// Each word now carries a primary adjective, an alternate adjective (used to avoid repetition),
// and a noun form. Weapons keep their name in all slots. Elemental nouns use the new
// adjPrimary/adjAlt pairs supplied in the WORDS list for richer naming variety.
const WORD_FORMS = {};
(() => {
  WORDS.forEach(w => {
    const noun = w.nounForm || w.name;
    const adjPrimary = w.adjPrimary || w.adjForm || w.name;
    const adjAlt = w.adjAlt || adjPrimary;
    WORD_FORMS[w.id] = {
      noun,
      adjPrimary,
      adjAlt,
      nounForm: noun,
      adjForm: adjPrimary
    };
  });
})();

// Helper to pick the correct display form for a word in a given slot. For adjective slots we
// use the primary adjective, but if that adjective (or the noun itself) already appears
// elsewhere in the current selection we fall back to the alt adjective to avoid repetition
// (e.g., "Bashing Bash" ‚Üí "Bashful Bash").
function getDisplayForm(word, slotKey = '', selection = S?.sel) {
  if (!word) return '';
  const forms = WORD_FORMS[word.id] || {};
  const noun = forms.noun || forms.nounForm || word.name;
  const adjPrimary = forms.adjPrimary || forms.adjForm || word.name;
  const adjAlt = forms.adjAlt || adjPrimary;

  // T3 elemental words: use creature name (noun) only in gem slot, always use adjAlt in adj slots
  const isT3Elemental = word.type === 'elemental' && word.rarity === T.T3;

  if (slotKey.startsWith('noun')) return noun;
  if (slotKey.startsWith('adj')) {
    // T3 elementals always use their alt adjective (generic form) in adjective slots
    if (isT3Elemental) return adjAlt;

    const sel = selection || {};
    const used = [];
    const startingLetters = new Set(); // Track starting letters of other words for Alliteration
    const slotOrder = ['item','adj1','adj2','adj3','adj4','noun1'];
    const slotIdx = slotOrder.indexOf(slotKey);
    Object.entries(sel).forEach(([k, v]) => {
      if (!v || k === slotKey) return;
      // Only consider words that appear earlier in the forge order so the "later" duplicate
      // swaps to its alt adjective.
      if (slotIdx !== -1) {
        const otherIdx = slotOrder.indexOf(k);
        if (otherIdx !== -1 && otherIdx > slotIdx) return;
      }
      if (k.startsWith('adj') || k.startsWith('noun')) {
        const otherForms = WORD_FORMS[v.id] || {};
        const otherAdj = otherForms.adjPrimary || otherForms.adjForm || v.name;
        const otherNoun = otherForms.noun || otherForms.nounForm || v.name;
        used.push(otherAdj.toLowerCase());
        used.push(otherNoun.toLowerCase());
        // Track starting letters for Alliteration talent
        const displayedForm = k.startsWith('noun') ? otherNoun : otherAdj;
        if (displayedForm) startingLetters.add(displayedForm[0].toLowerCase());
      }
      // Also track weapon starting letter
      if (k === 'item' && v.name) {
        startingLetters.add(v.name[0].toLowerCase());
      }
    });

    const primaryKey = adjPrimary.toLowerCase();
    const primaryLetter = adjPrimary[0]?.toLowerCase();
    const altLetter = adjAlt[0]?.toLowerCase();

    // Check if we need to avoid duplicate display names
    const primaryConflict = used.includes(primaryKey) || used.includes(noun.toLowerCase());

    // If player has Alliteration talent, prefer variant that matches other starting letters
    const hasAlliteration = S?.talents?.includes('alliteration');
    if (hasAlliteration && !primaryConflict) {
      const primaryMatches = startingLetters.has(primaryLetter);
      const altMatches = startingLetters.has(altLetter);
      // Prefer the variant that creates alliteration
      if (altMatches && !primaryMatches) {
        return adjAlt;
      }
      // If both or neither match, prefer primary (default behavior)
      return adjPrimary;
    }

    if (primaryConflict) {
      return adjAlt;
    }
    return adjPrimary;
  }
  // Default: use noun form in neutral contexts (inventory listing, etc.)
  return noun;
}


const STICK={id:"stick",name:"Stick",type:"weapon",category:"blunt",rarity:T.T0,ap:1,isStick:true,desc:"A humble twig. 0.5√ó total damage. Get a real weapon!"};

// === TALENTS ===
// Duplicate talent definition removed.  The primary TALENTS list is declared earlier in the file.

// === HELPER FUNCTIONS ===
function getTierRank(word){
  if(!word) return 0;
  const rank = word.rarity;
  return rank !== undefined ? rank : 0;
}

function findNextTierWord(word){
  if(!word) return null;
  const targetRank = getTierRank(word);
  const candidates = WORDS
    .filter(w => {
      if(w.type !== word.type) return false;
      if(word.type === 'weapon') return w.category === word.category;
      if(word.elem !== undefined) return w.elem === word.elem;
      return w.elem === undefined;
    })
    .sort((a,b) => {
      const ra = getTierRank(a);
      const rb = getTierRank(b);
      if(ra !== rb) return ra - rb;
      return WORDS.indexOf(a) - WORDS.indexOf(b);
    });
  return candidates.find(w => getTierRank(w) > targetRank) || null;
}

function applyWordUpgrade(target,template){
  if(!target || !template) return;
  const upgraded = {...template};
  Object.keys(target).forEach(k => delete target[k]);
  Object.assign(target, upgraded);
}

// Convert a rarity into a base AP value.  Tier¬†1 words grant 1 AP, Tier¬†2 words grant 2 AP,
// and Tier¬†3 words grant 3 AP.  Ranks are determined via the RRANK array (0=T1, 2=T2, 3=T3).
// Convert a tier into a base AP value.  T0=0 AP, T1=1 AP, T2=2 AP, T3=3 AP.
function rarityToAP(tier){
  return tier ?? 0;
}

// Format a modifier value as a styled badge span
// type: 'ap' for +AP, 'mult' for +mult, 'scale' for √ómult
function fmtMod(value, type = 'ap', suffix = '') {
  if (value === 0 || (type === 'scale' && value === 1)) return '';
  const isNeg = type === 'scale' ? value < 1 : value < 0;
  let cls, prefix;
  if (isNeg) {
    cls = 'neg';
    prefix = type === 'scale' ? '√ó' : '';
  } else if (type === 'ap') {
    cls = 'add';
    prefix = '+';
  } else if (type === 'word') {
    cls = 'word';
    prefix = '+';
  } else if (type === 'mult') {
    cls = 'mult';
    prefix = '+';
  } else {
    cls = 'scale';
    prefix = '√ó';
  }
  // Round to 2 decimal places, then remove trailing zeros
  const rounded = Math.round(value * 100) / 100;
  const v = Number.isInteger(rounded) ? rounded : parseFloat(rounded.toFixed(2));
  return `<span class="mod-badge ${cls}">${prefix}${v}${suffix}</span>`;
}

// Format talent description text, converting modifier patterns to badges
// e.g. "+0.5 AP" -> [+0.5 AP] green badge, "√ó2" -> [√ó2] pink badge, "+1.5 W" -> [+1.5 W] blue badge
// "√ó4 AP" -> [√ó4 AP] green badge (AP multiplier, not final damage)
// "√ó3 W" -> [√ó3 W] blue badge (word count multiplier)
// "REREAD √óN" -> orange reread badge
function fmtTalentDesc(desc) {
  if (!desc) return '';
  // Element name to color mapping
  const elemColors = {
    'Physical': '#a0a0a0', 'Poison': '#7ee04d', 'Fire': '#ff6633', 'Water': '#4d99ff',
    'Light': '#ffffa0', 'Dark': '#9966cc', 'Earth': '#996633', 'Lightning': '#ffff4d'
  };

  // If description already contains mod-badge HTML, preserve it and only process non-HTML parts
  if (desc.includes('class="mod-badge')) {
    // Handle "√óN" after closing </span> tag (merge it into the badge)
    desc = desc.replace(/<\/span>\s*√ó(\d+)/g, ' √ó$1</span>');
    // Color element names (but not inside HTML tags)
    desc = desc.replace(/\b(Physical|Poison|Fire|Water|Light|Dark|Earth|Lightning)\b(?![^<]*>)/g, (m) => `<span style="color:${elemColors[m]}">${m}</span>`);
    return desc;
  }

  return desc
    // Match REREAD √óN (retrigger) - must come before generic √óN match
    .replace(/REREAD\s*√ó(\d+)/g, (_, n) => `<span class="mod-badge reread">REREAD √ó${n}</span>`)
    // Match standalone REREAD (no number)
    .replace(/\bREREAD\b(?!\s*√ó)/g, '<span class="mod-badge reread">REREAD</span>')
    // Match √óN AP (AP multiplier) - green badge
    .replace(/√ó(\d+\.?\d*)\s*AP/gi, (_, n) => `<span class="mod-badge add">√ó${n} AP</span>`)
    // Match √óN W (word count multiplier) - blue badge
    .replace(/√ó(\d+\.?\d*)\s*W\b/g, (_, n) => `<span class="mod-badge word">√ó${n} W</span>`)
    // Match √óN or √óN.N alone (final damage multiplier) - pink badge
    .replace(/√ó(\d+\.?\d*)/g, (_, n) => fmtMod(parseFloat(n), 'scale'))
    // Match +N AP or +N.N AP (flat AP) - include "AP" inside the badge
    .replace(/\+(\d+\.?\d*)\s*AP/gi, (_, n) => fmtMod(parseFloat(n), 'ap', ' AP'))
    // Match +N W or +N.N W (word count bonus) - include "W" inside the badge
    .replace(/\+(\d+\.?\d*)\s*W\b/g, (_, n) => fmtMod(parseFloat(n), 'word', ' W'))
    // Color element names
    .replace(/\b(Physical|Poison|Fire|Water|Light|Dark|Earth|Lightning)\b/g, (m) => `<span style="color:${elemColors[m]}">${m}</span>`)
    // Capitalize Chapter, Round, Word
    .replace(/per chapter/gi, 'per Chapter')
    .replace(/per round/gi, 'per Round')
    .replace(/per word/gi, 'per Word');
}

// Normalize talent text into effect-first phrasing and clean scaling verbiage
function normalizeTalentText(desc){
  if(!desc) return '';

  // If description already contains HTML, skip normalization to preserve it
  if(desc.includes('<span') || desc.includes('class="')) {
    return desc;
  }

  let text = desc.replace(/\bReread\b/gi, 'REREAD');

  const colonIdx = text.indexOf(':');
  if(colonIdx !== -1){
    const condition = text.slice(0, colonIdx).trim();
    const effect = text.slice(colonIdx + 1).trim();
    if(effect.startsWith('+') || effect.startsWith('√ó')){
      const cleanedCondition = condition
        .replace(/^If\s+/i, '')
        .replace(/^If\s+weapon has\s+/i, '')
        .replace(/^weapon has\s+/i, '')
        .trim();
      text = `${effect} on ${cleanedCondition}`;
    }
  }

  // Remove redundant per-round wording; totals are shown elsewhere
  text = text.replace(/\s*per\s+Round/gi, '');

  // Flag chapter scaling succinctly
  let chapterScaled = false;
  text = text.replace(/\s*(?:based on|per)\s+Chapter/gi, () => { chapterScaled = true; return ''; });
  if(chapterScaled){
    text = `${text} (Chapter-scaled)`;
  }

  return text.replace(/\s+/g, ' ').trim();
}

function formatTalentDesc(talent, talentId = null){
  const desc = normalizeTalentText(talent?.desc || '');
  // Get talent level for scaling numbers in description
  const level = talentId ? getTalentLevel(talentId) : (talent?.id ? getTalentLevel(talent.id) : 1);

  if (level <= 1) {
    return fmtTalentDesc(desc);
  }

  // Scale numbers in the description by level
  // Handle both raw text (+N W) and HTML-wrapped text (<span...>+N W</span>)
  // Helper to scale a value and format nicely (preserve decimals for small values)
  const scaleValue = (n) => {
    const scaled = parseFloat(n) * level;
    // If result is less than 1 or has meaningful decimals, show 1 decimal place
    if (scaled < 1 || (scaled % 1 !== 0 && scaled < 10)) {
      return parseFloat(scaled.toFixed(1));
    }
    return Math.round(scaled);
  };

  let scaledDesc = desc
    // Scale +N W (word count bonuses) - handles both raw and inside HTML tags
    .replace(/\+(\d+\.?\d*)(\s*W)(?=\s|<|$)/g, (_, n, suffix) => `+${scaleValue(n)}${suffix}`)
    // Scale +N AP (flat AP bonuses) - handles both raw and inside HTML tags
    .replace(/\+(\d+\.?\d*)(\s*AP)(?=\s|<|$)/gi, (_, n, suffix) => `+${scaleValue(n)}${suffix}`)
    // Scale √óN (multipliers, but NOT REREAD √óN) - use additive scaling: base + (level-1) * 0.25 * bonus
    .replace(/(?<!REREAD\s*)√ó(\d+\.?\d*)/g, (_, n) => {
      const base = parseFloat(n);
      const bonusPortion = base - 1.0;
      const scaled = base + (level - 1) * (bonusPortion * 0.25);
      return `√ó${scaled.toFixed(2).replace(/\.?0+$/, '')}`;
    })
    // Scale REREAD √óN (explicit reread count) - additive scaling (+1 per level)
    .replace(/REREAD\s*√ó(\d+)/g, (_, n) => {
      const base = parseInt(n);
      const scaled = base + (level - 1);
      return `REREAD √ó${scaled}`;
    })
    // Scale standalone REREAD (implies √ó1) - show √óN at level 2+
    // Exclude REREAD after threshold pattern "N+ " (e.g., "6+ REREAD" should not scale)
    .replace(/(?<!\d+\+\s*)\bREREAD\b(?!\s*√ó)(?!\s*ALL)/g, () => {
      return level > 1 ? `REREAD √ó${level}` : 'REREAD';
    })
    // Scale REREAD ALL - show √óN at level 2+
    .replace(/REREAD\s*ALL(?!\s*√ó)/g, () => {
      return level > 1 ? `REREAD ALL √ó${level}` : 'REREAD ALL';
    });

  return fmtTalentDesc(scaledDesc);
}

/**
 * Format talent description showing upgrade preview (old value ‚Üí new value)
 * Used in the talent upgrade selection UI to show what will change
 */
function formatTalentDescUpgradePreview(talent, talentId = null){
  const desc = normalizeTalentText(talent?.desc || '');
  const currentLevel = talentId ? getTalentLevel(talentId) : (talent?.id ? getTalentLevel(talent.id) : 1);
  const nextLevel = currentLevel + 1;

  // Helper to scale a value linearly
  const scaleLinear = (n, lvl) => {
    const scaled = parseFloat(n) * lvl;
    if (scaled < 1 || (scaled % 1 !== 0 && scaled < 10)) {
      return parseFloat(scaled.toFixed(1));
    }
    return Math.round(scaled);
  };

  // Helper to scale a multiplier (25% of bonus per level)
  const scaleMult = (n, lvl) => {
    const base = parseFloat(n);
    const bonusPortion = base - 1.0;
    const scaled = base + (lvl - 1) * (bonusPortion * 0.25);
    return scaled.toFixed(2).replace(/\.?0+$/, '');
  };

  let previewDesc = desc
    // Scale +N W with old‚Üínew preview
    .replace(/\+(\d+\.?\d*)(\s*W)(?=\s|<|$)/g, (_, n, suffix) => {
      const oldVal = scaleLinear(n, currentLevel);
      const newVal = scaleLinear(n, nextLevel);
      return `<span class="upgrade-old">+${oldVal}</span><span class="upgrade-arrow">‚Üí</span><span class="upgrade-new">+${newVal}</span>${suffix}`;
    })
    // Scale +N AP with old‚Üínew preview
    .replace(/\+(\d+\.?\d*)(\s*AP)(?=\s|<|$)/gi, (_, n, suffix) => {
      const oldVal = scaleLinear(n, currentLevel);
      const newVal = scaleLinear(n, nextLevel);
      return `<span class="upgrade-old">+${oldVal}</span><span class="upgrade-arrow">‚Üí</span><span class="upgrade-new">+${newVal}</span>${suffix}`;
    })
    // Scale √óN with old‚Üínew preview (but NOT REREAD √óN)
    .replace(/(?<!REREAD\s*)√ó(\d+\.?\d*)/g, (_, n) => {
      const oldVal = scaleMult(n, currentLevel);
      const newVal = scaleMult(n, nextLevel);
      return `<span class="upgrade-old">√ó${oldVal}</span><span class="upgrade-arrow">‚Üí</span><span class="upgrade-new">√ó${newVal}</span>`;
    })
    // Scale REREAD √óN (explicit reread count) with old‚Üínew preview - additive (+1 per level)
    .replace(/REREAD\s*√ó(\d+)/g, (_, n) => {
      const base = parseInt(n);
      const oldVal = base + (currentLevel - 1);
      const newVal = base + (nextLevel - 1);
      return `REREAD <span class="upgrade-old">√ó${oldVal}</span><span class="upgrade-arrow">‚Üí</span><span class="upgrade-new">√ó${newVal}</span>`;
    })
    // Scale standalone REREAD with old‚Üínew preview
    // Exclude REREAD after threshold pattern "N+ " (e.g., "6+ REREAD" should not scale)
    .replace(/(?<!\d+\+\s*)\bREREAD\b(?!\s*√ó)(?!\s*ALL)/g, () => {
      const oldVal = currentLevel;
      const newVal = nextLevel;
      if (currentLevel === 1) {
        return `REREAD <span class="upgrade-arrow">‚Üí</span><span class="upgrade-new">√ó${newVal}</span>`;
      }
      return `REREAD <span class="upgrade-old">√ó${oldVal}</span><span class="upgrade-arrow">‚Üí</span><span class="upgrade-new">√ó${newVal}</span>`;
    })
    // Scale REREAD ALL with old‚Üínew preview
    .replace(/REREAD\s*ALL(?!\s*√ó)/g, () => {
      const oldVal = currentLevel;
      const newVal = nextLevel;
      if (currentLevel === 1) {
        return `REREAD ALL <span class="upgrade-arrow">‚Üí</span><span class="upgrade-new">√ó${newVal}</span>`;
      }
      return `REREAD ALL <span class="upgrade-old">√ó${oldVal}</span><span class="upgrade-arrow">‚Üí</span><span class="upgrade-new">√ó${newVal}</span>`;
    });

  return fmtTalentDesc(previewDesc);
}

// Determine the base AP for a given word.  If the word defines an explicit 'ap' property
// (e.g. gem nouns), use that value.  Otherwise, derive the AP from its rarity.
function getBaseAP(word){
  if(!word) return 0;
  if(word.ap !== undefined) return word.ap;
  return rarityToAP(word.rarity);
}

/**
 * Calculate the total AP for a single word, including base AP, chapter bonus, and all
 * applicable per-word talent bonuses. This is the single source of truth for word AP
 * that is used by both calc() and mkTooltip() to ensure consistency.
 *
 * @param {Object} word - The word object to calculate AP for
 * @param {Object} ctx - Context object with hero, enemy, allWords, weapon, state, etc.
 * @param {string} slotKey - The slot this word occupies ('item', 'adj1', 'noun1', etc.)
 * @returns {number} Total AP for this word including all bonuses
 */
function getWordAP(word, ctx, slotKey = null) {
  if (!word) return 0;

  // Start with base tier AP
  let ap = getBaseAP(word);

  // Apply skill tree bonuses based on slot type
  const skillBonuses = ctx.state.heroSkillBonuses || {};
  if (slotKey === 'item') {
    // Weapon slot gets weaponAP bonus
    ap += skillBonuses.weaponAP || 0;
  } else if (slotKey && slotKey.startsWith('adj')) {
    // Adjective slots get adjAP bonus
    ap += skillBonuses.adjAP || 0;
  } else if (slotKey && slotKey.startsWith('noun')) {
    // Noun slots get nounAP bonus
    ap += skillBonuses.nounAP || 0;
  }

  // Get chapter multiplier for talents that scale with chapters
  const chapterMultiplier = (ctx.state.currentChapter || 0) + 1;
  // Get round multiplier for per-round scaling (0.5 AP per round)
  const roundMultiplier = (ctx.state.roundIndex || 1) * 0.5;

  // Helper to check if a talent is active
  const hasTalent = (id) => ctx.state.talents && ctx.state.talents.includes(id);

  // Get word tier for tier-based talents
  const wordTier = word.rarity ?? 0;

  // === PER-WORD TALENT BONUSES ===
  // These values match the descriptions in TALENTS array and use round-based scaling
  // All talents scale with level via scaleTalentBonus()
  const round = ctx.state.roundIndex || 1;

  // Verbose: All Words +0.5 AP each per round
  if (hasTalent('verbose')) {
    ap += scaleTalentBonus('verbose', 0.5) * round;
  }

  // Tier-specific talents (per round scaling)
  if (hasTalent('eloquent') && wordTier >= 3) {
    // T3 Words +3 AP each per round
    ap += scaleTalentBonus('eloquent', 3) * round;
  }

  if (hasTalent('erudite') && wordTier === 2) {
    // T2 Words +2 AP each per round
    ap += scaleTalentBonus('erudite', 2) * round;
  }

  if (hasTalent('fundamental') && wordTier <= 1) {
    // T1 Words +1 AP each per round (includes T0)
    ap += scaleTalentBonus('fundamental', 1) * round;
  }

  // Type-specific talents
  if (hasTalent('adjectival_emphasis') && word.type === 'rarity') {
    // Adjective slots +3 AP each per round
    ap += scaleTalentBonus('adjectival_emphasis', 3) * round;
  }

  if (hasTalent('nominal_power') && (word.type === 'elemental' || word.type === 'weapon')) {
    // Nouns (Weapons + Gems) +2 AP each per round
    ap += scaleTalentBonus('nominal_power', 2) * round;
  }

  // Check if word has an element OR gains elements via Signature Style
  const hasElement = word.elem !== undefined;
  const hasSignatureStyleElement = hasTalent('signature_style') &&
    word.type === 'weapon' &&
    !word.isStick &&
    ctx.hero &&
    word.category === ctx.hero.good &&
    word.elem === undefined;
  const isElemental = hasElement || hasSignatureStyleElement;

  if (hasTalent('elemental_amplification') && isElemental) {
    // Elemental Words +0.5 AP each per round
    ap += scaleTalentBonus('elemental_amplification', 0.5) * round;
  }

  if (hasTalent('apotheosis') && isElemental) {
    // +5 AP per word with an element (flat, not per round)
    ap += scaleTalentBonus('apotheosis', 5);
  }

  if (hasTalent('bibliography')) {
    // +2 AP per word per boss defeated
    const bossesDefeated = ctx.state.bossesDefeated || 0;
    ap += scaleTalentBonus('bibliography', 2) * bossesDefeated;
  }

  if (hasTalent('spendthrift')) {
    // +0.02 AP per word per gold spent this run
    const goldSpent = ctx.state.goldSpent || 0;
    ap += goldSpent * scaleTalentBonus('spendthrift', 0.02);
  }

  if (hasTalent('gold_standard') && word.type === 'weapon') {
    // +0.1 AP to weapon per current gold held
    const gold = ctx.state.gold || 0;
    ap += gold * scaleTalentBonus('gold_standard', 0.1);
  }

  if (hasTalent('arsenal_mastery') && word.type === 'weapon') {
    // Weapon-type Words +4 AP each per round
    ap += scaleTalentBonus('arsenal_mastery', 4) * round;
  }

  // Family-based element talents: +1 AP per matching element word per round
  if (word.elem !== undefined) {
    // World & Sky Ink: Fire, Water, Earth, Lightning
    if (hasTalent('world_sky_ink') && isWorldSky(word.elem)) {
      ap += scaleTalentBonus('world_sky_ink', 1) * round;
    }
    // Body & Soul Ink: Physical, Poison, Light, Dark
    if (hasTalent('body_soul_ink') && isBodySoul(word.elem)) {
      ap += scaleTalentBonus('body_soul_ink', 1) * round;
    }
  }

  // Weapon damage type talents (Keen Edge, Piercing Point, etc.) are now global talents
  // They apply once via their apply() function, not per-word

  // Legendary Prose: +3 AP per Rarity Word per Round
  if (hasTalent('legendary_prose') && word.type === 'rarity') {
    ap += scaleTalentBonus('legendary_prose', 3) * round;
  }

  // Gemcutter (Scarab): +3 AP to Gem Word per Round
  if (hasTalent('gemcutter') && slotKey === 'noun1') {
    ap += scaleTalentBonus('gemcutter', 3) * round;
  }

  // Versatility: +3 AP to non-proficient Weapon Word per Round
  if (hasTalent('versatility') && slotKey === 'item' && word.type === 'weapon' && !word.isStick) {
    const hero = ctx.state.hero;
    if (hero && word.category !== hero.good) {
      ap += scaleTalentBonus('versatility', 3) * round;
    }
  }

  // Gemonomics: +1 AP to Gem Word per 10 Gold held
  if (hasTalent('gemonomics') && slotKey === 'noun1') {
    const gold = ctx.state.gold || 0;
    ap += Math.floor(gold / 10) * scaleTalentBonus('gemonomics', 1);
  }

  // Prolix: If using 4+ words, +0.5 AP per word per round
  if (hasTalent('prolix')) {
    const allWords = [ctx.state.sel?.adj1, ctx.state.sel?.adj2, ctx.state.sel?.item, ctx.state.sel?.adj3, ctx.state.sel?.adj4, ctx.state.sel?.noun1].filter(Boolean);
    const wordCount = allWords.filter(w => !w.isStick).length;
    if (wordCount >= 4) {
      ap += scaleTalentBonus('prolix', 0.5) * round;
    }
  }

  // === RUN-TRACKING TALENTS (converted to per-word) ===

  // Liquidation: +0.5 AP per Word per Word sold this run
  if (hasTalent('liquidation')) {
    const wordsSold = ctx.state.wordsSold || 0;
    ap += wordsSold * scaleTalentBonus('liquidation', 0.5);
  }

  // Quality Control: +0.1 AP per Word per Rarity Word played this run
  if (hasTalent('quality_control')) {
    const rarityUsed = ctx.state.rarityWordsUsed || 0;
    ap += rarityUsed * scaleTalentBonus('quality_control', 0.1);
  }

  // Grassroots: +0.05 AP per Word per T1 Word played this run
  if (hasTalent('grassroots')) {
    const t1Played = ctx.state.tierWordsPlayed?.[1] || 0;
    ap += t1Played * scaleTalentBonus('grassroots', 0.05);
  }

  // Intermediate: +0.1 AP per Word per T2 Word played this run
  if (hasTalent('intermediate')) {
    const t2Played = ctx.state.tierWordsPlayed?.[2] || 0;
    ap += t2Played * scaleTalentBonus('intermediate', 0.1);
  }

  // Masterwork: +0.2 AP per Word per T3 Word played this run
  if (hasTalent('masterwork')) {
    const t3Played = ctx.state.tierWordsPlayed?.[3] || 0;
    ap += t3Played * scaleTalentBonus('masterwork', 0.2);
  }

  // Tool Mastery: +1 AP per Word per Tool used this run
  if (hasTalent('tool_mastery')) {
    const toolsUsed = ctx.state.toolsUsed || 0;
    ap += toolsUsed * scaleTalentBonus('tool_mastery', 1);
  }

  // Crate Opener: +1.5 AP per Word per Crate opened this run
  if (hasTalent('crate_opener')) {
    const cratesOpened = ctx.state.cratesOpened || 0;
    ap += cratesOpened * scaleTalentBonus('crate_opener', 1.5);
  }

  // Momentum: +1 W per Word per Round completed (max 10)
  // NOTE: This is handled in getTalentBonusesForWord as a W bonus, not AP
  // Keeping this block for reference but it doesn't add to AP anymore

  // Investment: +0.5 AP per Word per Interest earned
  if (hasTalent('investment')) {
    const { totalInterest } = calculateInterest();
    ap += totalInterest * scaleTalentBonus('investment', 0.5);
  }

  return ap;
}

/**
 * Get a list of talent bonuses that apply to a specific word.
 * Returns an array of {name, value, type} objects for display in tooltips.
 * Type is 'AP', 'W', or 'x' for multipliers.
 */
function getTalentBonusesForWord(word) {
  if (!word || !S.talents || S.talents.length === 0) return [];

  const bonuses = [];
  const round = S.roundIndex || 1;
  const chapter = Math.floor((round - 1) / 9) + 1;
  const wordTier = word.rarity ?? 0;
  const hasTalent = (id) => S.talents.includes(id);

  // All talents scale with level via scaleTalentBonus()

  // Verbose: All Words +0.5 AP each per round
  if (hasTalent('verbose')) {
    bonuses.push({ name: 'Verbose', value: scaleTalentBonus('verbose', 0.5) * round, type: 'AP' });
  }

  // Prolix: If using 4+ words, +0.5 AP per word per round
  if (hasTalent('prolix')) {
    const allWords = [S.sel?.adj1, S.sel?.adj2, S.sel?.item, S.sel?.adj3, S.sel?.adj4, S.sel?.noun1].filter(Boolean);
    const wordCount = allWords.filter(w => !w.isStick).length;
    if (wordCount >= 4) {
      bonuses.push({ name: 'Prolix', value: scaleTalentBonus('prolix', 0.5) * round, type: 'AP' });
    }
  }

  // Tier-specific talents
  if (hasTalent('eloquent') && wordTier >= 3) {
    bonuses.push({ name: 'Eloquent', value: scaleTalentBonus('eloquent', 3) * round, type: 'AP' });
  }
  if (hasTalent('erudite') && wordTier === 2) {
    bonuses.push({ name: 'Erudite', value: scaleTalentBonus('erudite', 2) * round, type: 'AP' });
  }
  if (hasTalent('fundamental') && wordTier <= 1) {
    bonuses.push({ name: 'Fundamental', value: scaleTalentBonus('fundamental', 1) * round, type: 'AP' });
  }

  // Type-specific talents
  if (hasTalent('adjectival_emphasis') && word.type === 'rarity') {
    bonuses.push({ name: 'Adjectival Emphasis', value: scaleTalentBonus('adjectival_emphasis', 3) * round, type: 'AP' });
  }
  if (hasTalent('nominal_power') && (word.type === 'elemental' || word.type === 'weapon')) {
    bonuses.push({ name: 'Nominal Power', value: scaleTalentBonus('nominal_power', 2) * round, type: 'AP' });
  }
  // Check if word has an element OR gains elements via Signature Style
  const hasElement = word.elem !== undefined;
  const hasSignatureStyleElement = hasTalent('signature_style') &&
    word.type === 'weapon' &&
    !word.isStick &&
    S.hero &&
    word.category === S.hero.good &&
    word.elem === undefined;
  const isElemental = hasElement || hasSignatureStyleElement;

  if (hasTalent('elemental_amplification') && isElemental) {
    bonuses.push({ name: 'Elemental Amplification', value: scaleTalentBonus('elemental_amplification', 0.5) * round, type: 'AP' });
  }
  if (hasTalent('apotheosis') && isElemental) {
    bonuses.push({ name: 'Apotheosis', value: scaleTalentBonus('apotheosis', 5), type: 'AP' });
  }
  if (hasTalent('bibliography')) {
    const bossesDefeated = S.bossesDefeated || 0;
    if (bossesDefeated > 0) {
      bonuses.push({ name: 'Bibliography', value: scaleTalentBonus('bibliography', 2) * bossesDefeated, type: 'AP' });
    }
  }
  if (hasTalent('arsenal_mastery') && word.type === 'weapon') {
    bonuses.push({ name: 'Arsenal Mastery', value: scaleTalentBonus('arsenal_mastery', 4) * round, type: 'AP' });
  }

  // Family-based element talents
  if (word.elem !== undefined) {
    if (hasTalent('world_sky_ink') && isWorldSky(word.elem)) {
      bonuses.push({ name: 'World & Sky Ink', value: scaleTalentBonus('world_sky_ink', 1) * round, type: 'AP' });
    }
    if (hasTalent('body_soul_ink') && isBodySoul(word.elem)) {
      bonuses.push({ name: 'Body & Soul Ink', value: scaleTalentBonus('body_soul_ink', 1) * round, type: 'AP' });
    }
  }

  // Weapon damage type AP talents (Keen Edge, etc.) are global - shown in combat breakdown, not per-word

  // Legendary Prose: +3 AP per Rarity Word per Round
  if (hasTalent('legendary_prose') && word.type === 'rarity') {
    bonuses.push({ name: 'Legendary Prose', value: scaleTalentBonus('legendary_prose', 3) * round, type: 'AP' });
  }

  // Gem slot talents - check if this word is in the gem slot
  const isGemSlotWord = S.sel && S.sel.noun1 === word;
  if (isGemSlotWord) {
    // Gemcutter (Scarab): +3 AP to Gem Word per Round
    if (hasTalent('gemcutter')) {
      bonuses.push({ name: 'Scarab', value: scaleTalentBonus('gemcutter', 3) * round, type: 'AP' });
    }
    // Gemonomics: +1 AP to Gem Word per 10 Gold held
    if (hasTalent('gemonomics')) {
      const gold = S.gold || 0;
      const gemonomicsBonus = Math.floor(gold / 10) * scaleTalentBonus('gemonomics', 1);
      if (gemonomicsBonus > 0) {
        bonuses.push({ name: 'Gemonomics', value: gemonomicsBonus, type: 'AP' });
      }
    }
  }

  // Weapon slot talents - check if this word is in the weapon slot
  const isWeaponSlotWord = S.sel && S.sel.item === word && word.type === 'weapon' && !word.isStick;
  if (isWeaponSlotWord) {
    // Versatility: +3 AP to non-proficient Weapon Word per Round
    if (hasTalent('versatility') && S.hero && word.category !== S.hero.good) {
      bonuses.push({ name: 'Versatility', value: scaleTalentBonus('versatility', 3) * round, type: 'AP' });
    }
  }

  // Proficiency Focus: +6 W for proficient weapon type (uses chapter scaling + talent level)
  if (word.type === 'weapon' && !word.isStick && word.category) {
    const chapterW = chapterScaleW(scaleTalentBonus('proficiency_focus', 6), chapter);
    if (hasTalent('proficiency_focus') && S.hero && word.category === S.hero.good) {
      bonuses.push({ name: 'Proficiency Focus', value: chapterW, type: 'W' });
    }
  }

  // Family-based W talents (+5 W base, scales with level)
  if (word.elem !== undefined) {
    if (hasTalent('world_sky_focus') && isWorldSky(word.elem)) {
      const elemW = scaleTalentBonus('world_sky_focus', 5);
      bonuses.push({ name: 'World & Sky Focus', value: elemW, type: 'W' });
    }
    if (hasTalent('body_soul_focus') && isBodySoul(word.elem)) {
      const elemW = scaleTalentBonus('body_soul_focus', 5);
      bonuses.push({ name: 'Body & Soul Focus', value: elemW, type: 'W' });
    }
  }

  // === RUN-TRACKING TALENTS (per-word display) ===

  // Liquidation: +0.5 AP per Word per Word sold this run
  if (hasTalent('liquidation')) {
    const wordsSold = S.wordsSold || 0;
    const liquidationBonus = wordsSold * scaleTalentBonus('liquidation', 0.5);
    if (liquidationBonus > 0) {
      bonuses.push({ name: 'Liquidation', value: liquidationBonus, type: 'AP' });
    }
  }

  // Quality Control: +0.1 AP per Word per Rarity Word played this run
  if (hasTalent('quality_control')) {
    const rarityUsed = S.rarityWordsUsed || 0;
    const qualityBonus = rarityUsed * scaleTalentBonus('quality_control', 0.1);
    if (qualityBonus > 0) {
      bonuses.push({ name: 'Quality Control', value: qualityBonus, type: 'AP' });
    }
  }

  // Grassroots: +0.05 AP per Word per T1 Word played this run
  if (hasTalent('grassroots')) {
    const t1Played = S.tierWordsPlayed?.[1] || 0;
    const grassrootsBonus = t1Played * scaleTalentBonus('grassroots', 0.05);
    if (grassrootsBonus > 0) {
      bonuses.push({ name: 'Grassroots', value: grassrootsBonus, type: 'AP' });
    }
  }

  // Intermediate: +0.1 AP per Word per T2 Word played this run
  if (hasTalent('intermediate')) {
    const t2Played = S.tierWordsPlayed?.[2] || 0;
    const intermediateBonus = t2Played * scaleTalentBonus('intermediate', 0.1);
    if (intermediateBonus > 0) {
      bonuses.push({ name: 'Intermediate', value: intermediateBonus, type: 'AP' });
    }
  }

  // Masterwork: +0.2 AP per Word per T3 Word played this run
  if (hasTalent('masterwork')) {
    const t3Played = S.tierWordsPlayed?.[3] || 0;
    const masterworkBonus = t3Played * scaleTalentBonus('masterwork', 0.2);
    if (masterworkBonus > 0) {
      bonuses.push({ name: 'Masterwork', value: masterworkBonus, type: 'AP' });
    }
  }

  // Tool Mastery: +1 AP per Word per Tool used this run
  if (hasTalent('tool_mastery')) {
    const toolsUsed = S.toolsUsed || 0;
    const toolMasteryBonus = toolsUsed * scaleTalentBonus('tool_mastery', 1);
    if (toolMasteryBonus > 0) {
      bonuses.push({ name: 'Tool Mastery', value: toolMasteryBonus, type: 'AP' });
    }
  }

  // Crate Opener: +1.5 AP per Word per Crate opened this run
  if (hasTalent('crate_opener')) {
    const cratesOpened = S.cratesOpened || 0;
    const crateOpenerBonus = cratesOpened * scaleTalentBonus('crate_opener', 1.5);
    if (crateOpenerBonus > 0) {
      bonuses.push({ name: 'Crate Opener', value: crateOpenerBonus, type: 'AP' });
    }
  }

  // Momentum: +1 W per Word per Round completed (max 10), scales with level
  if (hasTalent('momentum')) {
    const roundsCompleted = Math.min((S.roundIndex || 1) - 1, 10);
    const momentumBonus = roundsCompleted * scaleTalentBonus('momentum', 1);
    if (momentumBonus > 0) {
      bonuses.push({ name: 'Momentum', value: momentumBonus, type: 'W' });
    }
  }

  // Investment: +0.5 AP per Word per Interest earned
  if (hasTalent('investment')) {
    const { totalInterest } = calculateInterest();
    const investmentBonus = totalInterest * scaleTalentBonus('investment', 0.5);
    if (investmentBonus > 0) {
      bonuses.push({ name: 'Investment', value: investmentBonus, type: 'AP' });
    }
  }

  return bonuses;
}

// === WEAPON SVG (Portrait-Style: Soft Gradients, No Bold Lines) ===
// Each weapon has: base (weapon shape), gem (noun1 slot), adj1-4 effects
// Style matches portraits: layered shapes, gradient fills, soft edges, no outlines

const WEAPON_SVG={
  // SLASH CATEGORY - Elegant bladed weapons with flowing gradients
  sword:{base:`<defs>
    <linearGradient id="sw-blade" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="BASECOLOR"/><stop offset="50%" stop-color="BASECOLOR" stop-opacity="0.9"/><stop offset="100%" stop-color="#1f2937"/></linearGradient>
    <linearGradient id="sw-hilt" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#8b7355"/><stop offset="100%" stop-color="#4a3728"/></linearGradient>
    <linearGradient id="sw-guard" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#c9a227"/><stop offset="100%" stop-color="#8b6914"/></linearGradient>
  </defs>
  <g id="sword-root">
    <path d="M50 8 L56 16 L56 88 L50 92 L44 88 L44 16 Z" fill="url(#sw-blade)"/>
    <path d="M51 12 L54 18 L54 84 L51 87 L48 84 L48 18 Z" fill="#ffffff" opacity="0.25"/>
    <path d="M50 20 L52 24 L52 78 L50 80 L48 78 L48 24 Z" fill="#0f172a" opacity="0.15"/>
    <path d="M34 88 L66 88 L62 94 L38 94 Z" fill="url(#sw-guard)"/>
    <path d="M36 89 L64 89 L61 92 L39 92 Z" fill="#ffffff" opacity="0.2"/>
    <rect x="45" y="94" width="10" height="24" rx="2" fill="url(#sw-hilt)"/>
    <path d="M46 98 L54 98 M46 104 L54 104 M46 110 L54 110" stroke="#5c4a3a" stroke-width="1.5" opacity="0.6"/>
    <ellipse cx="50" cy="122" rx="6" ry="5" fill="url(#sw-guard)"/>
  </g>`,
  gem:`<g id="sword-gem">
    <ellipse cx="50" cy="91" rx="6" ry="5" fill="GEMCOLOR"/>
    <ellipse cx="50" cy="90" rx="4" ry="3" fill="#ffffff" opacity="0.4"/>
    <ellipse cx="50" cy="91" rx="6" ry="5" fill="GEMCOLOR" opacity="0.5"/>
  </g>`,
  adj1:`<g id="sw-adj1">
    <defs><linearGradient id="sw-adj1-grad" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="ADJ1COLOR" stop-opacity="0.9"/><stop offset="100%" stop-color="ADJ1COLOR" stop-opacity="0"/></linearGradient></defs>
    <path d="M44 16 L44 88 L50 92 L50 8 Z" fill="url(#sw-adj1-grad)" opacity="0.6"/>
    <path d="M44 20 L44 85" stroke="ADJ1COLOR" stroke-width="2" opacity="0.8" stroke-linecap="round"/>
    <path d="M42 25 L42 75" stroke="#ffffff" stroke-width="1" opacity="0.4"/>
  </g>`,
  adj2:`<g id="sw-adj2">
    <defs><linearGradient id="sw-adj2-grad" x1="100%" y1="100%" x2="0%" y2="0%"><stop offset="0%" stop-color="ADJ2COLOR" stop-opacity="0.7"/><stop offset="100%" stop-color="ADJ2COLOR" stop-opacity="0"/></linearGradient></defs>
    <path d="M56 16 L56 88 L50 92 L50 8 Z" fill="url(#sw-adj2-grad)" opacity="0.5"/>
    <path d="M58 25 L58 75" stroke="ADJ2COLOR" stroke-width="2" opacity="0.4" stroke-linecap="round"/>
  </g>`,
  adj3:`<g id="sw-adj3">
    <defs><linearGradient id="sw-adj3-grad" x1="50%" y1="0%" x2="50%" y2="100%"><stop offset="0%" stop-color="ADJ3COLOR" stop-opacity="0.8"/><stop offset="50%" stop-color="ADJ3COLOR" stop-opacity="0.3"/><stop offset="100%" stop-color="ADJ3COLOR" stop-opacity="0.6"/></linearGradient></defs>
    <path d="M50 15 L52 20 L52 80 L50 85 L48 80 L48 20 Z" fill="url(#sw-adj3-grad)" opacity="0.5"/>
    <line x1="50" y1="20" x2="50" y2="75" stroke="ADJ3COLOR" stroke-width="1.5" opacity="0.7"/>
    <circle cx="50" cy="45" r="4" fill="ADJ3COLOR" opacity="0.3"/><circle cx="50" cy="45" r="2" fill="#ffffff" opacity="0.5"/>
  </g>`,
  adj4:`<g id="sw-adj4">
    <defs>
      <radialGradient id="sw-adj4-aura" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="ADJ4COLOR" stop-opacity="0.3"/><stop offset="70%" stop-color="ADJ4COLOR" stop-opacity="0.1"/><stop offset="100%" stop-color="ADJ4COLOR" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="50" rx="28" ry="45" fill="url(#sw-adj4-aura)"/>
    <ellipse cx="50" cy="50" rx="22" ry="38" fill="none" stroke="ADJ4COLOR" stroke-width="1.5" opacity="0.25"/>
    <ellipse cx="50" cy="50" rx="32" ry="52" fill="none" stroke="ADJ4COLOR" stroke-width="1" opacity="0.15"/>
  </g>`},

  greatsword:{base:`<defs>
    <linearGradient id="gs-blade" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="BASECOLOR"/><stop offset="60%" stop-color="BASECOLOR" stop-opacity="0.85"/><stop offset="100%" stop-color="#1f2937"/></linearGradient>
    <linearGradient id="gs-hilt" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#7a6548"/><stop offset="100%" stop-color="#3d3222"/></linearGradient>
    <linearGradient id="gs-guard" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#d4af37"/><stop offset="100%" stop-color="#9a7b1a"/></linearGradient>
  </defs>
  <g id="greatsword-root">
    <path d="M50 4 L58 14 L58 84 L50 90 L42 84 L42 14 Z" fill="url(#gs-blade)"/>
    <path d="M51 10 L56 16 L56 80 L51 85 L46 80 L46 16 Z" fill="#ffffff" opacity="0.2"/>
    <path d="M50 18 L53 22 L53 74 L50 77 L47 74 L47 22 Z" fill="#0f172a" opacity="0.12"/>
    <rect x="30" y="84" width="40" height="8" rx="2" fill="url(#gs-guard)"/>
    <path d="M32 85 L68 85 L66 90 L34 90 Z" fill="#ffffff" opacity="0.2"/>
    <rect x="44" y="92" width="12" height="26" rx="2" fill="url(#gs-hilt)"/>
    <path d="M45 96 L55 96 M45 103 L55 103 M45 110 L55 110" stroke="#4a3d2a" stroke-width="1.8" opacity="0.5"/>
    <ellipse cx="50" cy="122" rx="7" ry="6" fill="url(#gs-guard)"/>
  </g>`,
  gem:`<g id="gs-gem">
    <ellipse cx="50" cy="88" rx="7" ry="5.5" fill="GEMCOLOR"/>
    <ellipse cx="50" cy="87" rx="5" ry="3.5" fill="#ffffff" opacity="0.35"/>
  </g>`,
  adj1:`<g id="gs-adj1">
    <defs><linearGradient id="gs-adj1-grad" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="ADJ1COLOR" stop-opacity="0.9"/><stop offset="100%" stop-color="ADJ1COLOR" stop-opacity="0"/></linearGradient></defs>
    <path d="M42 14 L42 84 L50 90 L50 4 Z" fill="url(#gs-adj1-grad)" opacity="0.55"/>
    <path d="M42 18 L42 80" stroke="ADJ1COLOR" stroke-width="2.5" opacity="0.75" stroke-linecap="round"/>
    <path d="M40 24 L40 72" stroke="#ffffff" stroke-width="1" opacity="0.35"/>
  </g>`,
  adj2:`<g id="gs-adj2">
    <defs><linearGradient id="gs-adj2-grad" x1="100%" y1="100%" x2="0%" y2="0%"><stop offset="0%" stop-color="ADJ2COLOR" stop-opacity="0.65"/><stop offset="100%" stop-color="ADJ2COLOR" stop-opacity="0"/></linearGradient></defs>
    <path d="M58 14 L58 84 L50 90 L50 4 Z" fill="url(#gs-adj2-grad)" opacity="0.45"/>
    <path d="M60 24 L60 72" stroke="ADJ2COLOR" stroke-width="2" opacity="0.4" stroke-linecap="round"/>
  </g>`,
  adj3:`<g id="gs-adj3">
    <defs><linearGradient id="gs-adj3-grad" x1="50%" y1="0%" x2="50%" y2="100%"><stop offset="0%" stop-color="ADJ3COLOR" stop-opacity="0.75"/><stop offset="50%" stop-color="ADJ3COLOR" stop-opacity="0.25"/><stop offset="100%" stop-color="ADJ3COLOR" stop-opacity="0.55"/></linearGradient></defs>
    <path d="M50 10 L54 16 L54 78 L50 84 L46 78 L46 16 Z" fill="url(#gs-adj3-grad)" opacity="0.45"/>
    <line x1="50" y1="18" x2="50" y2="72" stroke="ADJ3COLOR" stroke-width="2" opacity="0.65"/>
    <circle cx="50" cy="45" r="5" fill="ADJ3COLOR" opacity="0.25"/><circle cx="50" cy="45" r="2.5" fill="#ffffff" opacity="0.45"/>
  </g>`,
  adj4:`<g id="gs-adj4">
    <defs><radialGradient id="gs-adj4-aura" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="ADJ4COLOR" stop-opacity="0.28"/><stop offset="70%" stop-color="ADJ4COLOR" stop-opacity="0.1"/><stop offset="100%" stop-color="ADJ4COLOR" stop-opacity="0"/></radialGradient></defs>
    <ellipse cx="50" cy="48" rx="32" ry="48" fill="url(#gs-adj4-aura)"/>
    <ellipse cx="50" cy="48" rx="26" ry="42" fill="none" stroke="ADJ4COLOR" stroke-width="1.5" opacity="0.22"/>
    <ellipse cx="50" cy="48" rx="38" ry="56" fill="none" stroke="ADJ4COLOR" stroke-width="1" opacity="0.12"/>
  </g>`},

  claymore:{base:`<defs>
    <linearGradient id="cl-blade" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="BASECOLOR"/><stop offset="55%" stop-color="BASECOLOR" stop-opacity="0.8"/><stop offset="100%" stop-color="#1f2937"/></linearGradient>
    <linearGradient id="cl-hilt" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#6b5840"/><stop offset="100%" stop-color="#2f261c"/></linearGradient>
    <linearGradient id="cl-guard" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#e6c547"/><stop offset="100%" stop-color="#a8891f"/></linearGradient>
  </defs>
  <g id="claymore-root">
    <path d="M50 2 L60 14 L60 82 L50 90 L40 82 L40 14 Z" fill="url(#cl-blade)"/>
    <path d="M51 8 L58 16 L58 78 L51 84 L44 78 L44 16 Z" fill="#ffffff" opacity="0.18"/>
    <path d="M50 16 L54 20 L54 72 L50 76 L46 72 L46 20 Z" fill="#0f172a" opacity="0.1"/>
    <rect x="26" y="82" width="48" height="10" rx="3" fill="url(#cl-guard)"/>
    <path d="M28 83 L72 83 L70 90 L30 90 Z" fill="#ffffff" opacity="0.2"/>
    <rect x="42" y="92" width="16" height="28" rx="3" fill="url(#cl-hilt)"/>
    <path d="M44 97 L56 97 M44 105 L56 105 M44 113 L56 113" stroke="#3f3426" stroke-width="2" opacity="0.5"/>
    <rect x="44" y="122" width="12" height="8" rx="2" fill="url(#cl-guard)"/>
  </g>`,
  gem:`<g id="cl-gem">
    <ellipse cx="50" cy="87" rx="8" ry="6" fill="GEMCOLOR"/>
    <ellipse cx="50" cy="86" rx="5.5" ry="4" fill="#ffffff" opacity="0.3"/>
    <ellipse cx="50" cy="100" rx="5" ry="4" fill="GEMCOLOR" opacity="0.7"/>
  </g>`,
  adj1:`<g id="cl-adj1">
    <defs><linearGradient id="cl-adj1-grad" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="ADJ1COLOR" stop-opacity="0.85"/><stop offset="100%" stop-color="ADJ1COLOR" stop-opacity="0"/></linearGradient></defs>
    <path d="M40 14 L40 82 L50 90 L50 2 Z" fill="url(#cl-adj1-grad)" opacity="0.5"/>
    <path d="M40 18 L40 78" stroke="ADJ1COLOR" stroke-width="3" opacity="0.7" stroke-linecap="round"/>
    <path d="M38 24 L38 70" stroke="#ffffff" stroke-width="1.2" opacity="0.3"/>
  </g>`,
  adj2:`<g id="cl-adj2">
    <defs><linearGradient id="cl-adj2-grad" x1="100%" y1="100%" x2="0%" y2="0%"><stop offset="0%" stop-color="ADJ2COLOR" stop-opacity="0.6"/><stop offset="100%" stop-color="ADJ2COLOR" stop-opacity="0"/></linearGradient></defs>
    <path d="M60 14 L60 82 L50 90 L50 2 Z" fill="url(#cl-adj2-grad)" opacity="0.4"/>
    <path d="M62 24 L62 70" stroke="ADJ2COLOR" stroke-width="2.5" opacity="0.35" stroke-linecap="round"/>
  </g>`,
  adj3:`<g id="cl-adj3">
    <defs><linearGradient id="cl-adj3-grad" x1="50%" y1="0%" x2="50%" y2="100%"><stop offset="0%" stop-color="ADJ3COLOR" stop-opacity="0.7"/><stop offset="50%" stop-color="ADJ3COLOR" stop-opacity="0.2"/><stop offset="100%" stop-color="ADJ3COLOR" stop-opacity="0.5"/></linearGradient></defs>
    <path d="M50 8 L55 16 L55 76 L50 84 L45 76 L45 16 Z" fill="url(#cl-adj3-grad)" opacity="0.4"/>
    <line x1="50" y1="16" x2="50" y2="70" stroke="ADJ3COLOR" stroke-width="2" opacity="0.6"/>
    <circle cx="50" cy="44" r="6" fill="ADJ3COLOR" opacity="0.2"/><circle cx="50" cy="44" r="3" fill="#ffffff" opacity="0.4"/>
  </g>`,
  adj4:`<g id="cl-adj4">
    <defs><radialGradient id="cl-adj4-aura" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="ADJ4COLOR" stop-opacity="0.25"/><stop offset="70%" stop-color="ADJ4COLOR" stop-opacity="0.08"/><stop offset="100%" stop-color="ADJ4COLOR" stop-opacity="0"/></radialGradient></defs>
    <ellipse cx="50" cy="46" rx="36" ry="52" fill="url(#cl-adj4-aura)"/>
    <ellipse cx="50" cy="46" rx="30" ry="46" fill="none" stroke="ADJ4COLOR" stroke-width="2" opacity="0.2"/>
    <ellipse cx="50" cy="46" rx="42" ry="60" fill="none" stroke="ADJ4COLOR" stroke-width="1" opacity="0.1"/>
  </g>`},

  // PIERCE CATEGORY - Curved bows with organic wood grain feel
  bow:{base:`<defs>
    <linearGradient id="bw-limb" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="BASECOLOR"/><stop offset="100%" stop-color="#2d1810"/></linearGradient>
    <linearGradient id="bw-string" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#d4af37"/><stop offset="50%" stop-color="#c9a227"/><stop offset="100%" stop-color="#d4af37"/></linearGradient>
  </defs>
  <g id="bow-root">
    <path d="M50 12 Q28 65 50 118 Q72 65 50 12" fill="none" stroke="url(#bw-limb)" stroke-width="7" stroke-linecap="round"/>
    <path d="M52 18 Q34 65 52 112" fill="none" stroke="#ffffff" stroke-width="2.5" opacity="0.25" stroke-linecap="round"/>
    <line x1="50" y1="18" x2="50" y2="112" stroke="url(#bw-string)" stroke-width="1.8"/>
    <ellipse cx="50" cy="18" rx="4" ry="3" fill="#c9a227"/>
    <ellipse cx="50" cy="112" rx="4" ry="3" fill="#c9a227"/>
    <ellipse cx="50" cy="65" rx="6" ry="8" fill="url(#bw-limb)"/>
    <ellipse cx="50" cy="65" rx="4" ry="5" fill="#ffffff" opacity="0.15"/>
  </g>`,
  gem:`<g id="bow-gem">
    <ellipse cx="50" cy="65" rx="7" ry="6" fill="GEMCOLOR"/>
    <ellipse cx="50" cy="64" rx="4.5" ry="3.5" fill="#ffffff" opacity="0.35"/>
  </g>`,
  adj1:`<g id="bw-adj1">
    <defs><linearGradient id="bw-adj1-grad" x1="0%" y1="50%" x2="100%" y2="50%"><stop offset="0%" stop-color="ADJ1COLOR" stop-opacity="0.8"/><stop offset="100%" stop-color="ADJ1COLOR" stop-opacity="0"/></linearGradient></defs>
    <path d="M50 15 Q30 65 50 115" fill="none" stroke="url(#bw-adj1-grad)" stroke-width="12" opacity="0.4"/>
    <path d="M48 20 Q32 65 48 110" fill="none" stroke="ADJ1COLOR" stroke-width="2" opacity="0.7" stroke-linecap="round"/>
    <path d="M46 25 Q34 65 46 105" fill="none" stroke="#ffffff" stroke-width="1" opacity="0.3"/>
  </g>`,
  adj2:`<g id="bw-adj2">
    <defs><linearGradient id="bw-adj2-grad" x1="100%" y1="50%" x2="0%" y2="50%"><stop offset="0%" stop-color="ADJ2COLOR" stop-opacity="0.6"/><stop offset="100%" stop-color="ADJ2COLOR" stop-opacity="0"/></linearGradient></defs>
    <path d="M50 15 Q70 65 50 115" fill="none" stroke="url(#bw-adj2-grad)" stroke-width="10" opacity="0.35"/>
    <path d="M54 25 Q66 65 54 105" fill="none" stroke="ADJ2COLOR" stroke-width="1.5" opacity="0.5"/>
  </g>`,
  adj3:`<g id="bw-adj3">
    <defs><radialGradient id="bw-adj3-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="ADJ3COLOR" stop-opacity="0.7"/><stop offset="100%" stop-color="ADJ3COLOR" stop-opacity="0.1"/></radialGradient></defs>
    <ellipse cx="50" cy="65" rx="10" ry="12" fill="url(#bw-adj3-glow)" opacity="0.6"/>
    <ellipse cx="50" cy="65" rx="5" ry="6" fill="ADJ3COLOR" opacity="0.4"/>
    <ellipse cx="50" cy="64" rx="2.5" ry="3" fill="#ffffff" opacity="0.5"/>
  </g>`,
  adj4:`<g id="bw-adj4">
    <defs><radialGradient id="bw-adj4-aura" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="ADJ4COLOR" stop-opacity="0.25"/><stop offset="60%" stop-color="ADJ4COLOR" stop-opacity="0.1"/><stop offset="100%" stop-color="ADJ4COLOR" stop-opacity="0"/></radialGradient></defs>
    <ellipse cx="50" cy="65" rx="35" ry="50" fill="url(#bw-adj4-aura)"/>
    <ellipse cx="50" cy="65" rx="28" ry="42" fill="none" stroke="ADJ4COLOR" stroke-width="1.5" opacity="0.2"/>
    <ellipse cx="50" cy="65" rx="40" ry="55" fill="none" stroke="ADJ4COLOR" stroke-width="1" opacity="0.1"/>
  </g>`},

  longbow:{base:`<defs>
    <linearGradient id="lb-limb" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="BASECOLOR"/><stop offset="100%" stop-color="#1f1208"/></linearGradient>
    <linearGradient id="lb-string" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#d4af37"/><stop offset="50%" stop-color="#c9a227"/><stop offset="100%" stop-color="#d4af37"/></linearGradient>
  </defs>
  <g id="longbow-root">
    <path d="M50 8 Q22 65 50 122 Q78 65 50 8" fill="none" stroke="url(#lb-limb)" stroke-width="8" stroke-linecap="round"/>
    <path d="M52 14 Q30 65 52 116" fill="none" stroke="#ffffff" stroke-width="2.8" opacity="0.22" stroke-linecap="round"/>
    <line x1="50" y1="14" x2="50" y2="116" stroke="url(#lb-string)" stroke-width="2"/>
    <ellipse cx="50" cy="14" rx="4.5" ry="3.5" fill="#c9a227"/>
    <ellipse cx="50" cy="116" rx="4.5" ry="3.5" fill="#c9a227"/>
    <rect x="44" y="60" width="12" height="12" rx="3" fill="url(#lb-limb)"/>
    <rect x="46" y="62" width="8" height="8" rx="2" fill="#ffffff" opacity="0.12"/>
  </g>`,
  gem:`<g id="lb-gem">
    <ellipse cx="50" cy="66" rx="8" ry="7" fill="GEMCOLOR"/>
    <ellipse cx="50" cy="65" rx="5" ry="4" fill="#ffffff" opacity="0.3"/>
  </g>`,
  adj1:`<g id="lb-adj1">
    <defs><linearGradient id="lb-adj1-grad" x1="0%" y1="50%" x2="100%" y2="50%"><stop offset="0%" stop-color="ADJ1COLOR" stop-opacity="0.8"/><stop offset="100%" stop-color="ADJ1COLOR" stop-opacity="0"/></linearGradient></defs>
    <path d="M50 10 Q26 65 50 120" fill="none" stroke="url(#lb-adj1-grad)" stroke-width="14" opacity="0.35"/>
    <path d="M47 16 Q28 65 47 114" fill="none" stroke="ADJ1COLOR" stroke-width="2" opacity="0.65" stroke-linecap="round"/>
    <path d="M45 22 Q32 65 45 108" fill="none" stroke="#ffffff" stroke-width="1" opacity="0.25"/>
  </g>`,
  adj2:`<g id="lb-adj2">
    <defs><linearGradient id="lb-adj2-grad" x1="100%" y1="50%" x2="0%" y2="50%"><stop offset="0%" stop-color="ADJ2COLOR" stop-opacity="0.55"/><stop offset="100%" stop-color="ADJ2COLOR" stop-opacity="0"/></linearGradient></defs>
    <path d="M50 10 Q74 65 50 120" fill="none" stroke="url(#lb-adj2-grad)" stroke-width="12" opacity="0.3"/>
    <path d="M55 22 Q68 65 55 108" fill="none" stroke="ADJ2COLOR" stroke-width="1.5" opacity="0.45"/>
  </g>`,
  adj3:`<g id="lb-adj3">
    <defs><radialGradient id="lb-adj3-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="ADJ3COLOR" stop-opacity="0.7"/><stop offset="100%" stop-color="ADJ3COLOR" stop-opacity="0.1"/></radialGradient></defs>
    <ellipse cx="50" cy="66" rx="12" ry="14" fill="url(#lb-adj3-glow)" opacity="0.55"/>
    <ellipse cx="50" cy="66" rx="6" ry="7" fill="ADJ3COLOR" opacity="0.35"/>
    <ellipse cx="50" cy="65" rx="3" ry="3.5" fill="#ffffff" opacity="0.45"/>
  </g>`,
  adj4:`<g id="lb-adj4">
    <defs><radialGradient id="lb-adj4-aura" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="ADJ4COLOR" stop-opacity="0.22"/><stop offset="60%" stop-color="ADJ4COLOR" stop-opacity="0.08"/><stop offset="100%" stop-color="ADJ4COLOR" stop-opacity="0"/></radialGradient></defs>
    <ellipse cx="50" cy="65" rx="38" ry="54" fill="url(#lb-adj4-aura)"/>
    <ellipse cx="50" cy="65" rx="32" ry="48" fill="none" stroke="ADJ4COLOR" stroke-width="1.5" opacity="0.18"/>
    <ellipse cx="50" cy="65" rx="44" ry="60" fill="none" stroke="ADJ4COLOR" stroke-width="1" opacity="0.1"/>
  </g>`},

  warbow:{base:`<defs>
    <linearGradient id="wb-limb" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="BASECOLOR"/><stop offset="100%" stop-color="#150a04"/></linearGradient>
    <linearGradient id="wb-string" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#e6c547"/><stop offset="50%" stop-color="#d4af37"/><stop offset="100%" stop-color="#e6c547"/></linearGradient>
    <linearGradient id="wb-metal" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#c9a227"/><stop offset="100%" stop-color="#8b6914"/></linearGradient>
  </defs>
  <g id="warbow-root">
    <path d="M50 5 Q16 65 50 125 Q84 65 50 5" fill="none" stroke="url(#wb-limb)" stroke-width="9" stroke-linecap="round"/>
    <path d="M52 12 Q26 65 52 118" fill="none" stroke="#ffffff" stroke-width="3" opacity="0.2" stroke-linecap="round"/>
    <line x1="50" y1="11" x2="50" y2="119" stroke="url(#wb-string)" stroke-width="2.5"/>
    <path d="M46 11 L50 5 L54 11 Z" fill="url(#wb-metal)"/>
    <path d="M46 119 L50 125 L54 119 Z" fill="url(#wb-metal)"/>
    <rect x="42" y="58" width="16" height="14" rx="3" fill="url(#wb-limb)"/>
    <rect x="47" y="58" width="6" height="14" fill="url(#wb-metal)" opacity="0.6"/>
  </g>`,
  gem:`<g id="wb-gem">
    <ellipse cx="50" cy="65" rx="9" ry="8" fill="GEMCOLOR"/>
    <ellipse cx="50" cy="64" rx="6" ry="5" fill="#ffffff" opacity="0.3"/>
    <ellipse cx="50" cy="50" rx="5" ry="4" fill="GEMCOLOR" opacity="0.6"/>
    <ellipse cx="50" cy="80" rx="5" ry="4" fill="GEMCOLOR" opacity="0.6"/>
  </g>`,
  adj1:`<g id="wb-adj1">
    <defs><linearGradient id="wb-adj1-grad" x1="0%" y1="50%" x2="100%" y2="50%"><stop offset="0%" stop-color="ADJ1COLOR" stop-opacity="0.75"/><stop offset="100%" stop-color="ADJ1COLOR" stop-opacity="0"/></linearGradient></defs>
    <path d="M50 8 Q20 65 50 122" fill="none" stroke="url(#wb-adj1-grad)" stroke-width="16" opacity="0.35"/>
    <path d="M46 14 Q24 65 46 116" fill="none" stroke="ADJ1COLOR" stroke-width="2.5" opacity="0.6" stroke-linecap="round"/>
    <path d="M44 20 Q28 65 44 110" fill="none" stroke="#ffffff" stroke-width="1.2" opacity="0.25"/>
  </g>`,
  adj2:`<g id="wb-adj2">
    <defs><linearGradient id="wb-adj2-grad" x1="100%" y1="50%" x2="0%" y2="50%"><stop offset="0%" stop-color="ADJ2COLOR" stop-opacity="0.55"/><stop offset="100%" stop-color="ADJ2COLOR" stop-opacity="0"/></linearGradient></defs>
    <path d="M50 8 Q80 65 50 122" fill="none" stroke="url(#wb-adj2-grad)" stroke-width="14" opacity="0.3"/>
    <path d="M56 20 Q72 65 56 110" fill="none" stroke="ADJ2COLOR" stroke-width="2" opacity="0.4"/>
  </g>`,
  adj3:`<g id="wb-adj3">
    <defs><radialGradient id="wb-adj3-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="ADJ3COLOR" stop-opacity="0.7"/><stop offset="100%" stop-color="ADJ3COLOR" stop-opacity="0.1"/></radialGradient></defs>
    <ellipse cx="50" cy="65" rx="14" ry="16" fill="url(#wb-adj3-glow)" opacity="0.5"/>
    <ellipse cx="50" cy="65" rx="7" ry="8" fill="ADJ3COLOR" opacity="0.35"/>
    <ellipse cx="50" cy="64" rx="3.5" ry="4" fill="#ffffff" opacity="0.45"/>
  </g>`,
  adj4:`<g id="wb-adj4">
    <defs><radialGradient id="wb-adj4-aura" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="ADJ4COLOR" stop-opacity="0.22"/><stop offset="60%" stop-color="ADJ4COLOR" stop-opacity="0.08"/><stop offset="100%" stop-color="ADJ4COLOR" stop-opacity="0"/></radialGradient></defs>
    <ellipse cx="50" cy="65" rx="42" ry="58" fill="url(#wb-adj4-aura)"/>
    <ellipse cx="50" cy="65" rx="36" ry="52" fill="none" stroke="ADJ4COLOR" stroke-width="2" opacity="0.18"/>
    <ellipse cx="50" cy="65" rx="48" ry="64" fill="none" stroke="ADJ4COLOR" stroke-width="1" opacity="0.1"/>
  </g>`},

  // MAGIC CATEGORY - Mystical implements with ethereal glow
  wand:{base:`<defs>
    <linearGradient id="wn-shaft" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#5c4a3a"/><stop offset="100%" stop-color="#2a1f16"/></linearGradient>
    <radialGradient id="wn-orb" cx="50%" cy="40%" r="50%"><stop offset="0%" stop-color="BASECOLOR"/><stop offset="70%" stop-color="BASECOLOR" stop-opacity="0.8"/><stop offset="100%" stop-color="#1f1033"/></radialGradient>
  </defs>
  <g id="wand-root">
    <rect x="47" y="58" width="6" height="64" rx="2" fill="url(#wn-shaft)"/>
    <rect x="48" y="60" width="3" height="60" fill="#ffffff" opacity="0.1"/>
    <circle cx="50" cy="28" r="22" fill="url(#wn-orb)"/>
    <circle cx="50" cy="24" r="14" fill="#ffffff" opacity="0.25"/>
    <path d="M50 28 A14 14 0 0 1 60 38" fill="none" stroke="#0f172a" stroke-width="2" opacity="0.15"/>
    <path d="M47 88 L53 88 M47 96 L53 96 M47 104 L53 104" stroke="#8b7355" stroke-width="1.8" opacity="0.5"/>
  </g>`,
  gem:`<g id="wand-gem">
    <circle cx="50" cy="28" rx="8" fill="GEMCOLOR"/>
    <circle cx="50" cy="26" rx="5" fill="#ffffff" opacity="0.4"/>
  </g>`,
  adj1:`<g id="wn-adj1">
    <defs><linearGradient id="wn-adj1-grad" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="ADJ1COLOR" stop-opacity="0.8"/><stop offset="100%" stop-color="ADJ1COLOR" stop-opacity="0"/></linearGradient></defs>
    <circle cx="50" cy="28" r="24" fill="url(#wn-adj1-grad)" opacity="0.45"/>
    <path d="M32 28 A18 18 0 0 1 50 10" stroke="ADJ1COLOR" stroke-width="3" fill="none" opacity="0.65" stroke-linecap="round"/>
    <path d="M30 26 A20 20 0 0 1 48 8" stroke="#ffffff" stroke-width="1.5" fill="none" opacity="0.3"/>
  </g>`,
  adj2:`<g id="wn-adj2">
    <defs><linearGradient id="wn-adj2-grad" x1="100%" y1="100%" x2="0%" y2="0%"><stop offset="0%" stop-color="ADJ2COLOR" stop-opacity="0.55"/><stop offset="100%" stop-color="ADJ2COLOR" stop-opacity="0"/></linearGradient></defs>
    <circle cx="50" cy="28" r="22" fill="url(#wn-adj2-grad)" opacity="0.35"/>
    <path d="M68 28 A18 18 0 0 1 50 46" stroke="ADJ2COLOR" stroke-width="2" fill="none" opacity="0.45"/>
  </g>`,
  adj3:`<g id="wn-adj3">
    <defs><radialGradient id="wn-adj3-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="ADJ3COLOR" stop-opacity="0.8"/><stop offset="100%" stop-color="ADJ3COLOR" stop-opacity="0.1"/></radialGradient></defs>
    <circle cx="50" cy="28" r="14" fill="url(#wn-adj3-glow)" opacity="0.5"/>
    <circle cx="50" cy="28" r="6" fill="ADJ3COLOR" opacity="0.4"/>
    <circle cx="50" cy="26" r="3" fill="#ffffff" opacity="0.5"/>
  </g>`,
  adj4:`<g id="wn-adj4">
    <defs><radialGradient id="wn-adj4-aura" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="ADJ4COLOR" stop-opacity="0.3"/><stop offset="60%" stop-color="ADJ4COLOR" stop-opacity="0.1"/><stop offset="100%" stop-color="ADJ4COLOR" stop-opacity="0"/></radialGradient></defs>
    <circle cx="50" cy="28" r="32" fill="url(#wn-adj4-aura)"/>
    <circle cx="50" cy="28" r="26" fill="none" stroke="ADJ4COLOR" stroke-width="1.5" opacity="0.22"/>
    <circle cx="50" cy="28" r="38" fill="none" stroke="ADJ4COLOR" stroke-width="1" opacity="0.12"/>
  </g>`},

  staff:{base:`<defs>
    <linearGradient id="st-shaft" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#5c4a3a"/><stop offset="100%" stop-color="#1f160e"/></linearGradient>
    <radialGradient id="st-orb" cx="50%" cy="40%" r="50%"><stop offset="0%" stop-color="BASECOLOR"/><stop offset="65%" stop-color="BASECOLOR" stop-opacity="0.75"/><stop offset="100%" stop-color="#150a20"/></radialGradient>
    <linearGradient id="st-cap" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#8B4513"/><stop offset="100%" stop-color="#4a2409"/></linearGradient>
  </defs>
  <g id="staff-root">
    <rect x="45" y="42" width="10" height="80" rx="3" fill="url(#st-shaft)"/>
    <rect x="47" y="44" width="4" height="76" fill="#ffffff" opacity="0.08"/>
    <circle cx="50" cy="22" r="26" fill="url(#st-orb)"/>
    <circle cx="50" cy="18" r="16" fill="#ffffff" opacity="0.22"/>
    <path d="M50 22 A16 16 0 0 1 62 34" fill="none" stroke="#0f172a" stroke-width="2.5" opacity="0.12"/>
    <path d="M38 118 L50 113 L62 118 L50 126 Z" fill="url(#st-cap)"/>
  </g>`,
  gem:`<g id="staff-gem">
    <circle cx="50" cy="22" r="10" fill="GEMCOLOR"/>
    <circle cx="50" cy="20" r="6" fill="#ffffff" opacity="0.35"/>
    <circle cx="50" cy="10" r="5" fill="GEMCOLOR" opacity="0.6"/>
  </g>`,
  adj1:`<g id="st-adj1">
    <defs><linearGradient id="st-adj1-grad" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="ADJ1COLOR" stop-opacity="0.75"/><stop offset="100%" stop-color="ADJ1COLOR" stop-opacity="0"/></linearGradient></defs>
    <circle cx="50" cy="22" r="28" fill="url(#st-adj1-grad)" opacity="0.4"/>
    <path d="M28 22 A22 22 0 0 1 50 0" stroke="ADJ1COLOR" stroke-width="3.5" fill="none" opacity="0.6" stroke-linecap="round"/>
    <path d="M26 20 A24 24 0 0 1 48 -2" stroke="#ffffff" stroke-width="1.5" fill="none" opacity="0.25"/>
  </g>`,
  adj2:`<g id="st-adj2">
    <defs><linearGradient id="st-adj2-grad" x1="100%" y1="100%" x2="0%" y2="0%"><stop offset="0%" stop-color="ADJ2COLOR" stop-opacity="0.5"/><stop offset="100%" stop-color="ADJ2COLOR" stop-opacity="0"/></linearGradient></defs>
    <circle cx="50" cy="22" r="26" fill="url(#st-adj2-grad)" opacity="0.3"/>
    <path d="M72 22 A22 22 0 0 1 50 44" stroke="ADJ2COLOR" stroke-width="2.5" fill="none" opacity="0.4"/>
  </g>`,
  adj3:`<g id="st-adj3">
    <defs><radialGradient id="st-adj3-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="ADJ3COLOR" stop-opacity="0.75"/><stop offset="100%" stop-color="ADJ3COLOR" stop-opacity="0.1"/></radialGradient></defs>
    <circle cx="50" cy="22" r="18" fill="url(#st-adj3-glow)" opacity="0.5"/>
    <circle cx="50" cy="22" r="8" fill="ADJ3COLOR" opacity="0.35"/>
    <circle cx="50" cy="20" r="4" fill="#ffffff" opacity="0.45"/>
  </g>`,
  adj4:`<g id="st-adj4">
    <defs><radialGradient id="st-adj4-aura" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="ADJ4COLOR" stop-opacity="0.28"/><stop offset="60%" stop-color="ADJ4COLOR" stop-opacity="0.1"/><stop offset="100%" stop-color="ADJ4COLOR" stop-opacity="0"/></radialGradient></defs>
    <circle cx="50" cy="22" r="38" fill="url(#st-adj4-aura)"/>
    <circle cx="50" cy="22" r="32" fill="none" stroke="ADJ4COLOR" stroke-width="2" opacity="0.2"/>
    <circle cx="50" cy="22" r="44" fill="none" stroke="ADJ4COLOR" stroke-width="1" opacity="0.1"/>
  </g>`},

  scepter:{base:`<defs>
    <linearGradient id="sc-shaft" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#c9a227"/><stop offset="50%" stop-color="#a8891f"/><stop offset="100%" stop-color="#5c4a1a"/></linearGradient>
    <radialGradient id="sc-orb" cx="50%" cy="35%" r="50%"><stop offset="0%" stop-color="BASECOLOR"/><stop offset="60%" stop-color="BASECOLOR" stop-opacity="0.7"/><stop offset="100%" stop-color="#0f0520"/></radialGradient>
    <linearGradient id="sc-crown" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#e6c547"/><stop offset="100%" stop-color="#a8891f"/></linearGradient>
  </defs>
  <g id="scepter-root">
    <rect x="44" y="50" width="12" height="72" rx="3" fill="url(#sc-shaft)"/>
    <rect x="46" y="52" width="5" height="68" fill="#ffffff" opacity="0.15"/>
    <circle cx="50" cy="22" r="28" fill="url(#sc-orb)"/>
    <circle cx="50" cy="17" r="18" fill="#ffffff" opacity="0.2"/>
    <path d="M50 22 A18 18 0 0 1 64 36" fill="none" stroke="#0f172a" stroke-width="3" opacity="0.1"/>
    <path d="M36 44 L50 36 L64 44 L50 50 Z" fill="url(#sc-crown)"/>
    <path d="M38 45 L50 38 L62 45" fill="#ffffff" opacity="0.2"/>
  </g>`,
  gem:`<g id="scepter-gem">
    <circle cx="50" cy="22" r="12" fill="GEMCOLOR"/>
    <circle cx="50" cy="19" r="7" fill="#ffffff" opacity="0.35"/>
    <circle cx="50" cy="6" r="6" fill="GEMCOLOR" opacity="0.5"/>
    <circle cx="36" cy="28" r="4" fill="GEMCOLOR" opacity="0.4"/>
    <circle cx="64" cy="28" r="4" fill="GEMCOLOR" opacity="0.4"/>
  </g>`,
  adj1:`<g id="sc-adj1">
    <defs><linearGradient id="sc-adj1-grad" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="ADJ1COLOR" stop-opacity="0.75"/><stop offset="100%" stop-color="ADJ1COLOR" stop-opacity="0"/></linearGradient></defs>
    <circle cx="50" cy="22" r="30" fill="url(#sc-adj1-grad)" opacity="0.4"/>
    <path d="M26 22 A24 24 0 0 1 50 -2" stroke="ADJ1COLOR" stroke-width="4" fill="none" opacity="0.55" stroke-linecap="round"/>
    <path d="M24 20 A26 26 0 0 1 48 -4" stroke="#ffffff" stroke-width="1.5" fill="none" opacity="0.25"/>
  </g>`,
  adj2:`<g id="sc-adj2">
    <defs><linearGradient id="sc-adj2-grad" x1="100%" y1="100%" x2="0%" y2="0%"><stop offset="0%" stop-color="ADJ2COLOR" stop-opacity="0.5"/><stop offset="100%" stop-color="ADJ2COLOR" stop-opacity="0"/></linearGradient></defs>
    <circle cx="50" cy="22" r="28" fill="url(#sc-adj2-grad)" opacity="0.3"/>
    <path d="M74 22 A24 24 0 0 1 50 46" stroke="ADJ2COLOR" stroke-width="3" fill="none" opacity="0.35"/>
  </g>`,
  adj3:`<g id="sc-adj3">
    <defs><radialGradient id="sc-adj3-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="ADJ3COLOR" stop-opacity="0.75"/><stop offset="100%" stop-color="ADJ3COLOR" stop-opacity="0.1"/></radialGradient></defs>
    <circle cx="50" cy="22" r="20" fill="url(#sc-adj3-glow)" opacity="0.45"/>
    <circle cx="50" cy="22" r="10" fill="ADJ3COLOR" opacity="0.3"/>
    <circle cx="50" cy="20" r="5" fill="#ffffff" opacity="0.45"/>
  </g>`,
  adj4:`<g id="sc-adj4">
    <defs><radialGradient id="sc-adj4-aura" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="ADJ4COLOR" stop-opacity="0.25"/><stop offset="60%" stop-color="ADJ4COLOR" stop-opacity="0.08"/><stop offset="100%" stop-color="ADJ4COLOR" stop-opacity="0"/></radialGradient></defs>
    <circle cx="50" cy="22" r="42" fill="url(#sc-adj4-aura)"/>
    <circle cx="50" cy="22" r="36" fill="none" stroke="ADJ4COLOR" stroke-width="2" opacity="0.18"/>
    <circle cx="50" cy="22" r="50" fill="none" stroke="ADJ4COLOR" stroke-width="1.5" opacity="0.1"/>
  </g>`},

  // BLUNT CATEGORY - Heavy, solid weapons with weight
  mace:{base:`<defs>
    <linearGradient id="mc-head" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="BASECOLOR"/><stop offset="100%" stop-color="#2a2a35"/></linearGradient>
    <linearGradient id="mc-haft" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#5c4a3a"/><stop offset="100%" stop-color="#2a1f16"/></linearGradient>
    <linearGradient id="mc-band" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#c9a227"/><stop offset="100%" stop-color="#8b6914"/></linearGradient>
  </defs>
  <g id="mace-root">
    <rect x="46" y="50" width="8" height="70" rx="2" fill="url(#mc-haft)"/>
    <rect x="47" y="52" width="4" height="66" fill="#ffffff" opacity="0.1"/>
    <ellipse cx="50" cy="28" rx="22" ry="24" fill="url(#mc-head)"/>
    <ellipse cx="50" cy="24" rx="14" ry="15" fill="#ffffff" opacity="0.2"/>
    <path d="M50 28 A14 14 0 0 1 60 38" fill="none" stroke="#0f172a" stroke-width="2" opacity="0.15"/>
    <rect x="42" y="46" width="16" height="6" rx="2" fill="url(#mc-band)"/>
    <path d="M46 90 L54 90 M46 98 L54 98 M46 106 L54 106" stroke="#8b7355" stroke-width="1.6" opacity="0.5"/>
    <ellipse cx="50" cy="118" rx="6" ry="5" fill="url(#mc-band)"/>
  </g>`,
  gem:`<g id="mace-gem">
    <ellipse cx="50" cy="28" rx="8" ry="9" fill="GEMCOLOR"/>
    <ellipse cx="50" cy="26" rx="5" ry="5" fill="#ffffff" opacity="0.35"/>
  </g>`,
  adj1:`<g id="mc-adj1">
    <defs><linearGradient id="mc-adj1-grad" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="ADJ1COLOR" stop-opacity="0.8"/><stop offset="100%" stop-color="ADJ1COLOR" stop-opacity="0"/></linearGradient></defs>
    <ellipse cx="50" cy="28" rx="24" ry="26" fill="url(#mc-adj1-grad)" opacity="0.45"/>
    <path d="M30 28 A20 20 0 0 1 50 8" stroke="ADJ1COLOR" stroke-width="3" fill="none" opacity="0.65" stroke-linecap="round"/>
    <path d="M28 26 A22 22 0 0 1 48 6" stroke="#ffffff" stroke-width="1.2" fill="none" opacity="0.3"/>
  </g>`,
  adj2:`<g id="mc-adj2">
    <defs><linearGradient id="mc-adj2-grad" x1="100%" y1="100%" x2="0%" y2="0%"><stop offset="0%" stop-color="ADJ2COLOR" stop-opacity="0.55"/><stop offset="100%" stop-color="ADJ2COLOR" stop-opacity="0"/></linearGradient></defs>
    <ellipse cx="50" cy="28" rx="22" ry="24" fill="url(#mc-adj2-grad)" opacity="0.35"/>
    <path d="M70 28 A20 20 0 0 1 50 48" stroke="ADJ2COLOR" stroke-width="2" fill="none" opacity="0.4"/>
  </g>`,
  adj3:`<g id="mc-adj3">
    <defs><radialGradient id="mc-adj3-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="ADJ3COLOR" stop-opacity="0.75"/><stop offset="100%" stop-color="ADJ3COLOR" stop-opacity="0.1"/></radialGradient></defs>
    <ellipse cx="50" cy="28" rx="14" ry="15" fill="url(#mc-adj3-glow)" opacity="0.5"/>
    <ellipse cx="50" cy="28" rx="6" ry="7" fill="ADJ3COLOR" opacity="0.35"/>
    <ellipse cx="50" cy="26" rx="3" ry="3.5" fill="#ffffff" opacity="0.45"/>
  </g>`,
  adj4:`<g id="mc-adj4">
    <defs><radialGradient id="mc-adj4-aura" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="ADJ4COLOR" stop-opacity="0.28"/><stop offset="60%" stop-color="ADJ4COLOR" stop-opacity="0.1"/><stop offset="100%" stop-color="ADJ4COLOR" stop-opacity="0"/></radialGradient></defs>
    <ellipse cx="50" cy="28" rx="32" ry="34" fill="url(#mc-adj4-aura)"/>
    <ellipse cx="50" cy="28" rx="26" ry="28" fill="none" stroke="ADJ4COLOR" stroke-width="1.5" opacity="0.22"/>
    <ellipse cx="50" cy="28" rx="36" ry="40" fill="none" stroke="ADJ4COLOR" stroke-width="1" opacity="0.12"/>
  </g>`},

  warhammer:{base:`<defs>
    <linearGradient id="wh-head" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="BASECOLOR"/><stop offset="100%" stop-color="#1a1a25"/></linearGradient>
    <linearGradient id="wh-haft" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#5c4a3a"/><stop offset="100%" stop-color="#1f160e"/></linearGradient>
    <linearGradient id="wh-band" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#d4af37"/><stop offset="100%" stop-color="#9a7b1a"/></linearGradient>
  </defs>
  <g id="warhammer-root">
    <rect x="45" y="46" width="10" height="76" rx="3" fill="url(#wh-haft)"/>
    <rect x="46" y="48" width="5" height="72" fill="#ffffff" opacity="0.08"/>
    <rect x="26" y="16" width="48" height="32" rx="4" fill="url(#wh-head)"/>
    <rect x="30" y="20" width="28" height="18" fill="#ffffff" opacity="0.18"/>
    <path d="M28 18 L72 18 L70 44 L30 44 Z" fill="#0f172a" opacity="0.08"/>
    <rect x="40" y="44" width="20" height="8" rx="2" fill="url(#wh-band)"/>
    <path d="M45 88 L55 88 M45 98 L55 98 M45 108 L55 108" stroke="#8b7355" stroke-width="1.8" opacity="0.5"/>
    <ellipse cx="50" cy="120" rx="7" ry="6" fill="url(#wh-band)"/>
  </g>`,
  gem:`<g id="wh-gem">
    <ellipse cx="50" cy="32" rx="9" ry="8" fill="GEMCOLOR"/>
    <ellipse cx="50" cy="30" rx="6" ry="5" fill="#ffffff" opacity="0.3"/>
  </g>`,
  adj1:`<g id="wh-adj1">
    <defs><linearGradient id="wh-adj1-grad" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="ADJ1COLOR" stop-opacity="0.8"/><stop offset="100%" stop-color="ADJ1COLOR" stop-opacity="0"/></linearGradient></defs>
    <rect x="24" y="14" width="52" height="34" rx="4" fill="url(#wh-adj1-grad)" opacity="0.4"/>
    <path d="M28 32 L28 18 L72 18" stroke="ADJ1COLOR" stroke-width="3" fill="none" opacity="0.6" stroke-linecap="round"/>
    <path d="M26 30 L26 16 L70 16" stroke="#ffffff" stroke-width="1.2" fill="none" opacity="0.25"/>
  </g>`,
  adj2:`<g id="wh-adj2">
    <defs><linearGradient id="wh-adj2-grad" x1="100%" y1="100%" x2="0%" y2="0%"><stop offset="0%" stop-color="ADJ2COLOR" stop-opacity="0.55"/><stop offset="100%" stop-color="ADJ2COLOR" stop-opacity="0"/></linearGradient></defs>
    <rect x="28" y="18" width="44" height="28" rx="3" fill="url(#wh-adj2-grad)" opacity="0.35"/>
    <path d="M72 32 L72 46 L28 46" stroke="ADJ2COLOR" stroke-width="2" fill="none" opacity="0.4"/>
  </g>`,
  adj3:`<g id="wh-adj3">
    <defs><radialGradient id="wh-adj3-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="ADJ3COLOR" stop-opacity="0.75"/><stop offset="100%" stop-color="ADJ3COLOR" stop-opacity="0.1"/></radialGradient></defs>
    <ellipse cx="50" cy="32" rx="16" ry="12" fill="url(#wh-adj3-glow)" opacity="0.5"/>
    <ellipse cx="50" cy="32" rx="7" ry="5" fill="ADJ3COLOR" opacity="0.35"/>
    <ellipse cx="50" cy="30" rx="3.5" ry="2.5" fill="#ffffff" opacity="0.45"/>
  </g>`,
  adj4:`<g id="wh-adj4">
    <defs><radialGradient id="wh-adj4-aura" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="ADJ4COLOR" stop-opacity="0.25"/><stop offset="60%" stop-color="ADJ4COLOR" stop-opacity="0.08"/><stop offset="100%" stop-color="ADJ4COLOR" stop-opacity="0"/></radialGradient></defs>
    <rect x="14" y="6" width="72" height="48" rx="8" fill="url(#wh-adj4-aura)"/>
    <rect x="18" y="10" width="64" height="40" rx="6" fill="none" stroke="ADJ4COLOR" stroke-width="1.5" opacity="0.2"/>
    <rect x="10" y="2" width="80" height="56" rx="10" fill="none" stroke="ADJ4COLOR" stroke-width="1" opacity="0.1"/>
  </g>`},

  maul:{base:`<defs>
    <linearGradient id="ml-head" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="BASECOLOR"/><stop offset="100%" stop-color="#101018"/></linearGradient>
    <linearGradient id="ml-haft" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#4a3d30"/><stop offset="100%" stop-color="#1a130c"/></linearGradient>
    <linearGradient id="ml-band" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#e6c547"/><stop offset="100%" stop-color="#a8891f"/></linearGradient>
  </defs>
  <g id="maul-root">
    <rect x="44" y="44" width="12" height="80" rx="3" fill="url(#ml-haft)"/>
    <rect x="46" y="46" width="6" height="76" fill="#ffffff" opacity="0.07"/>
    <rect x="22" y="12" width="56" height="36" rx="5" fill="url(#ml-head)"/>
    <rect x="26" y="16" width="34" height="22" fill="#ffffff" opacity="0.15"/>
    <path d="M24 14 L76 14 L74 44 L26 44 Z" fill="#0f172a" opacity="0.06"/>
    <rect x="38" y="44" width="24" height="10" rx="3" fill="url(#ml-band)"/>
    <path d="M44 92 L56 92 M44 104 L56 104 M44 116 L56 116" stroke="#6b5840" stroke-width="2" opacity="0.5"/>
    <rect x="44" y="120" width="12" height="8" rx="2" fill="url(#ml-band)"/>
  </g>`,
  gem:`<g id="maul-gem">
    <ellipse cx="50" cy="30" rx="11" ry="10" fill="GEMCOLOR"/>
    <ellipse cx="50" cy="28" rx="7" ry="6" fill="#ffffff" opacity="0.28"/>
    <ellipse cx="36" cy="30" rx="5" ry="4" fill="GEMCOLOR" opacity="0.5"/>
    <ellipse cx="64" cy="30" rx="5" ry="4" fill="GEMCOLOR" opacity="0.5"/>
  </g>`,
  adj1:`<g id="ml-adj1">
    <defs><linearGradient id="ml-adj1-grad" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="ADJ1COLOR" stop-opacity="0.75"/><stop offset="100%" stop-color="ADJ1COLOR" stop-opacity="0"/></linearGradient></defs>
    <rect x="20" y="10" width="60" height="40" rx="6" fill="url(#ml-adj1-grad)" opacity="0.4"/>
    <path d="M24 32 L24 14 L76 14" stroke="ADJ1COLOR" stroke-width="3.5" fill="none" opacity="0.55" stroke-linecap="round"/>
    <path d="M22 30 L22 12 L74 12" stroke="#ffffff" stroke-width="1.5" fill="none" opacity="0.25"/>
  </g>`,
  adj2:`<g id="ml-adj2">
    <defs><linearGradient id="ml-adj2-grad" x1="100%" y1="100%" x2="0%" y2="0%"><stop offset="0%" stop-color="ADJ2COLOR" stop-opacity="0.5"/><stop offset="100%" stop-color="ADJ2COLOR" stop-opacity="0"/></linearGradient></defs>
    <rect x="24" y="14" width="52" height="32" rx="5" fill="url(#ml-adj2-grad)" opacity="0.35"/>
    <path d="M76 28 L76 46 L24 46" stroke="ADJ2COLOR" stroke-width="2.5" fill="none" opacity="0.35"/>
  </g>`,
  adj3:`<g id="ml-adj3">
    <defs><radialGradient id="ml-adj3-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="ADJ3COLOR" stop-opacity="0.7"/><stop offset="100%" stop-color="ADJ3COLOR" stop-opacity="0.1"/></radialGradient></defs>
    <ellipse cx="50" cy="30" rx="18" ry="14" fill="url(#ml-adj3-glow)" opacity="0.5"/>
    <ellipse cx="50" cy="30" rx="9" ry="7" fill="ADJ3COLOR" opacity="0.3"/>
    <ellipse cx="50" cy="28" rx="4.5" ry="3.5" fill="#ffffff" opacity="0.4"/>
  </g>`,
  adj4:`<g id="ml-adj4">
    <defs><radialGradient id="ml-adj4-aura" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="ADJ4COLOR" stop-opacity="0.22"/><stop offset="60%" stop-color="ADJ4COLOR" stop-opacity="0.08"/><stop offset="100%" stop-color="ADJ4COLOR" stop-opacity="0"/></radialGradient></defs>
    <rect x="10" y="2" width="80" height="56" rx="10" fill="url(#ml-adj4-aura)"/>
    <rect x="14" y="6" width="72" height="48" rx="8" fill="none" stroke="ADJ4COLOR" stroke-width="2" opacity="0.18"/>
    <rect x="6" y="-2" width="88" height="64" rx="12" fill="none" stroke="ADJ4COLOR" stroke-width="1" opacity="0.1"/>
  </g>`},

  // STICK - Emergency backup weapon (minimalist)
  stick:{base:`<defs>
    <linearGradient id="stk-wood" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#6b5840"/><stop offset="100%" stop-color="#2f261c"/></linearGradient>
  </defs>
  <g id="stick-root">
    <rect x="46" y="20" width="8" height="100" rx="3" fill="url(#stk-wood)"/>
    <rect x="47" y="22" width="4" height="96" fill="#ffffff" opacity="0.1"/>
    <ellipse cx="50" cy="22" rx="5" ry="4" fill="#5c4a3a"/>
    <ellipse cx="50" cy="118" rx="4" ry="3" fill="#4a3d30"/>
  </g>`,
  gem:``,
  adj1:``,
  adj2:``,
  adj3:``,
  adj4:``}
};

// === TALENT SVG (Portrait-Style: Soft Gradients, No Bold Lines) ===
// Style matches weapons: layered shapes, gradient fills, soft edges, no outlines
// T1=simple gold glow, T2=cyan accents, T3=purple glow + particles

const TALENT_SVG = {
  // ========================================
  // T3 (RARE) - Elaborate designs with purple glow
  // ========================================

  // Anaphora - Crown with "1st" (REREAD first word)
  anaphora: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="an-crown" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#06b6d4"/><stop offset="100%" stop-color="#0e7490"/></linearGradient>
      <radialGradient id="an-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#9333ea" stop-opacity="0.5"/><stop offset="100%" stop-color="#9333ea" stop-opacity="0"/></radialGradient>
      <linearGradient id="an-gold" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#d4af37"/><stop offset="100%" stop-color="#8b6914"/></linearGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="45" ry="55" fill="url(#an-glow)"/>
    <ellipse cx="50" cy="65" rx="40" ry="48" fill="none" stroke="#9333ea" stroke-width="1.5" opacity="0.3"/>
    <path d="M25 55 L30 78 L40 65 L50 82 L60 65 L70 78 L75 55 L70 50 L60 60 L50 42 L40 60 L30 50 Z" fill="url(#an-crown)"/>
    <path d="M30 57 L34 72 L42 63" fill="none" stroke="#fff" stroke-width="2" opacity="0.3" stroke-linecap="round"/>
    <ellipse cx="50" cy="58" rx="6" ry="5" fill="#d4af37"/><ellipse cx="50" cy="57" rx="4" ry="3" fill="#fff" opacity="0.4"/>
    <circle cx="28" cy="42" r="2" fill="#fff" opacity="0.6"/><circle cx="72" cy="44" r="1.5" fill="#fff" opacity="0.5"/>
    <path d="M42 95 L50 105 L58 95" fill="none" stroke="#d4af37" stroke-width="3" stroke-linecap="round" opacity="0.8"/>
  </svg>`,

  // Epistrophe - Crown with "End" (REREAD last word)
  epistrophe: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="ep-crown" x1="0%" y1="100%" x2="100%" y2="0%"><stop offset="0%" stop-color="#0e7490"/><stop offset="100%" stop-color="#06b6d4"/></linearGradient>
      <radialGradient id="ep-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#9333ea" stop-opacity="0.5"/><stop offset="100%" stop-color="#9333ea" stop-opacity="0"/></radialGradient>
      <linearGradient id="ep-gold" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#d4af37"/><stop offset="100%" stop-color="#8b6914"/></linearGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="45" ry="55" fill="url(#ep-glow)"/>
    <ellipse cx="50" cy="65" rx="40" ry="48" fill="none" stroke="#9333ea" stroke-width="1.5" opacity="0.3"/>
    <path d="M25 55 L30 78 L40 65 L50 82 L60 65 L70 78 L75 55 L70 50 L60 60 L50 42 L40 60 L30 50 Z" fill="url(#ep-crown)" transform="rotate(180 50 65)"/>
    <path d="M70 73 L66 58 L58 67" fill="none" stroke="#fff" stroke-width="2" opacity="0.3" stroke-linecap="round"/>
    <ellipse cx="50" cy="72" rx="6" ry="5" fill="#d4af37"/><ellipse cx="50" cy="71" rx="4" ry="3" fill="#fff" opacity="0.4"/>
    <circle cx="28" cy="88" r="2" fill="#fff" opacity="0.6"/><circle cx="72" cy="86" r="1.5" fill="#fff" opacity="0.5"/>
    <path d="M42 105 L50 95 L58 105" fill="none" stroke="#d4af37" stroke-width="3" stroke-linecap="round" opacity="0.8"/>
  </svg>`,

  // Amplify/Khopesh - Egyptian curved blade (REREAD weapon)
  amplify: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="am-blade" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#06b6d4"/><stop offset="50%" stop-color="#0891b2"/><stop offset="100%" stop-color="#164e63"/></linearGradient>
      <radialGradient id="am-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#9333ea" stop-opacity="0.5"/><stop offset="100%" stop-color="#9333ea" stop-opacity="0"/></radialGradient>
      <linearGradient id="am-hilt" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#d4af37"/><stop offset="100%" stop-color="#8b6914"/></linearGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="45" ry="55" fill="url(#am-glow)"/>
    <ellipse cx="50" cy="65" rx="40" ry="48" fill="none" stroke="#9333ea" stroke-width="1.5" opacity="0.3"/>
    <path d="M30 95 Q25 80 30 60 Q35 40 55 25 Q70 35 75 50 Q72 55 65 55 Q55 55 50 65 Q48 75 50 85 L45 90 Z" fill="url(#am-blade)"/>
    <path d="M32 90 Q28 78 32 62 Q36 45 52 32" fill="none" stroke="#fff" stroke-width="2.5" opacity="0.25" stroke-linecap="round"/>
    <rect x="42" y="90" width="10" height="20" rx="2" fill="url(#am-hilt)"/>
    <ellipse cx="47" cy="115" rx="8" ry="5" fill="url(#am-hilt)"/>
    <circle cx="68" cy="38" r="2" fill="#fff" opacity="0.6"/><circle cx="35" cy="50" r="1.5" fill="#fff" opacity="0.5"/>
  </svg>`,

  // Crescendo - Rising wave (REREAD ALL at 6+ REREADs)
  crescendo: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="cr-wave" x1="0%" y1="100%" x2="100%" y2="0%"><stop offset="0%" stop-color="#0e7490"/><stop offset="50%" stop-color="#06b6d4"/><stop offset="100%" stop-color="#22d3ee"/></linearGradient>
      <radialGradient id="cr-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#9333ea" stop-opacity="0.5"/><stop offset="100%" stop-color="#9333ea" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="45" ry="55" fill="url(#cr-glow)"/>
    <ellipse cx="50" cy="65" rx="40" ry="48" fill="none" stroke="#9333ea" stroke-width="1.5" opacity="0.3"/>
    <path d="M15 95 Q20 90 25 85 Q30 75 35 70 Q42 60 50 50 Q60 38 70 30 Q78 25 80 28 Q75 35 72 45 Q68 58 62 68 Q55 80 45 88 Q35 95 25 98 Q18 100 15 95 Z" fill="url(#cr-wave)"/>
    <path d="M20 92 Q28 82 38 68 Q50 52 65 38" fill="none" stroke="#fff" stroke-width="2.5" opacity="0.3" stroke-linecap="round"/>
    <path d="M25 88 Q32 80 40 70 Q50 58 60 48" fill="none" stroke="#fff" stroke-width="1.5" opacity="0.2" stroke-linecap="round"/>
    <circle cx="75" cy="32" r="3" fill="#22d3ee" opacity="0.8"/><circle cx="78" cy="28" r="1.5" fill="#fff" opacity="0.7"/>
    <circle cx="22" cy="78" r="1.5" fill="#fff" opacity="0.5"/><circle cx="70" cy="42" r="1.5" fill="#fff" opacity="0.4"/>
  </svg>`,

  // Berserker - Rage mask (√ó2.5 at round 7+)
  berserker: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="bk-mask" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#dc2626"/><stop offset="50%" stop-color="#991b1b"/><stop offset="100%" stop-color="#450a0a"/></linearGradient>
      <radialGradient id="bk-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#9333ea" stop-opacity="0.5"/><stop offset="100%" stop-color="#9333ea" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="45" ry="55" fill="url(#bk-glow)"/>
    <ellipse cx="50" cy="65" rx="40" ry="48" fill="none" stroke="#9333ea" stroke-width="1.5" opacity="0.3"/>
    <path d="M25 45 Q30 30 50 25 Q70 30 75 45 L78 55 Q75 80 70 90 Q60 105 50 108 Q40 105 30 90 Q25 80 22 55 Z" fill="url(#bk-mask)"/>
    <path d="M28 48 Q32 35 50 30 Q68 35 72 48" fill="none" stroke="#fff" stroke-width="2" opacity="0.2" stroke-linecap="round"/>
    <path d="M30 42 L38 50 M70 42 L62 50" stroke="#450a0a" stroke-width="4" stroke-linecap="round"/>
    <path d="M35 60 L45 65 L35 70 M65 60 L55 65 L65 70" stroke="#0f0f0f" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
    <path d="M38 85 Q50 92 62 85" stroke="#0f0f0f" stroke-width="3" stroke-linecap="round" fill="none"/>
    <circle cx="25" cy="35" r="2" fill="#fff" opacity="0.5"/><circle cx="75" cy="35" r="1.5" fill="#fff" opacity="0.4"/>
  </svg>`,

  // Cascade - Waterfall tiers (√ó1.5^elements)
  cascade: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="ca-water" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#a855f7"/><stop offset="50%" stop-color="#7c3aed"/><stop offset="100%" stop-color="#4c1d95"/></linearGradient>
      <radialGradient id="ca-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#9333ea" stop-opacity="0.5"/><stop offset="100%" stop-color="#9333ea" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="45" ry="55" fill="url(#ca-glow)"/>
    <ellipse cx="50" cy="65" rx="40" ry="48" fill="none" stroke="#9333ea" stroke-width="1.5" opacity="0.3"/>
    <rect x="30" y="25" width="40" height="12" rx="3" fill="url(#ca-water)"/><rect x="32" y="27" width="36" height="4" rx="2" fill="#fff" opacity="0.2"/>
    <path d="M45 37 Q42 45 45 52 M55 37 Q58 45 55 52" stroke="url(#ca-water)" stroke-width="4" fill="none" stroke-linecap="round"/>
    <rect x="25" y="52" width="50" height="12" rx="3" fill="url(#ca-water)"/><rect x="27" y="54" width="46" height="4" rx="2" fill="#fff" opacity="0.2"/>
    <path d="M40 64 Q36 75 40 82 M50 64 Q50 75 50 82 M60 64 Q64 75 60 82" stroke="url(#ca-water)" stroke-width="4" fill="none" stroke-linecap="round"/>
    <rect x="20" y="82" width="60" height="14" rx="3" fill="url(#ca-water)"/><rect x="22" y="84" width="56" height="5" rx="2" fill="#fff" opacity="0.2"/>
    <circle cx="35" cy="45" r="1.5" fill="#fff" opacity="0.6"/><circle cx="65" cy="72" r="1.5" fill="#fff" opacity="0.5"/>
  </svg>`,

  // Compound Interest - Stacked coins (√ó1.15/50g)
  compound_interest: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="ci-coin" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#fbbf24"/><stop offset="50%" stop-color="#d4af37"/><stop offset="100%" stop-color="#92400e"/></linearGradient>
      <radialGradient id="ci-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#9333ea" stop-opacity="0.5"/><stop offset="100%" stop-color="#9333ea" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="45" ry="55" fill="url(#ci-glow)"/>
    <ellipse cx="50" cy="65" rx="40" ry="48" fill="none" stroke="#9333ea" stroke-width="1.5" opacity="0.3"/>
    <ellipse cx="50" cy="95" rx="25" ry="8" fill="url(#ci-coin)"/><ellipse cx="50" cy="93" rx="20" ry="5" fill="#fff" opacity="0.2"/>
    <ellipse cx="50" cy="85" rx="22" ry="7" fill="url(#ci-coin)"/><ellipse cx="50" cy="83" rx="17" ry="4" fill="#fff" opacity="0.2"/>
    <ellipse cx="50" cy="75" rx="19" ry="6" fill="url(#ci-coin)"/><ellipse cx="50" cy="73" rx="14" ry="4" fill="#fff" opacity="0.2"/>
    <ellipse cx="50" cy="65" rx="16" ry="5" fill="url(#ci-coin)"/><ellipse cx="50" cy="63" rx="11" ry="3" fill="#fff" opacity="0.25"/>
    <ellipse cx="50" cy="56" rx="13" ry="4" fill="url(#ci-coin)"/><ellipse cx="50" cy="54" rx="9" ry="2.5" fill="#fff" opacity="0.25"/>
    <ellipse cx="50" cy="48" rx="10" ry="3" fill="url(#ci-coin)"/><ellipse cx="50" cy="46" rx="7" ry="2" fill="#fff" opacity="0.3"/>
    <ellipse cx="50" cy="41" rx="7" ry="2.5" fill="url(#ci-coin)"/><ellipse cx="50" cy="40" rx="5" ry="1.5" fill="#fff" opacity="0.3"/>
    <circle cx="72" cy="50" r="2" fill="#fff" opacity="0.5"/><circle cx="28" cy="80" r="1.5" fill="#fff" opacity="0.4"/>
  </svg>`,

  // Overflow - Overflowing vessel (√ó1.5/10W above 50)
  overflow: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="ov-vessel" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#7c3aed"/><stop offset="100%" stop-color="#4c1d95"/></linearGradient>
      <linearGradient id="ov-liquid" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#a855f7"/><stop offset="100%" stop-color="#7c3aed"/></linearGradient>
      <radialGradient id="ov-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#9333ea" stop-opacity="0.5"/><stop offset="100%" stop-color="#9333ea" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="45" ry="55" fill="url(#ov-glow)"/>
    <ellipse cx="50" cy="65" rx="40" ry="48" fill="none" stroke="#9333ea" stroke-width="1.5" opacity="0.3"/>
    <path d="M30 50 L25 100 Q25 110 50 110 Q75 110 75 100 L70 50 Z" fill="url(#ov-vessel)"/>
    <path d="M32 52 L28 95 Q28 102 50 102" fill="none" stroke="#fff" stroke-width="2" opacity="0.2" stroke-linecap="round"/>
    <ellipse cx="50" cy="50" rx="20" ry="6" fill="url(#ov-vessel)"/>
    <path d="M32 55 Q50 35 68 55 Q50 45 32 55" fill="url(#ov-liquid)"/>
    <ellipse cx="50" cy="50" rx="18" ry="5" fill="url(#ov-liquid)"/><ellipse cx="50" cy="49" rx="12" ry="3" fill="#fff" opacity="0.25"/>
    <path d="M25 48 Q20 40 22 32 M75 48 Q80 40 78 32" stroke="url(#ov-liquid)" stroke-width="5" fill="none" stroke-linecap="round"/>
    <path d="M20 30 Q18 22 22 18 M80 30 Q82 22 78 18" stroke="url(#ov-liquid)" stroke-width="3" fill="none" stroke-linecap="round"/>
    <circle cx="18" cy="25" r="3" fill="#a855f7" opacity="0.7"/><circle cx="82" cy="25" r="3" fill="#a855f7" opacity="0.7"/>
  </svg>`,

  // Chain Reaction - Dominos falling (√ó3 at 4+ REREADs)
  chain_reaction: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="ch-dom" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#a855f7"/><stop offset="100%" stop-color="#581c87"/></linearGradient>
      <radialGradient id="ch-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#9333ea" stop-opacity="0.5"/><stop offset="100%" stop-color="#9333ea" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="45" ry="55" fill="url(#ch-glow)"/>
    <ellipse cx="50" cy="65" rx="40" ry="48" fill="none" stroke="#9333ea" stroke-width="1.5" opacity="0.3"/>
    <rect x="18" y="75" width="10" height="30" rx="2" fill="url(#ch-dom)" transform="rotate(-45 23 90)"/>
    <rect x="33" y="68" width="10" height="30" rx="2" fill="url(#ch-dom)" transform="rotate(-30 38 83)"/>
    <rect x="48" y="62" width="10" height="30" rx="2" fill="url(#ch-dom)" transform="rotate(-15 53 77)"/>
    <rect x="63" y="58" width="10" height="30" rx="2" fill="url(#ch-dom)"/>
    <rect x="78" y="58" width="10" height="30" rx="2" fill="url(#ch-dom)"/>
    <circle cx="23" cy="55" r="3" fill="#fbbf24"/><circle cx="38" cy="48" r="3" fill="#fbbf24"/><circle cx="53" cy="42" r="3" fill="#fbbf24"/><circle cx="68" cy="38" r="3" fill="#fbbf24"/>
    <path d="M25 52 L36 46 L51 40 L66 36" stroke="#fbbf24" stroke-width="2" stroke-dasharray="3,2" opacity="0.6"/>
    <circle cx="15" cy="62" r="1.5" fill="#fff" opacity="0.5"/>
  </svg>`,

  // Crown Jewel/Kohinoor - Legendary diamond (Gem √ó4W)
  crown_jewel: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="cj-gem" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#fff"/><stop offset="30%" stop-color="#e0f2fe"/><stop offset="70%" stop-color="#7dd3fc"/><stop offset="100%" stop-color="#0ea5e9"/></linearGradient>
      <radialGradient id="cj-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#9333ea" stop-opacity="0.6"/><stop offset="100%" stop-color="#9333ea" stop-opacity="0"/></radialGradient>
      <linearGradient id="cj-crown" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#fbbf24"/><stop offset="100%" stop-color="#92400e"/></linearGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="45" ry="55" fill="url(#cj-glow)"/>
    <ellipse cx="50" cy="65" rx="42" ry="50" fill="none" stroke="#9333ea" stroke-width="2" opacity="0.35"/>
    <path d="M50 25 L70 55 L60 90 L40 90 L30 55 Z" fill="url(#cj-gem)"/>
    <path d="M50 25 L30 55 L50 48 L70 55 Z" fill="#fff" opacity="0.4"/>
    <path d="M50 48 L30 55 L40 90 L50 75 Z" fill="#0ea5e9" opacity="0.3"/>
    <path d="M50 48 L70 55 L60 90 L50 75 Z" fill="#0284c7" opacity="0.25"/>
    <line x1="50" y1="25" x2="50" y2="75" stroke="#fff" stroke-width="1" opacity="0.5"/>
    <line x1="30" y1="55" x2="60" y2="90" stroke="#fff" stroke-width="0.5" opacity="0.3"/>
    <line x1="70" y1="55" x2="40" y2="90" stroke="#fff" stroke-width="0.5" opacity="0.3"/>
    <path d="M35 100 L50 95 L65 100 L60 105 L40 105 Z" fill="url(#cj-crown)"/>
    <circle cx="50" cy="32" r="4" fill="#fff" opacity="0.7"/><circle cx="38" cy="55" r="2" fill="#fff" opacity="0.5"/>
    <circle cx="25" cy="40" r="2" fill="#fff" opacity="0.5"/><circle cx="75" cy="40" r="1.5" fill="#fff" opacity="0.4"/>
  </svg>`,

  // Reread Amplifier - Amplifier dial at max (√ó1.5 per REREAD)
  reread_amplifier: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="ra-dial" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#06b6d4"/><stop offset="100%" stop-color="#0e7490"/></linearGradient>
      <linearGradient id="ra-body" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#374151"/><stop offset="100%" stop-color="#111827"/></linearGradient>
      <radialGradient id="ra-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#9333ea" stop-opacity="0.5"/><stop offset="100%" stop-color="#9333ea" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="45" ry="55" fill="url(#ra-glow)"/>
    <ellipse cx="50" cy="65" rx="40" ry="48" fill="none" stroke="#9333ea" stroke-width="1.5" opacity="0.3"/>
    <rect x="25" y="35" width="50" height="70" rx="8" fill="url(#ra-body)"/>
    <rect x="28" y="38" width="44" height="64" rx="6" fill="#1f2937"/>
    <circle cx="50" cy="70" r="22" fill="#0f172a" stroke="url(#ra-dial)" stroke-width="3"/>
    <circle cx="50" cy="70" r="18" fill="#1e293b"/>
    <path d="M30 75 A25 25 0 0 1 70 75" fill="none" stroke="#dc2626" stroke-width="4" stroke-linecap="round"/>
    <path d="M35 78 A20 20 0 0 1 50 58" fill="none" stroke="#22c55e" stroke-width="3" stroke-linecap="round" opacity="0.5"/>
    <line x1="50" y1="70" x2="68" y2="62" stroke="#06b6d4" stroke-width="3" stroke-linecap="round"/>
    <circle cx="50" cy="70" r="4" fill="url(#ra-dial)"/>
    <circle cx="32" cy="45" r="2" fill="#22c55e"/><circle cx="50" cy="42" r="2" fill="#fbbf24"/><circle cx="68" cy="45" r="2" fill="#dc2626"/>
  </svg>`,

  // Echo Chamber - Chamber with reverberations (+5W per REREAD)
  echo_chamber: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="ec-wall" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#475569"/><stop offset="100%" stop-color="#1e293b"/></linearGradient>
      <radialGradient id="ec-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#9333ea" stop-opacity="0.5"/><stop offset="100%" stop-color="#9333ea" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="45" ry="55" fill="url(#ec-glow)"/>
    <ellipse cx="50" cy="65" rx="40" ry="48" fill="none" stroke="#9333ea" stroke-width="1.5" opacity="0.3"/>
    <path d="M20 30 L20 100 L80 100 L80 30 Q50 45 20 30" fill="url(#ec-wall)"/>
    <path d="M22 35 L22 98 L78 98 L78 35 Q50 48 22 35" fill="#0f172a"/>
    <circle cx="50" cy="70" r="6" fill="#06b6d4" opacity="0.9"/>
    <circle cx="50" cy="70" r="12" fill="none" stroke="#06b6d4" stroke-width="2" opacity="0.7"/>
    <circle cx="50" cy="70" r="20" fill="none" stroke="#06b6d4" stroke-width="1.5" opacity="0.5"/>
    <circle cx="50" cy="70" r="28" fill="none" stroke="#06b6d4" stroke-width="1" opacity="0.3"/>
    <circle cx="50" cy="70" r="36" fill="none" stroke="#06b6d4" stroke-width="0.5" opacity="0.2"/>
    <path d="M24 38 L24 95" stroke="#fff" stroke-width="1" opacity="0.1"/>
    <path d="M76 38 L76 95" stroke="#fff" stroke-width="1" opacity="0.1"/>
    <circle cx="30" cy="50" r="1.5" fill="#fff" opacity="0.4"/><circle cx="70" cy="50" r="1.5" fill="#fff" opacity="0.4"/>
  </svg>`,

  // ========================================
  // T1 (COMMON) - Simple designs with gold glow
  // ========================================

  // Steady Hand - Open palm (flat +3W)
  steady_hand: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="sh-hand" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#d4af37"/><stop offset="100%" stop-color="#8b6914"/></linearGradient>
      <radialGradient id="sh-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#d4af37" stop-opacity="0.4"/><stop offset="100%" stop-color="#d4af37" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="35" ry="40" fill="url(#sh-glow)"/>
    <path d="M35 50 Q32 60 35 80 Q38 95 50 100 Q62 95 65 80 Q68 60 65 50 Q63 42 58 38 L58 55 Q55 60 50 60 Q45 60 42 55 L42 38 Q37 42 35 50" fill="url(#sh-hand)"/>
    <path d="M38 55 Q36 65 38 78 Q40 88 50 92" fill="none" stroke="#fff" stroke-width="2.5" opacity="0.25" stroke-linecap="round"/>
    <ellipse cx="42" cy="35" rx="4" ry="6" fill="url(#sh-hand)"/>
    <ellipse cx="50" cy="32" rx="4" ry="7" fill="url(#sh-hand)"/>
    <ellipse cx="58" cy="35" rx="4" ry="6" fill="url(#sh-hand)"/>
  </svg>`,

  // First Blood - Blood drop with dawn (rounds 1-3 +10W)
  first_blood: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="fb-drop" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#ef4444"/><stop offset="100%" stop-color="#7f1d1d"/></linearGradient>
      <radialGradient id="fb-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#fbbf24" stop-opacity="0.4"/><stop offset="100%" stop-color="#fbbf24" stop-opacity="0"/></radialGradient>
      <linearGradient id="fb-dawn" x1="0%" y1="100%" x2="0%" y2="0%"><stop offset="0%" stop-color="#f97316"/><stop offset="50%" stop-color="#fbbf24"/><stop offset="100%" stop-color="#fef3c7"/></linearGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="35" ry="40" fill="url(#fb-glow)"/>
    <path d="M20 95 Q50 75 80 95 L80 110 L20 110 Z" fill="url(#fb-dawn)" opacity="0.5"/>
    <path d="M50 25 Q35 55 35 75 Q35 95 50 100 Q65 95 65 75 Q65 55 50 25" fill="url(#fb-drop)"/>
    <path d="M45 35 Q38 58 40 78" fill="none" stroke="#fff" stroke-width="3" opacity="0.3" stroke-linecap="round"/>
    <ellipse cx="45" cy="80" rx="5" ry="4" fill="#fff" opacity="0.25"/>
  </svg>`,

  // Comfort Zone - Cozy circle (1 element type +6W)
  comfort_zone: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <radialGradient id="cz-warm" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#fbbf24"/><stop offset="70%" stop-color="#d97706"/><stop offset="100%" stop-color="#92400e"/></radialGradient>
      <radialGradient id="cz-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#d4af37" stop-opacity="0.4"/><stop offset="100%" stop-color="#d4af37" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="35" ry="40" fill="url(#cz-glow)"/>
    <circle cx="50" cy="65" r="30" fill="url(#cz-warm)"/>
    <circle cx="50" cy="65" r="22" fill="#fef3c7" opacity="0.2"/>
    <circle cx="50" cy="65" r="14" fill="#fff" opacity="0.15"/>
    <circle cx="42" cy="58" r="4" fill="#fff" opacity="0.3"/>
  </svg>`,

  // Linguist - Speech bubbles (3+ word types +5W)
  linguist: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="lg-bubble" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#d4af37"/><stop offset="100%" stop-color="#8b6914"/></linearGradient>
      <radialGradient id="lg-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#d4af37" stop-opacity="0.4"/><stop offset="100%" stop-color="#d4af37" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="35" ry="40" fill="url(#lg-glow)"/>
    <ellipse cx="38" cy="50" rx="18" ry="14" fill="url(#lg-bubble)"/>
    <path d="M30 60 L25 72 L38 62" fill="url(#lg-bubble)"/>
    <ellipse cx="38" cy="48" rx="12" ry="8" fill="#fff" opacity="0.2"/>
    <ellipse cx="62" cy="70" rx="16" ry="12" fill="url(#lg-bubble)"/>
    <path d="M70 78 L78 88 L65 80" fill="url(#lg-bubble)"/>
    <ellipse cx="62" cy="68" rx="10" ry="7" fill="#fff" opacity="0.2"/>
    <ellipse cx="50" cy="90" rx="14" ry="10" fill="url(#lg-bubble)"/>
    <path d="M45 98 L40 108 L52 99" fill="url(#lg-bubble)"/>
    <ellipse cx="50" cy="88" rx="9" ry="6" fill="#fff" opacity="0.2"/>
  </svg>`,

  // Condensed - Compressed cube (‚â§3 words +8W)
  condensed: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="cd-cube" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#9ca3af"/><stop offset="100%" stop-color="#4b5563"/></linearGradient>
      <linearGradient id="cd-top" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#d1d5db"/><stop offset="100%" stop-color="#9ca3af"/></linearGradient>
      <radialGradient id="cd-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#d4af37" stop-opacity="0.4"/><stop offset="100%" stop-color="#d4af37" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="35" ry="40" fill="url(#cd-glow)"/>
    <path d="M50 35 L75 50 L75 85 L50 100 L25 85 L25 50 Z" fill="url(#cd-cube)"/>
    <path d="M50 35 L75 50 L50 65 L25 50 Z" fill="url(#cd-top)"/>
    <path d="M50 65 L50 100 L25 85 L25 50 Z" fill="#374151"/>
    <path d="M50 35 L50 65 M25 50 L50 65 L75 50" stroke="#fff" stroke-width="1" opacity="0.2"/>
    <path d="M30 52 L30 80" stroke="#fff" stroke-width="2" opacity="0.15"/>
  </svg>`,

  // Spectrum - Rainbow arc (+2W per element)
  spectrum: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <radialGradient id="sp-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#d4af37" stop-opacity="0.4"/><stop offset="100%" stop-color="#d4af37" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="35" ry="40" fill="url(#sp-glow)"/>
    <path d="M15 90 Q50 20 85 90" fill="none" stroke="#94a3b8" stroke-width="6" stroke-linecap="round"/>
    <path d="M20 90 Q50 28 80 90" fill="none" stroke="#84cc16" stroke-width="5" stroke-linecap="round"/>
    <path d="M25 90 Q50 36 75 90" fill="none" stroke="#f97316" stroke-width="5" stroke-linecap="round"/>
    <path d="M30 90 Q50 44 70 90" fill="none" stroke="#3b82f6" stroke-width="5" stroke-linecap="round"/>
    <path d="M35 90 Q50 52 65 90" fill="none" stroke="#fbbf24" stroke-width="4" stroke-linecap="round"/>
    <path d="M40 90 Q50 60 60 90" fill="none" stroke="#6b21a8" stroke-width="4" stroke-linecap="round"/>
    <path d="M45 90 Q50 68 55 90" fill="none" stroke="#78716c" stroke-width="3" stroke-linecap="round"/>
    <path d="M48 90 Q50 76 52 90" fill="none" stroke="#facc15" stroke-width="3" stroke-linecap="round"/>
  </svg>`,

  // Inferno - Steam burst (Fire+Water +10W)
  inferno: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="in-fire" x1="0%" y1="100%" x2="0%" y2="0%"><stop offset="0%" stop-color="#dc2626"/><stop offset="50%" stop-color="#f97316"/><stop offset="100%" stop-color="#fbbf24"/></linearGradient>
      <linearGradient id="in-water" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#3b82f6"/><stop offset="100%" stop-color="#1e40af"/></linearGradient>
      <radialGradient id="in-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#d4af37" stop-opacity="0.4"/><stop offset="100%" stop-color="#d4af37" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="35" ry="40" fill="url(#in-glow)"/>
    <path d="M30 95 Q20 80 35 70 Q25 60 40 50 Q35 35 50 25 Q65 35 60 50 Q75 60 65 70 Q80 80 70 95 Z" fill="url(#in-fire)"/>
    <ellipse cx="50" cy="100" rx="25" ry="8" fill="url(#in-water)"/>
    <path d="M30 95 Q35 100 50 102 Q65 100 70 95" fill="none" stroke="#fff" stroke-width="3" opacity="0.4" stroke-linecap="round"/>
    <ellipse cx="50" cy="45" rx="8" ry="6" fill="#fff" opacity="0.3"/>
    <path d="M42 30 Q50 20 58 30" stroke="#fff" stroke-width="2" opacity="0.4" fill="none"/>
  </svg>`,

  // Verdant - Sprouting plant (Earth+Light +10W)
  verdant: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="vd-leaf" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#22c55e"/><stop offset="100%" stop-color="#15803d"/></linearGradient>
      <linearGradient id="vd-earth" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#78716c"/><stop offset="100%" stop-color="#44403c"/></linearGradient>
      <radialGradient id="vd-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#d4af37" stop-opacity="0.4"/><stop offset="100%" stop-color="#d4af37" stop-opacity="0"/></radialGradient>
      <radialGradient id="vd-sun" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#fbbf24"/><stop offset="100%" stop-color="#fbbf24" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="35" ry="40" fill="url(#vd-glow)"/>
    <ellipse cx="70" cy="30" rx="15" ry="15" fill="url(#vd-sun)" opacity="0.5"/>
    <rect x="20" y="90" width="60" height="20" rx="3" fill="url(#vd-earth)"/>
    <path d="M50 90 L50 55" stroke="#15803d" stroke-width="4" stroke-linecap="round"/>
    <path d="M50 70 Q35 60 30 45 Q40 50 50 60" fill="url(#vd-leaf)"/>
    <path d="M50 60 Q65 50 70 35 Q60 45 50 55" fill="url(#vd-leaf)"/>
    <ellipse cx="50" cy="42" rx="8" ry="6" fill="url(#vd-leaf)"/>
    <path d="M45 42 Q50 35 55 42" stroke="#fff" stroke-width="1.5" opacity="0.3" fill="none"/>
  </svg>`,

  // Venom Strike - Lightning fang (Poison+Lightning +10W)
  venom_strike: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="vs-fang" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#84cc16"/><stop offset="100%" stop-color="#365314"/></linearGradient>
      <linearGradient id="vs-bolt" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#facc15"/><stop offset="100%" stop-color="#ca8a04"/></linearGradient>
      <radialGradient id="vs-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#d4af37" stop-opacity="0.4"/><stop offset="100%" stop-color="#d4af37" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="35" ry="40" fill="url(#vs-glow)"/>
    <path d="M35 30 Q30 50 35 70 L40 65 Q38 50 40 35 Z" fill="url(#vs-fang)"/>
    <path d="M65 30 Q70 50 65 70 L60 65 Q62 50 60 35 Z" fill="url(#vs-fang)"/>
    <path d="M36 32 Q34 48 36 62" stroke="#fff" stroke-width="2" opacity="0.3" fill="none"/>
    <path d="M64 32 Q66 48 64 62" stroke="#fff" stroke-width="2" opacity="0.3" fill="none"/>
    <path d="M50 45 L55 60 L48 60 L55 80 L45 65 L52 65 L45 50 Z" fill="url(#vs-bolt)"/>
    <ellipse cx="38" cy="75" rx="4" ry="6" fill="#84cc16" opacity="0.6"/>
    <ellipse cx="62" cy="78" rx="3" ry="5" fill="#84cc16" opacity="0.5"/>
  </svg>`,

  // Twilight - Half moon (Dark+Physical +10W)
  twilight: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="tw-moon" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#94a3b8"/><stop offset="50%" stop-color="#64748b"/><stop offset="100%" stop-color="#1e293b"/></linearGradient>
      <radialGradient id="tw-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#d4af37" stop-opacity="0.4"/><stop offset="100%" stop-color="#d4af37" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="35" ry="40" fill="url(#tw-glow)"/>
    <circle cx="50" cy="65" r="28" fill="url(#tw-moon)"/>
    <circle cx="62" cy="65" r="22" fill="#0f172a"/>
    <circle cx="40" cy="55" r="4" fill="#475569" opacity="0.5"/>
    <circle cx="45" cy="72" r="3" fill="#475569" opacity="0.4"/>
    <circle cx="35" cy="65" r="2" fill="#475569" opacity="0.3"/>
    <circle cx="42" cy="60" r="3" fill="#fff" opacity="0.15"/>
  </svg>`,

  // Bibliophile - Open book (+1AP per word)
  bibliophile: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="bp-cover" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#d4af37"/><stop offset="100%" stop-color="#8b6914"/></linearGradient>
      <linearGradient id="bp-page" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#fef3c7"/><stop offset="100%" stop-color="#d4af37" stop-opacity="0.3"/></linearGradient>
      <radialGradient id="bp-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#d4af37" stop-opacity="0.4"/><stop offset="100%" stop-color="#d4af37" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="35" ry="40" fill="url(#bp-glow)"/>
    <path d="M50 40 Q30 45 20 50 L20 95 Q30 90 50 85 Q70 90 80 95 L80 50 Q70 45 50 40" fill="url(#bp-cover)"/>
    <path d="M50 45 Q32 50 24 54 L24 90 Q32 86 50 82" fill="url(#bp-page)"/>
    <path d="M50 45 Q68 50 76 54 L76 90 Q68 86 50 82" fill="url(#bp-page)"/>
    <line x1="50" y1="45" x2="50" y2="82" stroke="#8b6914" stroke-width="2"/>
    <path d="M28 60 L44 58 M28 68 L44 66 M28 76 L44 74" stroke="#92400e" stroke-width="1.5" opacity="0.4"/>
    <path d="M72 60 L56 58 M72 68 L56 66 M72 76 L56 74" stroke="#92400e" stroke-width="1.5" opacity="0.4"/>
    <ellipse cx="50" cy="35" rx="8" ry="4" fill="#fbbf24" opacity="0.6"/>
  </svg>`,

  // Proficiency Focus - Crossed tools (+6W for proficient weapon)
  proficiency_focus: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="pf-metal" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#9ca3af"/><stop offset="100%" stop-color="#4b5563"/></linearGradient>
      <linearGradient id="pf-wood" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#92400e"/><stop offset="100%" stop-color="#451a03"/></linearGradient>
      <radialGradient id="pf-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#d4af37" stop-opacity="0.4"/><stop offset="100%" stop-color="#d4af37" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="35" ry="40" fill="url(#pf-glow)"/>
    <rect x="25" y="60" width="50" height="8" rx="2" fill="url(#pf-metal)" transform="rotate(-45 50 65)"/>
    <rect x="25" y="60" width="50" height="8" rx="2" fill="url(#pf-metal)" transform="rotate(45 50 65)"/>
    <rect x="20" y="85" width="12" height="20" rx="2" fill="url(#pf-wood)" transform="rotate(-45 26 95)"/>
    <rect x="68" y="85" width="12" height="20" rx="2" fill="url(#pf-wood)" transform="rotate(45 74 95)"/>
    <circle cx="50" cy="65" r="8" fill="#d4af37"/>
    <circle cx="50" cy="65" r="5" fill="#fff" opacity="0.3"/>
  </svg>`,

  // Hendiadys - Two overlapping circles (+6W for 2+ adj)
  hendiadys: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="hd-left" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#d4af37"/><stop offset="100%" stop-color="#92400e"/></linearGradient>
      <linearGradient id="hd-right" x1="100%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#fbbf24"/><stop offset="100%" stop-color="#d4af37"/></linearGradient>
      <radialGradient id="hd-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#d4af37" stop-opacity="0.4"/><stop offset="100%" stop-color="#d4af37" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="35" ry="40" fill="url(#hd-glow)"/>
    <circle cx="38" cy="65" r="22" fill="url(#hd-left)" opacity="0.8"/>
    <circle cx="62" cy="65" r="22" fill="url(#hd-right)" opacity="0.8"/>
    <path d="M50 45 Q42 65 50 85 Q58 65 50 45" fill="#fff" opacity="0.3"/>
    <circle cx="32" cy="58" r="4" fill="#fff" opacity="0.25"/>
    <circle cx="68" cy="58" r="4" fill="#fff" opacity="0.25"/>
  </svg>`,

  // Stony Brook - River stone with water (+12W for Water+Earth)
  stony_brook: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="sb-stone" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#78716c"/><stop offset="100%" stop-color="#44403c"/></linearGradient>
      <linearGradient id="sb-water" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#3b82f6" stop-opacity="0"/><stop offset="50%" stop-color="#3b82f6"/><stop offset="100%" stop-color="#3b82f6" stop-opacity="0"/></linearGradient>
      <radialGradient id="sb-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#d4af37" stop-opacity="0.4"/><stop offset="100%" stop-color="#d4af37" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="35" ry="40" fill="url(#sb-glow)"/>
    <ellipse cx="50" cy="70" rx="28" ry="20" fill="url(#sb-stone)"/>
    <ellipse cx="45" cy="65" rx="10" ry="8" fill="#57534e" opacity="0.5"/>
    <ellipse cx="60" cy="72" rx="8" ry="6" fill="#57534e" opacity="0.4"/>
    <ellipse cx="42" cy="62" rx="5" ry="4" fill="#fff" opacity="0.2"/>
    <path d="M15 95 Q30 88 50 92 Q70 88 85 95" stroke="url(#sb-water)" stroke-width="4" fill="none"/>
    <path d="M20 100 Q35 94 50 97 Q65 94 80 100" stroke="url(#sb-water)" stroke-width="3" fill="none" opacity="0.7"/>
    <ellipse cx="35" cy="94" rx="3" ry="2" fill="#fff" opacity="0.4"/>
    <ellipse cx="65" cy="96" rx="2" ry="1.5" fill="#fff" opacity="0.3"/>
  </svg>`,

  // Golden Tongue - Coin with tongue (+2W per 10g)
  golden_tongue: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="gt-coin" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#fbbf24"/><stop offset="50%" stop-color="#d4af37"/><stop offset="100%" stop-color="#92400e"/></linearGradient>
      <radialGradient id="gt-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#d4af37" stop-opacity="0.4"/><stop offset="100%" stop-color="#d4af37" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="35" ry="40" fill="url(#gt-glow)"/>
    <ellipse cx="50" cy="60" rx="28" ry="28" fill="url(#gt-coin)"/>
    <ellipse cx="50" cy="60" rx="22" ry="22" fill="none" stroke="#92400e" stroke-width="2" opacity="0.5"/>
    <ellipse cx="50" cy="55" rx="10" ry="8" fill="#fff" opacity="0.25"/>
    <circle cx="50" cy="60" r="6" fill="#92400e"/><ellipse cx="50" cy="58" rx="3" ry="2" fill="#fff" opacity="0.3"/>
    <path d="M40 95 Q50 105 60 95" stroke="#dc2626" stroke-width="6" fill="none" stroke-linecap="round"/>
    <ellipse cx="50" cy="100" rx="8" ry="3" fill="#ef4444"/>
  </svg>`,

  // Momentum - Forward arrow (+1W per word per round)
  momentum: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="mm-arrow" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#92400e"/><stop offset="100%" stop-color="#d4af37"/></linearGradient>
      <radialGradient id="mm-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#d4af37" stop-opacity="0.4"/><stop offset="100%" stop-color="#d4af37" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="35" ry="40" fill="url(#mm-glow)"/>
    <path d="M20 65 L60 65 L60 50 L85 65 L60 80 L60 65" fill="url(#mm-arrow)"/>
    <path d="M25 65 L55 65" stroke="#fff" stroke-width="3" opacity="0.3" stroke-linecap="round"/>
    <path d="M15 55 L25 55" stroke="#d4af37" stroke-width="2" opacity="0.5" stroke-linecap="round"/>
    <path d="M10 65 L22 65" stroke="#d4af37" stroke-width="2" opacity="0.4" stroke-linecap="round"/>
    <path d="M15 75 L25 75" stroke="#d4af37" stroke-width="2" opacity="0.5" stroke-linecap="round"/>
  </svg>`,

  // Word Hoard - Book pile (+0.2W per inventory word)
  word_hoard: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="wh-book1" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#d4af37"/><stop offset="100%" stop-color="#92400e"/></linearGradient>
      <linearGradient id="wh-book2" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#fbbf24"/><stop offset="100%" stop-color="#d4af37"/></linearGradient>
      <radialGradient id="wh-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#d4af37" stop-opacity="0.4"/><stop offset="100%" stop-color="#d4af37" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="35" ry="40" fill="url(#wh-glow)"/>
    <rect x="25" y="85" width="50" height="12" rx="2" fill="url(#wh-book1)"/>
    <rect x="28" y="70" width="44" height="12" rx="2" fill="url(#wh-book2)"/>
    <rect x="30" y="55" width="40" height="12" rx="2" fill="url(#wh-book1)"/>
    <rect x="33" y="40" width="34" height="12" rx="2" fill="url(#wh-book2)"/>
    <rect x="36" y="28" width="28" height="10" rx="2" fill="url(#wh-book1)"/>
    <path d="M27 87 L27 95 M73 87 L73 95" stroke="#fff" stroke-width="1.5" opacity="0.2"/>
    <path d="M30 72 L30 80 M70 72 L70 80" stroke="#fff" stroke-width="1.5" opacity="0.2"/>
  </svg>`,

  // Slow Burn - Candle (+2W √ó round)
  slow_burn: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="slb-wax" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#fef3c7"/><stop offset="100%" stop-color="#d4af37"/></linearGradient>
      <linearGradient id="slb-flame" x1="0%" y1="100%" x2="0%" y2="0%"><stop offset="0%" stop-color="#dc2626"/><stop offset="50%" stop-color="#f97316"/><stop offset="100%" stop-color="#fbbf24"/></linearGradient>
      <radialGradient id="slb-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#d4af37" stop-opacity="0.4"/><stop offset="100%" stop-color="#d4af37" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="35" ry="40" fill="url(#slb-glow)"/>
    <rect x="38" y="55" width="24" height="55" rx="3" fill="url(#slb-wax)"/>
    <rect x="40" y="57" width="8" height="50" rx="2" fill="#fff" opacity="0.2"/>
    <line x1="50" y1="55" x2="50" y2="45" stroke="#44403c" stroke-width="2"/>
    <path d="M50 45 Q42 35 50 20 Q58 35 50 45" fill="url(#slb-flame)"/>
    <ellipse cx="50" cy="32" rx="4" ry="6" fill="#fff" opacity="0.4"/>
    <ellipse cx="50" cy="110" rx="15" ry="4" fill="#92400e" opacity="0.3"/>
  </svg>`,

  // Weak Point - Target with crack (√ó1.5 for weakness)
  weak_point: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <radialGradient id="wp-target" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#dc2626"/><stop offset="30%" stop-color="#dc2626"/><stop offset="35%" stop-color="#fff"/><stop offset="55%" stop-color="#fff"/><stop offset="60%" stop-color="#dc2626"/><stop offset="100%" stop-color="#7f1d1d"/></radialGradient>
      <radialGradient id="wp-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#d4af37" stop-opacity="0.4"/><stop offset="100%" stop-color="#d4af37" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="35" ry="40" fill="url(#wp-glow)"/>
    <circle cx="50" cy="65" r="30" fill="url(#wp-target)"/>
    <path d="M50 65 L55 50 L48 55 L60 40" stroke="#0f172a" stroke-width="3" fill="none" stroke-linecap="round"/>
    <path d="M50 65 L45 80 L52 75 L40 90" stroke="#0f172a" stroke-width="2" fill="none" stroke-linecap="round" opacity="0.7"/>
    <circle cx="50" cy="65" r="5" fill="#0f172a"/>
  </svg>`,

  // Opening Strike - Sunrise sword (√ó1.5 for weapon first)
  opening_strike: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="os-blade" x1="0%" y1="100%" x2="0%" y2="0%"><stop offset="0%" stop-color="#6b7280"/><stop offset="100%" stop-color="#d1d5db"/></linearGradient>
      <linearGradient id="os-dawn" x1="0%" y1="100%" x2="0%" y2="0%"><stop offset="0%" stop-color="#f97316"/><stop offset="50%" stop-color="#fbbf24"/><stop offset="100%" stop-color="#fef3c7"/></linearGradient>
      <radialGradient id="os-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#d4af37" stop-opacity="0.4"/><stop offset="100%" stop-color="#d4af37" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="35" ry="40" fill="url(#os-glow)"/>
    <ellipse cx="50" cy="100" rx="40" ry="20" fill="url(#os-dawn)" opacity="0.5"/>
    <path d="M50 20 L54 25 L54 75 L50 80 L46 75 L46 25 Z" fill="url(#os-blade)"/>
    <path d="M47 28 L47 72" stroke="#fff" stroke-width="2" opacity="0.3"/>
    <rect x="42" y="80" width="16" height="6" rx="1" fill="#92400e"/>
    <rect x="45" y="86" width="10" height="15" rx="2" fill="#78716c"/>
    <path d="M30 95 L40 85 M70 95 L60 85 M50 100 L50 90" stroke="#fbbf24" stroke-width="2" opacity="0.6"/>
  </svg>`,

  // Capital Punishment - Sling (√ó2.5 vs boss/miniboss)
  capital_punishment: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="dg-sling" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#92400e"/><stop offset="100%" stop-color="#451a03"/></linearGradient>
      <linearGradient id="dg-stone" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#9ca3af"/><stop offset="100%" stop-color="#4b5563"/></linearGradient>
      <radialGradient id="dg-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#d4af37" stop-opacity="0.4"/><stop offset="100%" stop-color="#d4af37" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="35" ry="40" fill="url(#dg-glow)"/>
    <path d="M25 90 Q15 70 30 55 Q40 50 50 55" stroke="url(#dg-sling)" stroke-width="4" fill="none" stroke-linecap="round"/>
    <path d="M75 90 Q85 70 70 55 Q60 50 50 55" stroke="url(#dg-sling)" stroke-width="4" fill="none" stroke-linecap="round"/>
    <ellipse cx="50" cy="55" rx="12" ry="8" fill="url(#dg-sling)"/>
    <circle cx="50" cy="55" r="10" fill="url(#dg-stone)"/>
    <ellipse cx="46" cy="52" rx="3" ry="2" fill="#fff" opacity="0.3"/>
    <path d="M35 40 L45 48 M65 40 L55 48" stroke="#d4af37" stroke-width="2" opacity="0.5"/>
  </svg>`,

  // Irony - Twisted arrows (resist ‚Üí weakness)
  irony: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="ir-arrow1" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#3b82f6"/><stop offset="100%" stop-color="#1e40af"/></linearGradient>
      <linearGradient id="ir-arrow2" x1="100%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#dc2626"/><stop offset="100%" stop-color="#7f1d1d"/></linearGradient>
      <radialGradient id="ir-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#d4af37" stop-opacity="0.4"/><stop offset="100%" stop-color="#d4af37" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="35" ry="40" fill="url(#ir-glow)"/>
    <path d="M25 40 Q50 55 75 40" stroke="url(#ir-arrow1)" stroke-width="5" fill="none" stroke-linecap="round"/>
    <path d="M70 35 L78 42 L72 48" fill="url(#ir-arrow1)"/>
    <path d="M75 90 Q50 75 25 90" stroke="url(#ir-arrow2)" stroke-width="5" fill="none" stroke-linecap="round"/>
    <path d="M30 95 L22 88 L28 82" fill="url(#ir-arrow2)"/>
    <circle cx="50" cy="65" r="10" fill="#d4af37"/>
    <path d="M46 62 L50 58 L54 62 M46 68 L50 72 L54 68" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round"/>
  </svg>`,

  // Overkill Dividend - Coin splash (overkill ‚Üí gold)
  overkill_dividend: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="od-coin" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#fbbf24"/><stop offset="100%" stop-color="#92400e"/></linearGradient>
      <radialGradient id="od-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#d4af37" stop-opacity="0.4"/><stop offset="100%" stop-color="#d4af37" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="35" ry="40" fill="url(#od-glow)"/>
    <ellipse cx="50" cy="70" rx="15" ry="15" fill="url(#od-coin)"/>
    <ellipse cx="50" cy="68" rx="10" ry="10" fill="#fff" opacity="0.2"/>
    <ellipse cx="30" cy="45" rx="8" ry="8" fill="url(#od-coin)"/>
    <ellipse cx="70" cy="48" rx="7" ry="7" fill="url(#od-coin)"/>
    <ellipse cx="25" cy="80" rx="6" ry="6" fill="url(#od-coin)"/>
    <ellipse cx="75" cy="85" rx="7" ry="7" fill="url(#od-coin)"/>
    <ellipse cx="40" cy="95" rx="5" ry="5" fill="url(#od-coin)"/>
    <ellipse cx="62" cy="92" rx="6" ry="6" fill="url(#od-coin)"/>
    <path d="M50 50 L45 35 M50 50 L55 32 M50 50 L38 42 M50 50 L62 40" stroke="#fbbf24" stroke-width="2" opacity="0.6"/>
  </svg>`,

  // Echo Profits - Coins with reread echoes
  echo_profits: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="ep-coin" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#fbbf24"/><stop offset="100%" stop-color="#92400e"/></linearGradient>
      <radialGradient id="ep-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#d4af37" stop-opacity="0.4"/><stop offset="100%" stop-color="#d4af37" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="35" ry="40" fill="url(#ep-glow)"/>
    <ellipse cx="50" cy="70" rx="18" ry="18" fill="url(#ep-coin)"/>
    <ellipse cx="50" cy="68" rx="12" ry="12" fill="#fff" opacity="0.2"/>
    <circle cx="50" cy="70" r="28" fill="none" stroke="#d4af37" stroke-width="2" opacity="0.3"/>
    <circle cx="50" cy="70" r="35" fill="none" stroke="#d4af37" stroke-width="1.5" opacity="0.2"/>
    <circle cx="50" cy="70" r="42" fill="none" stroke="#d4af37" stroke-width="1" opacity="0.1"/>
    <text x="50" y="75" font-size="14" fill="#fff" text-anchor="middle" font-weight="bold">$</text>
  </svg>`,

  // Elemental Bounty - Multiple element orbs with gold
  elemental_bounty: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="eb-coin" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#fbbf24"/><stop offset="100%" stop-color="#92400e"/></linearGradient>
      <radialGradient id="eb-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#eb-glow)"/>
    <circle cx="30" cy="50" r="10" fill="#f97316"/><ellipse cx="28" cy="48" rx="4" ry="3" fill="#fff" opacity="0.3"/>
    <circle cx="70" cy="50" r="10" fill="#3b82f6"/><ellipse cx="68" cy="48" rx="4" ry="3" fill="#fff" opacity="0.3"/>
    <circle cx="30" cy="80" r="10" fill="#78716c"/><ellipse cx="28" cy="78" rx="4" ry="3" fill="#fff" opacity="0.3"/>
    <circle cx="70" cy="80" r="10" fill="#facc15"/><ellipse cx="68" cy="78" rx="4" ry="3" fill="#fff" opacity="0.3"/>
    <ellipse cx="50" cy="65" rx="14" ry="14" fill="url(#eb-coin)"/>
    <text x="50" y="70" font-size="12" fill="#fff" text-anchor="middle" font-weight="bold">$</text>
  </svg>`,

  // Treasure Hunter - Chest with T3 gems
  treasure_hunter: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="th-chest" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#92400e"/><stop offset="100%" stop-color="#451a03"/></linearGradient>
      <linearGradient id="th-gold" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#fbbf24"/><stop offset="100%" stop-color="#d97706"/></linearGradient>
      <radialGradient id="th-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#fbbf24" stop-opacity="0.5"/><stop offset="100%" stop-color="#fbbf24" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#th-glow)"/>
    <rect x="25" y="55" width="50" height="35" rx="3" fill="url(#th-chest)"/>
    <rect x="25" y="55" width="50" height="12" rx="3" fill="#b45309"/>
    <rect x="45" y="62" width="10" height="8" rx="2" fill="url(#th-gold)"/>
    <ellipse cx="35" cy="45" rx="6" ry="6" fill="#c084fc"/><ellipse cx="33" cy="43" rx="2" ry="2" fill="#fff" opacity="0.4"/>
    <ellipse cx="50" cy="40" rx="7" ry="7" fill="#c084fc"/><ellipse cx="48" cy="38" rx="2.5" ry="2" fill="#fff" opacity="0.4"/>
    <ellipse cx="65" cy="45" rx="6" ry="6" fill="#c084fc"/><ellipse cx="63" cy="43" rx="2" ry="2" fill="#fff" opacity="0.4"/>
    <path d="M35 45 L40 52 M50 40 L50 50 M65 45 L60 52" stroke="#fbbf24" stroke-width="1.5" opacity="0.6"/>
  </svg>`,

  // Appraiser's Eye - Magnifying glass over rarity badge
  appraisers_eye: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="ae-lens" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#bfdbfe"/><stop offset="100%" stop-color="#60a5fa"/></linearGradient>
      <linearGradient id="ae-gold" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#fbbf24"/><stop offset="100%" stop-color="#d97706"/></linearGradient>
      <radialGradient id="ae-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#fbbf24" stop-opacity="0.3"/><stop offset="100%" stop-color="#fbbf24" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#ae-glow)"/>
    <circle cx="45" cy="60" r="22" fill="url(#ae-lens)" opacity="0.3"/>
    <circle cx="45" cy="60" r="22" fill="none" stroke="url(#ae-gold)" stroke-width="4"/>
    <line x1="62" y1="77" x2="78" y2="93" stroke="url(#ae-gold)" stroke-width="6" stroke-linecap="round"/>
    <rect x="35" y="55" width="20" height="12" rx="2" fill="#c084fc"/>
    <text x="45" y="64" font-size="8" fill="#fff" text-anchor="middle" font-weight="bold">RARE</text>
  </svg>`,

  // Rarity Cascade - Rarity badge with echo rings
  rarity_cascade: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="rc-badge" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#c084fc"/><stop offset="100%" stop-color="#7c3aed"/></linearGradient>
      <radialGradient id="rc-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#c084fc" stop-opacity="0.4"/><stop offset="100%" stop-color="#c084fc" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#rc-glow)"/>
    <circle cx="50" cy="65" r="38" fill="none" stroke="#c084fc" stroke-width="1" opacity="0.15"/>
    <circle cx="50" cy="65" r="32" fill="none" stroke="#c084fc" stroke-width="1.5" opacity="0.25"/>
    <circle cx="50" cy="65" r="26" fill="none" stroke="#c084fc" stroke-width="2" opacity="0.35"/>
    <rect x="30" y="55" width="40" height="20" rx="4" fill="url(#rc-badge)"/>
    <text x="50" y="69" font-size="10" fill="#fff" text-anchor="middle" font-weight="bold">EPIC</text>
    <path d="M30 65 L20 65 M70 65 L80 65 M50 45 L50 35 M50 85 L50 95" stroke="#c084fc" stroke-width="2" opacity="0.5"/>
  </svg>`,

  // Gem Resonance - Single gem with pulse (REREAD gem)
  gem_resonance: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="gr-gem" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#c084fc"/><stop offset="50%" stop-color="#9333ea"/><stop offset="100%" stop-color="#581c87"/></linearGradient>
      <radialGradient id="gr-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#d4af37" stop-opacity="0.4"/><stop offset="100%" stop-color="#d4af37" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="35" ry="40" fill="url(#gr-glow)"/>
    <circle cx="50" cy="65" r="32" fill="none" stroke="#9333ea" stroke-width="1" opacity="0.2"/>
    <circle cx="50" cy="65" r="26" fill="none" stroke="#9333ea" stroke-width="1.5" opacity="0.3"/>
    <circle cx="50" cy="65" r="20" fill="none" stroke="#9333ea" stroke-width="2" opacity="0.4"/>
    <path d="M50 40 L65 55 L65 75 L50 90 L35 75 L35 55 Z" fill="url(#gr-gem)"/>
    <path d="M50 40 L35 55 L50 60 L65 55 Z" fill="#fff" opacity="0.3"/>
    <path d="M50 60 L35 55 L35 75 L50 80 Z" fill="#7c3aed" opacity="0.3"/>
    <line x1="50" y1="40" x2="50" y2="80" stroke="#fff" stroke-width="1" opacity="0.3"/>
    <ellipse cx="42" cy="55" rx="4" ry="3" fill="#fff" opacity="0.4"/>
  </svg>`,

  // ========================================
  // T2 (UNCOMMON) - Medium complexity with cyan accents
  // ========================================

  // World & Sky Focus - Four elements quadrant (+2W each)
  world_sky_focus: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <radialGradient id="wsf-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#wsf-glow)"/>
    <circle cx="50" cy="65" r="32" fill="#0f172a" stroke="#06b6d4" stroke-width="2" opacity="0.8"/>
    <path d="M50 33 L50 65 L82 65" fill="none" stroke="#1e293b" stroke-width="2"/>
    <path d="M50 33 L50 65 L18 65" fill="none" stroke="#1e293b" stroke-width="2"/>
    <circle cx="38" cy="52" r="10" fill="#f97316"/><ellipse cx="36" cy="50" rx="4" ry="3" fill="#fff" opacity="0.3"/>
    <circle cx="62" cy="52" r="10" fill="#3b82f6"/><ellipse cx="60" cy="50" rx="4" ry="3" fill="#fff" opacity="0.3"/>
    <circle cx="38" cy="78" r="10" fill="#78716c"/><ellipse cx="36" cy="76" rx="4" ry="3" fill="#fff" opacity="0.3"/>
    <circle cx="62" cy="78" r="10" fill="#facc15"/><ellipse cx="60" cy="76" rx="4" ry="3" fill="#fff" opacity="0.3"/>
  </svg>`,

  // Body & Soul Focus - Yin-yang variant (+2W each)
  body_soul_focus: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <radialGradient id="bsf-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#bsf-glow)"/>
    <circle cx="50" cy="65" r="32" fill="#0f172a" stroke="#06b6d4" stroke-width="2" opacity="0.8"/>
    <path d="M50 33 A32 32 0 0 1 50 97" fill="#94a3b8"/>
    <path d="M50 33 A32 32 0 0 0 50 97" fill="#6b21a8"/>
    <circle cx="50" cy="49" r="8" fill="#84cc16"/><ellipse cx="48" cy="47" rx="3" ry="2" fill="#fff" opacity="0.3"/>
    <circle cx="50" cy="81" r="8" fill="#fbbf24"/><ellipse cx="48" cy="79" rx="3" ry="2" fill="#fff" opacity="0.3"/>
  </svg>`,

  // Weakness Exploit - Cracked armor (+6W per weakness word)
  weakness_exploit: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="we-armor" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#6b7280"/><stop offset="100%" stop-color="#374151"/></linearGradient>
      <radialGradient id="we-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#we-glow)"/>
    <path d="M50 25 L75 45 L75 90 L50 105 L25 90 L25 45 Z" fill="url(#we-armor)"/>
    <path d="M30 48 L30 85 L50 98" fill="none" stroke="#fff" stroke-width="2" opacity="0.15"/>
    <path d="M50 50 L55 60 L48 65 L58 78 L45 85 L52 95" stroke="#dc2626" stroke-width="3" fill="none"/>
    <path d="M50 50 L42 58 L50 62 L40 72" stroke="#dc2626" stroke-width="2" fill="none" opacity="0.7"/>
    <circle cx="50" cy="50" r="4" fill="#dc2626"/>
  </svg>`,

  // Isocolon - Equal bars (+15W all same tier)
  isocolon: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="ic-bar" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#06b6d4"/><stop offset="100%" stop-color="#0891b2"/></linearGradient>
      <radialGradient id="ic-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#ic-glow)"/>
    <rect x="20" y="40" width="60" height="12" rx="3" fill="url(#ic-bar)"/>
    <rect x="22" y="42" width="56" height="4" rx="2" fill="#fff" opacity="0.25"/>
    <rect x="20" y="58" width="60" height="12" rx="3" fill="url(#ic-bar)"/>
    <rect x="22" y="60" width="56" height="4" rx="2" fill="#fff" opacity="0.25"/>
    <rect x="20" y="76" width="60" height="12" rx="3" fill="url(#ic-bar)"/>
    <rect x="22" y="78" width="56" height="4" rx="2" fill="#fff" opacity="0.25"/>
    <circle cx="12" cy="46" r="3" fill="#06b6d4"/><circle cx="12" cy="64" r="3" fill="#06b6d4"/><circle cx="12" cy="82" r="3" fill="#06b6d4"/>
  </svg>`,

  // Alliteration - Sound waves (same first letter)
  alliteration: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="al-wave" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#06b6d4"/><stop offset="100%" stop-color="#0e7490"/></linearGradient>
      <radialGradient id="al-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#al-glow)"/>
    <circle cx="30" cy="65" r="8" fill="url(#al-wave)"/>
    <path d="M42 50 Q55 65 42 80" fill="none" stroke="#06b6d4" stroke-width="3" opacity="0.8"/>
    <path d="M52 42 Q70 65 52 88" fill="none" stroke="#06b6d4" stroke-width="3" opacity="0.6"/>
    <path d="M62 35 Q85 65 62 95" fill="none" stroke="#06b6d4" stroke-width="3" opacity="0.4"/>
  </svg>`,

  // Lexicon Growth - Growing tree (+1W per word per boss)
  lexicon_growth: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="lxg-trunk" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#92400e"/><stop offset="100%" stop-color="#451a03"/></linearGradient>
      <linearGradient id="lxg-leaf" x1="0%" y1="100%" x2="0%" y2="0%"><stop offset="0%" stop-color="#15803d"/><stop offset="100%" stop-color="#22c55e"/></linearGradient>
      <radialGradient id="lxg-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#lxg-glow)"/>
    <rect x="45" y="70" width="10" height="35" rx="2" fill="url(#lxg-trunk)"/>
    <circle cx="50" cy="55" r="25" fill="url(#lxg-leaf)"/>
    <circle cx="35" cy="48" r="12" fill="url(#lxg-leaf)"/>
    <circle cx="65" cy="48" r="12" fill="url(#lxg-leaf)"/>
    <circle cx="50" cy="38" r="10" fill="url(#lxg-leaf)"/>
    <ellipse cx="42" cy="50" rx="5" ry="4" fill="#fff" opacity="0.2"/>
    <rect x="30" y="95" width="40" height="12" rx="3" fill="#78716c"/>
    <ellipse cx="50" cy="101" rx="5" ry="3" fill="#dc2626"/><path d="M47 99 L50 95 L53 99" fill="#dc2626"/>
  </svg>`,

  // Tithe - Offering bowl (+2W per 20g spent)
  tithe: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="ti-bowl" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#d4af37"/><stop offset="100%" stop-color="#92400e"/></linearGradient>
      <linearGradient id="ti-coin" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#fbbf24"/><stop offset="100%" stop-color="#d4af37"/></linearGradient>
      <radialGradient id="ti-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#ti-glow)"/>
    <path d="M25 70 Q20 85 30 95 L70 95 Q80 85 75 70 Z" fill="url(#ti-bowl)"/>
    <ellipse cx="50" cy="70" rx="25" ry="8" fill="url(#ti-bowl)"/>
    <ellipse cx="50" cy="68" rx="20" ry="6" fill="#fef3c7" opacity="0.3"/>
    <ellipse cx="40" cy="55" rx="6" ry="6" fill="url(#ti-coin)"/>
    <ellipse cx="55" cy="48" rx="5" ry="5" fill="url(#ti-coin)"/>
    <ellipse cx="62" cy="58" rx="6" ry="6" fill="url(#ti-coin)"/>
    <path d="M42 50 Q50 62 40 68 M57 45 Q50 58 55 68 M64 52 Q58 62 62 68" stroke="#d4af37" stroke-width="1.5" stroke-dasharray="2,2" opacity="0.5"/>
  </svg>`,

  // Word Historian - Open scroll with tally marks (cumulative words)
  word_historian: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="whist-book" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#8b5a2b"/><stop offset="100%" stop-color="#5d3a1a"/></linearGradient>
      <linearGradient id="whist-page" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#fef9e7"/><stop offset="100%" stop-color="#f5e6c8"/></linearGradient>
      <radialGradient id="whist-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.5"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <!-- Glow -->
    <ellipse cx="50" cy="65" rx="40" ry="48" fill="url(#whist-glow)"/>
    <!-- Open book - left page -->
    <path d="M50 30 L20 38 L20 95 L50 88 Z" fill="url(#whist-page)" stroke="#d4a76a" stroke-width="1"/>
    <!-- Open book - right page -->
    <path d="M50 30 L80 38 L80 95 L50 88 Z" fill="url(#whist-page)" stroke="#d4a76a" stroke-width="1"/>
    <!-- Book spine -->
    <rect x="47" y="28" width="6" height="62" fill="url(#whist-book)" rx="1"/>
    <!-- Counter badge on left page -->
    <circle cx="35" cy="58" r="14" fill="#1e3a5f" stroke="#06b6d4" stroke-width="2"/>
    <text x="35" y="64" font-size="16" font-weight="bold" fill="#06b6d4" text-anchor="middle" font-family="sans-serif">+</text>
    <!-- Tally marks on right page -->
    <line x1="58" y1="48" x2="58" y2="62" stroke="#5d3a1a" stroke-width="2.5" stroke-linecap="round"/>
    <line x1="64" y1="48" x2="64" y2="62" stroke="#5d3a1a" stroke-width="2.5" stroke-linecap="round"/>
    <line x1="70" y1="48" x2="70" y2="62" stroke="#5d3a1a" stroke-width="2.5" stroke-linecap="round"/>
    <line x1="56" y1="55" x2="72" y2="55" stroke="#5d3a1a" stroke-width="2" stroke-linecap="round"/>
    <!-- More tallies below -->
    <line x1="58" y1="70" x2="58" y2="80" stroke="#5d3a1a" stroke-width="2" stroke-linecap="round"/>
    <line x1="64" y1="70" x2="64" y2="80" stroke="#5d3a1a" stroke-width="2" stroke-linecap="round"/>
  </svg>`,

  // Reverberation - Sound waves echoing (cumulative rereads)
  reverberation: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="reverb-wave" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#a855f7"/><stop offset="100%" stop-color="#7c3aed"/></linearGradient>
      <radialGradient id="reverb-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#a855f7" stop-opacity="0.4"/><stop offset="100%" stop-color="#7c3aed" stop-opacity="0"/></radialGradient>
      <radialGradient id="reverb-center" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#e879f9"/><stop offset="100%" stop-color="#a855f7"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#reverb-glow)"/>
    <circle cx="50" cy="65" r="8" fill="url(#reverb-center)"/>
    <circle cx="50" cy="65" r="8" fill="#fff" opacity="0.3"/>
    <circle cx="50" cy="65" r="16" stroke="url(#reverb-wave)" stroke-width="2" fill="none" opacity="0.8"/>
    <circle cx="50" cy="65" r="24" stroke="url(#reverb-wave)" stroke-width="2" fill="none" opacity="0.6"/>
    <circle cx="50" cy="65" r="32" stroke="url(#reverb-wave)" stroke-width="2" fill="none" opacity="0.4"/>
    <circle cx="50" cy="65" r="40" stroke="url(#reverb-wave)" stroke-width="1.5" fill="none" opacity="0.2"/>
  </svg>`,

  // Magma Core - Lava heart (√ó2 Fire+Earth)
  magma_core: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="mc-lava" x1="0%" y1="100%" x2="0%" y2="0%"><stop offset="0%" stop-color="#7f1d1d"/><stop offset="30%" stop-color="#dc2626"/><stop offset="60%" stop-color="#f97316"/><stop offset="100%" stop-color="#fbbf24"/></linearGradient>
      <linearGradient id="mc-rock" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#78716c"/><stop offset="100%" stop-color="#44403c"/></linearGradient>
      <radialGradient id="mc-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#mc-glow)"/>
    <path d="M50 30 Q70 45 70 65 Q70 90 50 100 Q30 90 30 65 Q30 45 50 30" fill="url(#mc-rock)"/>
    <path d="M50 38 Q62 50 62 65 Q62 82 50 90 Q38 82 38 65 Q38 50 50 38" fill="url(#mc-lava)"/>
    <path d="M45 45 Q50 55 45 65" stroke="#fbbf24" stroke-width="3" fill="none" opacity="0.6"/>
    <circle cx="50" cy="65" r="8" fill="#fbbf24" opacity="0.5"/>
    <circle cx="50" cy="65" r="4" fill="#fff" opacity="0.6"/>
  </svg>`,

  // Tempest - Storm cloud (√ó2 Water+Lightning)
  tempest: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="tm-cloud" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#6b7280"/><stop offset="100%" stop-color="#374151"/></linearGradient>
      <linearGradient id="tm-bolt" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#facc15"/><stop offset="100%" stop-color="#ca8a04"/></linearGradient>
      <radialGradient id="tm-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#tm-glow)"/>
    <ellipse cx="35" cy="45" rx="18" ry="14" fill="url(#tm-cloud)"/>
    <ellipse cx="55" cy="42" rx="20" ry="16" fill="url(#tm-cloud)"/>
    <ellipse cx="70" cy="48" rx="15" ry="12" fill="url(#tm-cloud)"/>
    <ellipse cx="50" cy="52" rx="30" ry="18" fill="url(#tm-cloud)"/>
    <path d="M45 65 L52 78 L42 78 L55 100 L48 85 L58 85 L45 65" fill="url(#tm-bolt)"/>
    <path d="M28 75 L28 85 M35 78 L35 92 M72 75 L72 88 M65 72 L65 85" stroke="#3b82f6" stroke-width="2" stroke-linecap="round"/>
    <ellipse cx="40" cy="40" rx="6" ry="4" fill="#fff" opacity="0.2"/>
  </svg>`,

  // Eclipse/Umbral Dawn - Sun-moon eclipse (√ó2 Light+Dark)
  eclipse: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="ec-sun" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#fbbf24"/><stop offset="100%" stop-color="#f97316"/></linearGradient>
      <radialGradient id="ec-corona" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#fbbf24" stop-opacity="0.8"/><stop offset="100%" stop-color="#fbbf24" stop-opacity="0"/></radialGradient>
      <radialGradient id="ec-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#ec-glow)"/>
    <circle cx="50" cy="65" r="35" fill="url(#ec-corona)"/>
    <circle cx="50" cy="65" r="25" fill="url(#ec-sun)"/>
    <circle cx="55" cy="60" r="25" fill="#1e1b4b"/>
    <ellipse cx="62" cy="55" rx="4" ry="3" fill="#fff" opacity="0.1"/>
    <path d="M20 65 L10 65 M80 65 L90 65 M50 30 L50 20 M50 100 L50 110" stroke="#fbbf24" stroke-width="2" opacity="0.5"/>
    <path d="M25 40 L18 33 M75 40 L82 33 M25 90 L18 97 M75 90 L82 97" stroke="#fbbf24" stroke-width="1.5" opacity="0.4"/>
  </svg>`,

  // Necrotoxin/Thanatos - Skull with drip (√ó2 Dark+Poison)
  necrotoxin: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="nt-skull" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#e5e7eb"/><stop offset="100%" stop-color="#9ca3af"/></linearGradient>
      <linearGradient id="nt-poison" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#84cc16"/><stop offset="100%" stop-color="#365314"/></linearGradient>
      <radialGradient id="nt-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#nt-glow)"/>
    <ellipse cx="50" cy="50" rx="25" ry="22" fill="url(#nt-skull)"/>
    <path d="M35 70 L35 85 L42 85 L42 75 L50 80 L58 75 L58 85 L65 85 L65 70" fill="url(#nt-skull)"/>
    <ellipse cx="40" cy="48" rx="7" ry="8" fill="#1e1b4b"/>
    <ellipse cx="60" cy="48" rx="7" ry="8" fill="#1e1b4b"/>
    <ellipse cx="50" cy="58" rx="4" ry="3" fill="#1e1b4b"/>
    <path d="M30 40 Q25 50 28 65 L22 75" stroke="url(#nt-poison)" stroke-width="4" fill="none" stroke-linecap="round"/>
    <ellipse cx="22" cy="78" rx="4" ry="5" fill="url(#nt-poison)"/>
    <path d="M70 42 Q78 52 72 68 L78 80" stroke="url(#nt-poison)" stroke-width="3" fill="none" stroke-linecap="round"/>
    <ellipse cx="78" cy="83" rx="3" ry="4" fill="url(#nt-poison)"/>
  </svg>`,

  // Blessed Steel/Helios - Radiant blade (√ó2 Light+Physical)
  blessed_steel: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="bs-blade" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#f1f5f9"/><stop offset="50%" stop-color="#cbd5e1"/><stop offset="100%" stop-color="#64748b"/></linearGradient>
      <radialGradient id="bs-holy" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#fbbf24" stop-opacity="0.8"/><stop offset="100%" stop-color="#fbbf24" stop-opacity="0"/></radialGradient>
      <radialGradient id="bs-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#bs-glow)"/>
    <ellipse cx="50" cy="50" rx="30" ry="30" fill="url(#bs-holy)"/>
    <path d="M50 20 L55 30 L55 75 L50 82 L45 75 L45 30 Z" fill="url(#bs-blade)"/>
    <path d="M47 32 L47 72" stroke="#fff" stroke-width="2" opacity="0.4"/>
    <rect x="38" y="82" width="24" height="8" rx="2" fill="#d4af37"/>
    <rect x="44" y="90" width="12" height="16" rx="2" fill="#92400e"/>
    <path d="M30 45 L20 45 M70 45 L80 45 M50 15 L50 8" stroke="#fbbf24" stroke-width="3" opacity="0.6"/>
    <circle cx="50" cy="50" r="6" fill="#fbbf24" opacity="0.5"/>
  </svg>`,

  // Static Earth/Gaia - Crystal formation (√ó2 Lightning+Earth)
  static_earth: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="se-crystal" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#a8a29e"/><stop offset="50%" stop-color="#78716c"/><stop offset="100%" stop-color="#44403c"/></linearGradient>
      <linearGradient id="se-spark" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#facc15"/><stop offset="100%" stop-color="#ca8a04"/></linearGradient>
      <radialGradient id="se-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#se-glow)"/>
    <path d="M50 25 L58 50 L50 55 L42 50 Z" fill="url(#se-crystal)"/>
    <path d="M35 45 L42 70 L35 78 L28 70 Z" fill="url(#se-crystal)"/>
    <path d="M65 45 L72 70 L65 78 L58 70 Z" fill="url(#se-crystal)"/>
    <path d="M50 60 L60 90 L50 100 L40 90 Z" fill="url(#se-crystal)"/>
    <path d="M45 28 L45 48" stroke="#fff" stroke-width="1.5" opacity="0.3"/>
    <path d="M32 48 L32 72" stroke="#fff" stroke-width="1.5" opacity="0.3"/>
    <path d="M68 48 L68 72" stroke="#fff" stroke-width="1.5" opacity="0.3"/>
    <path d="M48 62 L48 92" stroke="#fff" stroke-width="1.5" opacity="0.3"/>
    <path d="M40 35 L38 42 M60 35 L62 42 M25 60 L30 65 M75 60 L70 65" stroke="url(#se-spark)" stroke-width="2"/>
    <circle cx="50" cy="40" r="3" fill="#facc15" opacity="0.6"/>
  </svg>`,

  // Synecdoche - Crown piece (√ó4 for 4+ same element)
  synecdoche: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="sy-gold" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#fbbf24"/><stop offset="100%" stop-color="#92400e"/></linearGradient>
      <radialGradient id="sy-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#sy-glow)"/>
    <path d="M50 30 L62 45 L58 50 L50 42 L42 50 L38 45 Z" fill="url(#sy-gold)"/>
    <ellipse cx="50" cy="35" rx="5" ry="4" fill="#dc2626"/>
    <ellipse cx="50" cy="34" rx="3" ry="2" fill="#fff" opacity="0.4"/>
    <path d="M42 52 L42 48 M58 52 L58 48" stroke="#fff" stroke-width="1" opacity="0.3"/>
    <ellipse cx="50" cy="80" rx="30" ry="20" fill="none" stroke="#06b6d4" stroke-width="1" stroke-dasharray="4,3" opacity="0.5"/>
    <circle cx="40" cy="80" r="4" fill="#06b6d4" opacity="0.7"/><circle cx="50" cy="80" r="4" fill="#06b6d4" opacity="0.7"/><circle cx="60" cy="80" r="4" fill="#06b6d4" opacity="0.7"/>
  </svg>`,

  // Minimalist/Brevity - Two dots (√ó3 exactly 2 words)
  minimalist: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="mn-dot" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#06b6d4"/><stop offset="100%" stop-color="#0e7490"/></linearGradient>
      <radialGradient id="mn-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#mn-glow)"/>
    <circle cx="35" cy="65" r="15" fill="url(#mn-dot)"/>
    <ellipse cx="32" cy="60" rx="5" ry="4" fill="#fff" opacity="0.3"/>
    <circle cx="65" cy="65" r="15" fill="url(#mn-dot)"/>
    <ellipse cx="62" cy="60" rx="5" ry="4" fill="#fff" opacity="0.3"/>
  </svg>`,

  // Maximalist - Six-pointed burst (√ó2.5 for 6 slots)
  maximalist: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="mx-star" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#06b6d4"/><stop offset="100%" stop-color="#0e7490"/></linearGradient>
      <radialGradient id="mx-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#mx-glow)"/>
    <polygon points="50,25 55,55 85,55 60,75 70,105 50,85 30,105 40,75 15,55 45,55" fill="url(#mx-star)"/>
    <polygon points="50,35 53,58 75,58 56,72 64,95 50,78 36,95 44,72 25,58 47,58" fill="#fff" opacity="0.15"/>
    <circle cx="50" cy="65" r="10" fill="#0e7490"/>
    <circle cx="50" cy="65" r="6" fill="#06b6d4"/>
    <path d="M47 62 L50 58 L53 62 M47 68 L50 72 L53 68" fill="none" stroke="#fff" stroke-width="1.5" stroke-linecap="round"/>
  </svg>`,

  // Dual Spec - Split shield (√ó2 both hero elements)
  dual_spec: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="ds-left" x1="100%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#3b82f6"/><stop offset="100%" stop-color="#1e40af"/></linearGradient>
      <linearGradient id="ds-right" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#f97316"/><stop offset="100%" stop-color="#c2410c"/></linearGradient>
      <radialGradient id="ds-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#ds-glow)"/>
    <path d="M50 25 L25 45 L25 80 L50 105 L50 25" fill="url(#ds-left)"/>
    <path d="M50 25 L75 45 L75 80 L50 105 L50 25" fill="url(#ds-right)"/>
    <path d="M28 48 L28 75 L50 95" stroke="#fff" stroke-width="2" opacity="0.2" fill="none"/>
    <path d="M72 48 L72 75 L50 95" stroke="#fff" stroke-width="2" opacity="0.2" fill="none"/>
    <line x1="50" y1="25" x2="50" y2="105" stroke="#d4af37" stroke-width="3"/>
  </svg>`,

  // Monolith - Tall obelisk (√ó4 all T3 words)
  monolith: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="mo-stone" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#374151"/><stop offset="100%" stop-color="#111827"/></linearGradient>
      <radialGradient id="mo-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#mo-glow)"/>
    <path d="M50 15 L60 25 L60 105 L40 105 L40 25 Z" fill="url(#mo-stone)"/>
    <path d="M42 28 L42 100" stroke="#fff" stroke-width="2" opacity="0.1"/>
    <path d="M48 30 L48 98" stroke="#fff" stroke-width="1" opacity="0.08"/>
    <path d="M45 40 L55 40 M45 55 L55 55 M45 70 L55 70 M45 85 L55 85" stroke="#06b6d4" stroke-width="1" opacity="0.4"/>
    <ellipse cx="50" cy="22" rx="6" ry="3" fill="#9333ea" opacity="0.8"/>
  </svg>`,

  // Trinity - Celtic knot (√ó2.5 exactly 3 words)
  trinity: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="tr-knot" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#06b6d4"/><stop offset="100%" stop-color="#0e7490"/></linearGradient>
      <radialGradient id="tr-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#tr-glow)"/>
    <path d="M50 30 Q70 45 70 65 Q70 90 50 95 Q30 90 30 65 Q30 45 50 30" fill="none" stroke="url(#tr-knot)" stroke-width="5"/>
    <path d="M50 40 Q60 50 60 65 Q60 80 50 85 Q40 80 40 65 Q40 50 50 40" fill="none" stroke="url(#tr-knot)" stroke-width="4"/>
    <circle cx="50" cy="38" r="5" fill="url(#tr-knot)"/>
    <circle cx="35" cy="80" r="5" fill="url(#tr-knot)"/>
    <circle cx="65" cy="80" r="5" fill="url(#tr-knot)"/>
    <circle cx="50" cy="63" r="4" fill="#fff" opacity="0.6"/>
  </svg>`,

  // Glass Cannon - Crystal sword (√ó5 exactly 1 word)
  glass_cannon: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="gc-crystal" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#e0f2fe"/><stop offset="50%" stop-color="#7dd3fc"/><stop offset="100%" stop-color="#0284c7"/></linearGradient>
      <radialGradient id="gc-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#gc-glow)"/>
    <path d="M50 15 L58 25 L58 80 L50 90 L42 80 L42 25 Z" fill="url(#gc-crystal)"/>
    <path d="M50 15 L42 25 L50 30 L58 25 Z" fill="#fff" opacity="0.5"/>
    <path d="M50 30 L42 25 L42 80 L50 85 Z" fill="#0ea5e9" opacity="0.3"/>
    <line x1="50" y1="20" x2="50" y2="82" stroke="#fff" stroke-width="1" opacity="0.4"/>
    <rect x="40" y="90" width="20" height="6" rx="1" fill="#9ca3af"/>
    <rect x="44" y="96" width="12" height="12" rx="2" fill="#6b7280"/>
    <path d="M35 40 L30 35 M65 40 L70 35 M35 60 L28 58 M65 60 L72 58" stroke="#7dd3fc" stroke-width="2" opacity="0.5"/>
  </svg>`,

  // Focused Fire - Magnifying lens (√ó2.5 one strong element)
  focused_fire: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="ff-lens" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#e0f2fe"/><stop offset="100%" stop-color="#7dd3fc"/></linearGradient>
      <linearGradient id="ff-beam" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#fbbf24"/><stop offset="100%" stop-color="#f97316"/></linearGradient>
      <radialGradient id="ff-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#ff-glow)"/>
    <circle cx="50" cy="50" r="25" fill="url(#ff-lens)" opacity="0.3"/>
    <circle cx="50" cy="50" r="25" fill="none" stroke="#06b6d4" stroke-width="4"/>
    <circle cx="50" cy="50" r="20" fill="none" stroke="#0e7490" stroke-width="2"/>
    <ellipse cx="42" cy="42" rx="6" ry="5" fill="#fff" opacity="0.4"/>
    <path d="M50 75 L45 100 L50 95 L55 100 L50 75" fill="url(#ff-beam)"/>
    <circle cx="50" cy="98" r="6" fill="#f97316" opacity="0.6"/>
    <circle cx="50" cy="98" r="3" fill="#fbbf24"/>
  </svg>`,

  // Fortuna - Wheel of fortune (√ó2 at 100g)
  fortuna: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="fo-wheel" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#d4af37"/><stop offset="100%" stop-color="#92400e"/></linearGradient>
      <radialGradient id="fo-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#fo-glow)"/>
    <circle cx="50" cy="65" r="30" fill="none" stroke="url(#fo-wheel)" stroke-width="5"/>
    <circle cx="50" cy="65" r="22" fill="none" stroke="url(#fo-wheel)" stroke-width="2"/>
    <path d="M50 35 L50 95 M20 65 L80 65 M28 43 L72 87 M28 87 L72 43" stroke="url(#fo-wheel)" stroke-width="2"/>
    <circle cx="50" cy="65" r="8" fill="url(#fo-wheel)"/>
    <circle cx="50" cy="65" r="5" fill="#fbbf24"/>
    <circle cx="50" cy="65" r="2" fill="#92400e"/>
    <path d="M50 30 L55 38 L45 38 Z" fill="#dc2626"/>
  </svg>`,

  // Perfectionist - Flawless gem (√ó3 for 6 slots no resist)
  perfectionist: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="pe-gem" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#fff"/><stop offset="30%" stop-color="#e0f2fe"/><stop offset="100%" stop-color="#06b6d4"/></linearGradient>
      <radialGradient id="pe-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#pe-glow)"/>
    <path d="M50 25 L75 50 L65 95 L35 95 L25 50 Z" fill="url(#pe-gem)"/>
    <path d="M50 25 L25 50 L50 45 L75 50 Z" fill="#fff" opacity="0.5"/>
    <path d="M50 45 L25 50 L35 95 L50 80 Z" fill="#0891b2" opacity="0.2"/>
    <path d="M50 45 L75 50 L65 95 L50 80 Z" fill="#0e7490" opacity="0.15"/>
    <line x1="50" y1="25" x2="50" y2="80" stroke="#fff" stroke-width="1" opacity="0.4"/>
    <circle cx="50" cy="35" r="5" fill="#fff" opacity="0.7"/>
    <circle cx="38" cy="50" r="3" fill="#fff" opacity="0.4"/>
    <path d="M35 100 Q50 95 65 100" stroke="#22c55e" stroke-width="3" stroke-linecap="round"/>
    <circle cx="50" cy="100" r="3" fill="#22c55e"/>
  </svg>`,

  // Gemination - Twin gems (REREAD same tier)
  gemination: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="gm-gem" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#c084fc"/><stop offset="100%" stop-color="#7c3aed"/></linearGradient>
      <radialGradient id="gm-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#gm-glow)"/>
    <path d="M35 35 L48 50 L48 70 L35 85 L22 70 L22 50 Z" fill="url(#gm-gem)"/>
    <path d="M35 35 L22 50 L35 55 L48 50 Z" fill="#fff" opacity="0.3"/>
    <path d="M65 35 L78 50 L78 70 L65 85 L52 70 L52 50 Z" fill="url(#gm-gem)"/>
    <path d="M65 35 L52 50 L65 55 L78 50 Z" fill="#fff" opacity="0.3"/>
    <path d="M40 60 L50 65 L60 60" stroke="#06b6d4" stroke-width="2" stroke-dasharray="3,2"/>
    <path d="M35 95 L50 100 L65 95" stroke="#06b6d4" stroke-width="2"/>
  </svg>`,

  // Diacope - Echo waves (REREAD ALL for 4 elem family)
  diacope: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <radialGradient id="di-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#di-glow)"/>
    <circle cx="50" cy="65" r="8" fill="#06b6d4"/>
    <circle cx="50" cy="65" r="15" fill="none" stroke="#06b6d4" stroke-width="2.5" opacity="0.8"/>
    <circle cx="50" cy="65" r="23" fill="none" stroke="#06b6d4" stroke-width="2" opacity="0.6"/>
    <circle cx="50" cy="65" r="31" fill="none" stroke="#06b6d4" stroke-width="1.5" opacity="0.4"/>
    <circle cx="50" cy="65" r="39" fill="none" stroke="#06b6d4" stroke-width="1" opacity="0.2"/>
    <circle cx="50" cy="65" r="3" fill="#fff"/>
  </svg>`,

  // Resonance - Tuning fork (REREAD hero elements)
  resonance: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="rs-fork" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#9ca3af"/><stop offset="100%" stop-color="#4b5563"/></linearGradient>
      <radialGradient id="rs-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#rs-glow)"/>
    <path d="M35 30 L35 75 Q35 85 45 85 L45 110 L55 110 L55 85 Q65 85 65 75 L65 30" fill="none" stroke="url(#rs-fork)" stroke-width="6" stroke-linecap="round"/>
    <path d="M30 35 Q25 35 25 40 M70 35 Q75 35 75 40" stroke="#06b6d4" stroke-width="2" opacity="0.6"/>
    <path d="M28 45 Q20 48 20 55 M72 45 Q80 48 80 55" stroke="#06b6d4" stroke-width="1.5" opacity="0.4"/>
    <circle cx="35" cy="50" r="3" fill="#06b6d4" opacity="0.5"/>
    <circle cx="65" cy="50" r="3" fill="#06b6d4" opacity="0.5"/>
  </svg>`,

  // Execute - Guillotine blade (REREAD ALL at ‚â§15% HP)
  execute: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="ex-blade" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#dc2626"/><stop offset="50%" stop-color="#9ca3af"/><stop offset="100%" stop-color="#4b5563"/></linearGradient>
      <linearGradient id="ex-frame" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#78716c"/><stop offset="100%" stop-color="#44403c"/></linearGradient>
      <radialGradient id="ex-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#ex-glow)"/>
    <rect x="25" y="25" width="8" height="85" fill="url(#ex-frame)"/>
    <rect x="67" y="25" width="8" height="85" fill="url(#ex-frame)"/>
    <rect x="25" y="25" width="50" height="8" fill="url(#ex-frame)"/>
    <path d="M30 70 L70 70 L70 80 L50 95 L30 80 Z" fill="url(#ex-blade)"/>
    <path d="M32 72 L50 72 L50 88" stroke="#fff" stroke-width="1.5" opacity="0.3"/>
    <circle cx="50" cy="50" r="6" fill="none" stroke="#dc2626" stroke-width="2"/><line x1="46" y1="46" x2="54" y2="54" stroke="#dc2626" stroke-width="2"/>
  </svg>`,

  // Critical Mass - Nucleus (REREAD T3 words)
  critical_mass: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <radialGradient id="cm-core" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#22d3ee"/><stop offset="70%" stop-color="#06b6d4"/><stop offset="100%" stop-color="#0e7490"/></radialGradient>
      <radialGradient id="cm-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#cm-glow)"/>
    <circle cx="50" cy="65" r="15" fill="url(#cm-core)"/>
    <ellipse cx="50" cy="65" rx="30" ry="10" fill="none" stroke="#06b6d4" stroke-width="2" opacity="0.5"/>
    <ellipse cx="50" cy="65" rx="10" ry="30" fill="none" stroke="#06b6d4" stroke-width="2" opacity="0.5" transform="rotate(60 50 65)"/>
    <ellipse cx="50" cy="65" rx="10" ry="30" fill="none" stroke="#06b6d4" stroke-width="2" opacity="0.5" transform="rotate(-60 50 65)"/>
    <circle cx="50" cy="35" r="5" fill="#fbbf24"/>
    <circle cx="75" cy="75" r="5" fill="#a855f7"/>
    <circle cx="25" cy="75" r="5" fill="#22c55e"/>
    <circle cx="50" cy="65" r="5" fill="#9333ea"/>
  </svg>`,

  // Polysyndeton - Chain links (REREAD highest at 3+ elements)
  polysyndeton: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="po-link" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#06b6d4"/><stop offset="100%" stop-color="#0e7490"/></linearGradient>
      <radialGradient id="po-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#po-glow)"/>
    <ellipse cx="35" cy="45" rx="12" ry="8" fill="none" stroke="url(#po-link)" stroke-width="4"/>
    <ellipse cx="50" cy="65" rx="12" ry="8" fill="none" stroke="url(#po-link)" stroke-width="4"/>
    <ellipse cx="65" cy="85" rx="12" ry="8" fill="none" stroke="url(#po-link)" stroke-width="4"/>
    <path d="M43 48 L45 60 M55 70 L58 82" stroke="url(#po-link)" stroke-width="3"/>
    <circle cx="35" cy="100" r="4" fill="#dc2626"/><circle cx="50" cy="100" r="4" fill="#22c55e"/><circle cx="65" cy="100" r="4" fill="#3b82f6"/>
  </svg>`,

  // Anadiplosis - Step pattern (REREAD adjacent same element)
  anadiplosis: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="ad-step" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#06b6d4"/><stop offset="100%" stop-color="#0e7490"/></linearGradient>
      <radialGradient id="ad-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#ad-glow)"/>
    <rect x="20" y="75" width="20" height="20" rx="3" fill="url(#ad-step)"/>
    <rect x="40" y="55" width="20" height="40" rx="3" fill="url(#ad-step)"/>
    <rect x="60" y="35" width="20" height="60" rx="3" fill="url(#ad-step)"/>
    <path d="M30 72 L30 62 L50 62 L50 52 L70 52 L70 32" stroke="#fff" stroke-width="2" stroke-dasharray="4,3" opacity="0.5" fill="none"/>
    <circle cx="30" cy="85" r="4" fill="#f97316"/>
    <circle cx="50" cy="75" r="4" fill="#f97316"/>
    <circle cx="70" cy="55" r="4" fill="#f97316"/>
  </svg>`,

  // Chiasmus - X crossing (REREAD√ó2 if first/last same element)
  chiasmus: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="chi-line" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#06b6d4"/><stop offset="100%" stop-color="#0e7490"/></linearGradient>
      <radialGradient id="chi-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#chi-glow)"/>
    <line x1="25" y1="35" x2="75" y2="95" stroke="url(#chi-line)" stroke-width="6" stroke-linecap="round"/>
    <line x1="75" y1="35" x2="25" y2="95" stroke="url(#chi-line)" stroke-width="6" stroke-linecap="round"/>
    <circle cx="25" cy="35" r="8" fill="#f97316"/><ellipse cx="23" cy="33" rx="3" ry="2" fill="#fff" opacity="0.3"/>
    <circle cx="75" cy="35" r="8" fill="#3b82f6"/><ellipse cx="73" cy="33" rx="3" ry="2" fill="#fff" opacity="0.3"/>
    <circle cx="25" cy="95" r="8" fill="#3b82f6"/><ellipse cx="23" cy="93" rx="3" ry="2" fill="#fff" opacity="0.3"/>
    <circle cx="75" cy="95" r="8" fill="#f97316"/><ellipse cx="73" cy="93" rx="3" ry="2" fill="#fff" opacity="0.3"/>
    <circle cx="50" cy="65" r="10" fill="#0f172a"/>
    <path d="M46 62 L50 56 L54 62 M46 68 L50 74 L54 68" fill="none" stroke="#06b6d4" stroke-width="2" stroke-linecap="round"/>
  </svg>`,

  // Signature Style - Autograph flourish (weapon gains hero elements)
  signature_style: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="ss-ink" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#1e1b4b"/><stop offset="100%" stop-color="#312e81"/></linearGradient>
      <radialGradient id="ss-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#ss-glow)"/>
    <rect x="20" y="30" width="60" height="75" rx="3" fill="#fef3c7"/>
    <rect x="22" y="32" width="56" height="71" rx="2" fill="#fefce8"/>
    <path d="M30 55 Q40 45 50 55 Q60 65 70 55 Q75 50 72 60 Q68 75 55 80 Q45 82 35 78 Q25 72 30 60" fill="none" stroke="url(#ss-ink)" stroke-width="3" stroke-linecap="round"/>
    <path d="M60 82 Q65 90 75 88" stroke="url(#ss-ink)" stroke-width="2" stroke-linecap="round"/>
    <line x1="30" y1="92" x2="70" y2="92" stroke="#d4af37" stroke-width="2"/>
  </svg>`,

  // Hyperbole - Explosion burst (overkill carries √ó2)
  hyperbole: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="hy-burst" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#fbbf24"/><stop offset="50%" stop-color="#f97316"/><stop offset="100%" stop-color="#dc2626"/></linearGradient>
      <radialGradient id="hy-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#hy-glow)"/>
    <polygon points="50,25 55,50 80,45 60,60 85,75 55,70 50,100 45,70 15,75 40,60 20,45 45,50" fill="url(#hy-burst)"/>
    <circle cx="50" cy="62" r="12" fill="#fbbf24"/>
    <circle cx="50" cy="62" r="8" fill="#fff" opacity="0.4"/>
    <path d="M46 58 L50 54 L54 58 M46 66 L50 70 L54 66" fill="none" stroke="#dc2626" stroke-width="2" stroke-linecap="round"/>
  </svg>`,

  // Residual - Dripping residue (+W ‚Üí +AP converter)
  residual: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="re-drop" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#22c55e"/><stop offset="100%" stop-color="#15803d"/></linearGradient>
      <radialGradient id="re-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#06b6d4" stop-opacity="0.4"/><stop offset="100%" stop-color="#06b6d4" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="38" ry="45" fill="url(#re-glow)"/>
    <rect x="25" y="30" width="50" height="40" rx="5" fill="#374151"/>
    <rect x="27" y="32" width="46" height="36" rx="4" fill="#1f2937"/>
    <circle cx="50" cy="50" r="8" fill="#d4af37"/><path d="M46 48 L50 44 L54 48 M46 52 L50 56 L54 52" fill="none" stroke="#fff" stroke-width="1.5" stroke-linecap="round"/>
    <path d="M35 70 Q32 80 35 90 Q35 98 40 100" stroke="url(#re-drop)" stroke-width="4" fill="none" stroke-linecap="round"/>
    <ellipse cx="42" cy="102" rx="5" ry="4" fill="url(#re-drop)"/>
    <path d="M50 70 L50 85" stroke="url(#re-drop)" stroke-width="4" fill="none" stroke-linecap="round"/>
    <ellipse cx="50" cy="90" rx="4" ry="5" fill="url(#re-drop)"/>
    <path d="M65 70 Q68 78 65 88" stroke="url(#re-drop)" stroke-width="3" fill="none" stroke-linecap="round"/>
    <ellipse cx="65" cy="92" rx="3" ry="4" fill="url(#re-drop)"/>
    <path d="M35 112 L50 118 L65 112" stroke="#22c55e" stroke-width="3" stroke-linecap="round"/>
  </svg>`,

  // Default fallback icon
  default: `<svg viewBox="0 0 100 130" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <radialGradient id="df-glow" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#6b7280" stop-opacity="0.4"/><stop offset="100%" stop-color="#6b7280" stop-opacity="0"/></radialGradient>
    </defs>
    <ellipse cx="50" cy="65" rx="35" ry="40" fill="url(#df-glow)"/>
    <circle cx="50" cy="65" r="25" fill="none" stroke="#6b7280" stroke-width="2"/>
    <circle cx="50" cy="65" r="8" fill="#6b7280"/><circle cx="50" cy="65" r="4" fill="#9ca3af"/>
  </svg>`
};

// Helper function to get talent SVG by ID
function getTalentSVG(talentId) {
  return TALENT_SVG[talentId] || TALENT_SVG.default;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SKILL NODE SVG ICONS - Simple 20x20 icons for skill tree nodes
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const SKILL_NODE_SVG = {
  // Weapon slot bonus - crossed swords
  weaponAP: `<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
    <path d="M3 3 L14 14 M3 14 L7 14 L7 10 M17 17 L14 14 M3 3 L7 3 L7 7" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
    <path d="M17 3 L6 14 M17 3 L13 3 L13 7 M3 17 L6 14" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
  </svg>`,

  // Adjective slot bonus - sparkle/star
  adjAP: `<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
    <path d="M10 2 L10 18 M2 10 L18 10 M4 4 L16 16 M16 4 L4 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
    <circle cx="10" cy="10" r="2" fill="currentColor"/>
  </svg>`,

  // Noun slot bonus - open book
  nounAP: `<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
    <path d="M10 4 L10 17" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
    <path d="M10 4 Q6 3 3 5 L3 16 Q6 14 10 17" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M10 4 Q14 3 17 5 L17 16 Q14 14 10 17" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
  </svg>`,

  // Gem slot bonus - diamond
  gemAP: `<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
    <path d="M10 2 L17 7 L10 18 L3 7 Z" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>
    <path d="M3 7 L17 7 M7 7 L10 2 L13 7 M7 7 L10 18 L13 7" fill="none" stroke="currentColor" stroke-width="1" stroke-linejoin="round"/>
  </svg>`,

  // Starting gold bonus - coin stack
  startGold: `<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
    <ellipse cx="10" cy="14" rx="6" ry="3" fill="none" stroke="currentColor" stroke-width="1.5"/>
    <path d="M4 14 L4 11 Q4 8 10 8 Q16 8 16 11 L16 14" fill="none" stroke="currentColor" stroke-width="1.5"/>
    <ellipse cx="10" cy="11" rx="6" ry="3" fill="none" stroke="currentColor" stroke-width="1.5"/>
    <path d="M4 11 L4 8 Q4 5 10 5 Q16 5 16 8 L16 11" fill="none" stroke="currentColor" stroke-width="1.5"/>
    <ellipse cx="10" cy="8" rx="6" ry="3" fill="none" stroke="currentColor" stroke-width="1.5"/>
  </svg>`,

  // Slash weapon bonus - single blade
  slashAP: `<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
    <path d="M15 2 L5 16 L6 17 L8 16 L16 4 Z" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>
    <path d="M5 16 L3 18 M6 17 L5 19" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
  </svg>`,

  // Pierce weapon bonus - arrow
  pierceAP: `<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
    <path d="M3 17 L17 3" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
    <path d="M17 3 L17 8 M17 3 L12 3" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
    <path d="M3 17 L6 14 L4 12 Z" fill="currentColor"/>
  </svg>`,

  // Blunt weapon bonus - hammer
  bluntAP: `<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
    <rect x="3" y="3" width="10" height="6" rx="1" fill="none" stroke="currentColor" stroke-width="1.5"/>
    <path d="M8 9 L8 17" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
  </svg>`,

  // Magic weapon bonus - wand with star
  magicAP: `<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
    <path d="M3 17 L14 6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
    <path d="M16 4 L16 2 M16 4 L18 4 M16 4 L14 4 M16 4 L16 6 M14.5 2.5 L17.5 5.5 M17.5 2.5 L14.5 5.5" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round"/>
  </svg>`,

  // Physical bonus - fist
  physAP: `<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
    <path d="M6 8 L6 13 Q6 16 10 16 L14 16 Q16 16 16 14 L16 9 Q16 7 14 7 L12 7 L12 5 Q12 4 11 4 L9 4 Q8 4 8 5 L8 8" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>
    <path d="M8 8 L6 8 Q4 8 4 10 L4 11" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
  </svg>`,

  // Fire bonus - flame
  fireAP: `<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
    <path d="M10 2 Q14 6 14 10 Q14 14 10 17 Q6 14 6 10 Q6 6 10 2" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>
    <path d="M10 8 Q12 10 12 12 Q12 14 10 15 Q8 14 8 12 Q8 10 10 8" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>
  </svg>`,

  // Water bonus - droplet
  waterAP: `<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
    <path d="M10 2 Q16 9 16 12 Q16 17 10 17 Q4 17 4 12 Q4 9 10 2" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>
    <path d="M7 12 Q7 14 10 14" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round"/>
  </svg>`,

  // Light bonus - sun rays
  lightAP: `<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
    <circle cx="10" cy="10" r="4" fill="none" stroke="currentColor" stroke-width="1.5"/>
    <path d="M10 2 L10 4 M10 16 L10 18 M2 10 L4 10 M16 10 L18 10 M4.3 4.3 L5.7 5.7 M14.3 14.3 L15.7 15.7 M15.7 4.3 L14.3 5.7 M5.7 14.3 L4.3 15.7" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
  </svg>`,

  // Dark bonus - crescent moon
  darkAP: `<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
    <path d="M14 4 Q9 5 9 10 Q9 15 14 16 Q10 18 6 14 Q3 10 6 6 Q10 2 14 4" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>
    <circle cx="15" cy="6" r="0.8" fill="currentColor"/>
    <circle cx="17" cy="9" r="0.5" fill="currentColor"/>
  </svg>`,

  // Earth bonus - mountain/rock
  earthAP: `<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
    <path d="M2 16 L7 6 L10 10 L13 5 L18 16 Z" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>
    <path d="M5 16 L8 11 L10 13" fill="none" stroke="currentColor" stroke-width="1" stroke-linejoin="round"/>
  </svg>`,

  // Lightning bonus - bolt
  lightningAP: `<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
    <path d="M12 2 L6 10 L10 10 L8 18 L14 10 L10 10 L12 2" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>
  </svg>`,

  // Poison bonus - skull drops
  poisonAP: `<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
    <circle cx="10" cy="8" r="5" fill="none" stroke="currentColor" stroke-width="1.5"/>
    <circle cx="8" cy="7" r="1.2" fill="currentColor"/>
    <circle cx="12" cy="7" r="1.2" fill="currentColor"/>
    <path d="M8 10 L8 12 M10 10 L10 13 M12 10 L12 12" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
    <path d="M7 16 Q7 18 8.5 18 Q10 18 10 16 Q10 18 11.5 18 Q13 18 13 16" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round"/>
  </svg>`,

  // Boss damage bonus - skull with crown
  bossAP: `<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
    <path d="M4 5 L6 7 L8 4 L10 7 L12 4 L14 7 L16 5 L16 8 L4 8 Z" fill="none" stroke="currentColor" stroke-width="1" stroke-linejoin="round"/>
    <circle cx="10" cy="12" r="5" fill="none" stroke="currentColor" stroke-width="1.5"/>
    <circle cx="8" cy="11" r="1" fill="currentColor"/>
    <circle cx="12" cy="11" r="1" fill="currentColor"/>
    <path d="M8 14 L12 14" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round"/>
  </svg>`,

  // Weakness exploit bonus - crosshair on target
  weaknessAP: `<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
    <circle cx="10" cy="10" r="6" fill="none" stroke="currentColor" stroke-width="1.5"/>
    <circle cx="10" cy="10" r="2" fill="currentColor"/>
    <path d="M10 2 L10 6 M10 14 L10 18 M2 10 L6 10 M14 10 L18 10" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
  </svg>`,

  // Capstone bonus - crown
  capstone: `<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
    <path d="M3 15 L3 8 L6 11 L10 5 L14 11 L17 8 L17 15 Z" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>
    <circle cx="3" cy="8" r="1.5" fill="currentColor"/>
    <circle cx="10" cy="5" r="1.5" fill="currentColor"/>
    <circle cx="17" cy="8" r="1.5" fill="currentColor"/>
  </svg>`,

  // Default - simple star
  default: `<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
    <path d="M10 2 L12 8 L18 8 L13 12 L15 18 L10 14 L5 18 L7 12 L2 8 L8 8 Z" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>
  </svg>`
};

// Helper function to get skill node SVG by bonus type
function getSkillNodeSVG(bonusType) {
  return SKILL_NODE_SVG[bonusType] || SKILL_NODE_SVG.default;
}

const BASE_COLORS={
  // Slash
  sword:"#7a8b99",
  greatsword:"#8a9baa",
  claymore:"#9aabbb",
  // Pierce
  bow:"#8B4513",
  longbow:"#9B5523",
  warbow:"#AB6533",
  // Magic
  wand:"#9966cc",
  staff:"#aa77dd",
  scepter:"#bb88ee",
  // Blunt
  mace:"#6a6a7a",
  warhammer:"#7a7a8a",
  maul:"#8a8a9a",
  stick:"#5a4a3a",
  hammer:"#86654b",
  dagger:"#7f7f7f",
  axe:"#7a4c30"
};

// Persistent storage keys for saves and lifetime stats
const SAVE_KEY="wordyweapon-save";
const STATS_KEY="wordyweapon-stats";

// Lifetime stats and achievement tracking. These values persist between runs.
let PStats={
  attempts:0,
  victories:0,
  weaponsForged:0,
  bestDamage:0,
  bestWeaponName:"",
  heroClears:{},
  highestRound:0,
  tutorialComplete:false,
  bossDefeats:{}, // Track which chapter bosses have been defeated {boss_id: true}
  unlockedHeroes: IS_DEMO ? ['Graham Moor', 'Quivera'] : ['Graham Moor'], // Demo has both heroes unlocked
  // Hero progression system
  heroXP:{}, // {heroName: xpAmount}
  heroLevel:{}, // {heroName: level}
  heroSkillPoints:{}, // {heroName: unspentPoints}
  heroSkills:{} // {heroName: {skillId: pointsAllocated}}
};

// === STATE ===
let S={
  difficulty:0, // 0=Normal, 1=Hard, 2=Nightmare
  wins:0,losses:0,streak:0,gold:30,
  hero:null,enemy:null,
  level:1, // Hero level (increments each battle)
  roundIndex:1, // Current round in the run
  floor:1, // Current floor (3 rounds per floor)
  nextEnemyData:null, // Cached preview enemy data (with randomized elements) for next round
  nextChapterBoss:null, // Pre-selected chapter boss for shop preview
  talents:[], // Active talents for this run
  talentLevels:{}, // Talent levels (key=talent ID, value=level starting at 1)
  consumables:[], // Owned consumables
  inv:[], // Word inventory
  sel:{item:null,adj1:null,adj2:null,adj3:null,adj4:null,noun1:null}, // Selected words: 1 weapon, 4 adjectives, 1 noun
  // Word currently selected from the bank awaiting assignment to a slot
  pendingWord:null,
  // Pre-rolled boss loot used to keep preview text and actual rewards in sync
  pendingBossLoot:null,
  rerollCost:5,
  sortMode:"type",
  // Sort direction for the forge inventory: true=ascending, false=descending
  sortAsc:true,
  shopSortMode:"type", // Sort mode for shop word bank
  shopSortAsc:true, // Sort direction for shop word bank: true=ascending, false=descending
  heroSelected:false, // Whether hero has been selected for this run
  shadowBonusHP:0, // For Shadow Pact talent
  battleHardenedBonus:0, // For Battle Hardened talent cap tracking
  quickStudyBonus:0, // For Quick Study talent cap tracking
  tempEffects:{}, // One-battle temporary modifiers
  lives:1, // Lives remaining (Paladin passive grants +1)
  // Talent tracking for adaptive talents
  usedWeaponTypes: new Set(), // Tracks unique weapon categories used (Jack of All Trades)
  usedWeapons: new Set(), // Tracks unique weapon names used (Adaptive Arsenal)
  uniqueWordsUsed: new Set(), // Tracks unique word IDs used (Anthology)
  bossesDefeated: 0, // Tracks bosses defeated (Bibliography)
  wordsSold: 0, // Tracks total words sold this run (Liquidation talent)
  elementWordsUsed: {}, // Tracks elemental words used by element (Elemental Windfall)
  carriedOverkill: 0, // Hyperbole talent: overkill damage √ó2 carries to next round
  // New talent tracking variables
  toolsUsed: 0, // Tracks Tools (consumables) used this run
  cratesOpened: 0, // Tracks crates purchased this run
  goldSpent: 0, // Tracks total gold spent this run
  rarityWordsUsed: 0, // Tracks rarity words (Common, Legendary, etc.) used this run
  tierWordsPlayed: {1:0, 2:0, 3:0}, // Tracks words played by tier this run
  toolUsedThisBattle: false, // Tracks if a tool was used in current battle
  // Chapter system (AP bump removed; retained for save compatibility)
  chapterAPBonus: 0,
  currentChapter: 0, // Tracks which chapter (0=rounds 1-9, 1=rounds 10-18, etc.)
  gamePhase: 'shop', // 'shop' or 'forge' - used for save/load restore point
  // Chapter boss tracking (unique bosses at round 9, 18, 27, etc.)
  foughtChapterBosses: [], // IDs of chapter bosses already fought (cycles when exhausted)
  chapterBoss: null, // Current chapter boss data (if fighting one)
  blockedSlot: null // Red Aktins: which slot is blocked for this fight
},audioOn=true;

// === STEAM INTEGRATION ===
// Maps in-game achievement conditions to Steam achievement IDs
// These IDs must match what's configured in Steamworks partner dashboard
const STEAM_ACHIEVEMENTS = {
  // Progression achievements
  FIRST_VICTORY: 'ACH_FIRST_VICTORY',
  WORDSMITH_MASTER: 'ACH_WORDSMITH_MASTER',
  ENDLESS_WARRIOR: 'ACH_ENDLESS_WARRIOR',
  BOSS_SLAYER: 'ACH_BOSS_SLAYER',
  // Difficulty achievements
  APPRENTICE_SMITH: 'ACH_APPRENTICE_SMITH',
  ADEPT_FORGER: 'ACH_ADEPT_FORGER',
  MASTER_BLACKSMITH: 'ACH_MASTER_BLACKSMITH',
  // Boss achievements
  BOSS_CINNA_ANTONY: 'ACH_BOSS_CINNA_ANTONY',
  BOSS_RED_AKTINS: 'ACH_BOSS_RED_AKTINS',
  BOSS_PLAGUE_DOCTOR: 'ACH_BOSS_PLAGUE_DOCTOR',
  BOSS_OXY: 'ACH_BOSS_OXY',
  BOSS_DOTDOTDOT: 'ACH_BOSS_DOTDOTDOT',
  BOSS_SILENT_KNIGHT: 'ACH_BOSS_SILENT_KNIGHT',
  // Hero achievements (one per hero clear)
  HERO_GRAHAM: 'ACH_HERO_GRAHAM',
  HERO_QUIVERA: 'ACH_HERO_QUIVERA',
  HERO_BELLE: 'ACH_HERO_BELLE',
  HERO_ALEXANDRIA: 'ACH_HERO_ALEXANDRIA',
  HERO_CAESURA: 'ACH_HERO_CAESURA',
  HERO_REED: 'ACH_HERO_REED',
  // Special achievements
  HOARDER: 'ACH_HOARDER',
  TREASURE_HUNTER: 'ACH_TREASURE_HUNTER',
  MINIMALIST: 'ACH_MINIMALIST'
};

// Unlock a Steam achievement (gracefully fails if Steam not available)
async function unlockSteamAchievement(achievementKey) {
  if (typeof window.steamAPI === 'undefined') return false;
  try {
    const steamId = STEAM_ACHIEVEMENTS[achievementKey];
    if (!steamId) {
      console.warn('Unknown achievement key:', achievementKey);
      return false;
    }
    return await window.steamAPI.unlockAchievement(steamId);
  } catch (e) {
    console.warn('Steam achievement unlock failed:', e);
    return false;
  }
}

// Check and unlock achievements based on current PStats
async function checkAndUnlockAchievements() {
  if (typeof window.steamAPI === 'undefined') return;
  const available = await window.steamAPI.isAvailable();
  if (!available) return;

  // First Victory
  if (PStats.victories >= 1) {
    unlockSteamAchievement('FIRST_VICTORY');
  }

  // Wordsmith Master (all 6 heroes cleared)
  const heroNames = ['Graham Moor', 'Quivera', 'Belle Lettres', 'Alexandria Constanza', 'Caesura', 'Reed'];
  const heroClears = PStats.heroClears || {};
  const clearedCount = heroNames.filter(h => heroClears[h]).length;
  if (clearedCount >= 6) {
    unlockSteamAchievement('WORDSMITH_MASTER');
  }

  // Endless Warrior (reach round 15)
  if ((PStats.highestRound || 0) >= 15) {
    unlockSteamAchievement('ENDLESS_WARRIOR');
  }

  // Difficulty clears
  const diffClears = PStats.difficultyClears || {};
  if (diffClears[0]) unlockSteamAchievement('APPRENTICE_SMITH');
  if (diffClears[1]) unlockSteamAchievement('ADEPT_FORGER');
  if (diffClears[2]) unlockSteamAchievement('MASTER_BLACKSMITH');

  // Boss defeats
  const bossDefeats = PStats.bossDefeats || {};
  if (bossDefeats['cinna_antony']) unlockSteamAchievement('BOSS_CINNA_ANTONY');
  if (bossDefeats['red_aktins']) unlockSteamAchievement('BOSS_RED_AKTINS');
  if (bossDefeats['plague_doctor']) unlockSteamAchievement('BOSS_PLAGUE_DOCTOR');
  if (bossDefeats['oxy']) unlockSteamAchievement('BOSS_OXY');
  if (bossDefeats['dotdotdot']) unlockSteamAchievement('BOSS_DOTDOTDOT');
  if (bossDefeats['silent_knight']) unlockSteamAchievement('BOSS_SILENT_KNIGHT');

  // Boss Slayer (all 5 main bosses)
  const mainBossCount = ['cinna_antony', 'red_aktins', 'plague_doctor', 'oxy', 'dotdotdot']
    .filter(id => bossDefeats[id]).length;
  if (mainBossCount >= 5) {
    unlockSteamAchievement('BOSS_SLAYER');
  }

  // Hero-specific clears
  if (heroClears['Graham Moor']) unlockSteamAchievement('HERO_GRAHAM');
  if (heroClears['Quivera']) unlockSteamAchievement('HERO_QUIVERA');
  if (heroClears['Belle Lettres']) unlockSteamAchievement('HERO_BELLE');
  if (heroClears['Alexandria Constanza']) unlockSteamAchievement('HERO_ALEXANDRIA');
  if (heroClears['Caesura']) unlockSteamAchievement('HERO_CAESURA');
  if (heroClears['Reed']) unlockSteamAchievement('HERO_REED');
}

// Check TREASURE_HUNTER achievement (1000+ gold in one run)
function checkTreasureHunterAchievement() {
  if (S.gold >= 1000) {
    unlockSteamAchievement('TREASURE_HUNTER');
  }
}

// Check HOARDER achievement (word bank full at 24)
function checkHoarderAchievement() {
  const visibleCount = S.inv ? S.inv.filter(w => !w.hiddenInBank).length : 0;
  if (visibleCount >= INV_LIMIT) {
    unlockSteamAchievement('HOARDER');
  }
}

// Steam Cloud save/load wrapper functions
async function steamCloudSaveStats() {
  if (typeof window.steamAPI === 'undefined') return false;
  try {
    const available = await window.steamAPI.isAvailable();
    if (!available) return false;
    return await window.steamAPI.cloudSave('wordyweapon-stats', PStats);
  } catch (e) {
    console.warn('Steam Cloud save failed:', e);
    return false;
  }
}

async function steamCloudSaveRun() {
  if (typeof window.steamAPI === 'undefined') return false;
  try {
    const available = await window.steamAPI.isAvailable();
    if (!available) return false;
    const saveData = {
      ...S,
      usedWeaponTypes: Array.from(S.usedWeaponTypes || []),
      usedWeapons: Array.from(S.usedWeapons || []),
      uniqueWordsUsed: Array.from(S.uniqueWordsUsed || [])
    };
    return await window.steamAPI.cloudSave('wordyweapon-save', saveData);
  } catch (e) {
    console.warn('Steam Cloud save failed:', e);
    return false;
  }
}

async function steamCloudLoadStats() {
  if (typeof window.steamAPI === 'undefined') return null;
  try {
    const available = await window.steamAPI.isAvailable();
    if (!available) return null;
    return await window.steamAPI.cloudLoad('wordyweapon-stats');
  } catch (e) {
    console.warn('Steam Cloud load failed:', e);
    return null;
  }
}

async function steamCloudLoadRun() {
  if (typeof window.steamAPI === 'undefined') return null;
  try {
    const available = await window.steamAPI.isAvailable();
    if (!available) return null;
    return await window.steamAPI.cloudLoad('wordyweapon-save');
  } catch (e) {
    console.warn('Steam Cloud load failed:', e);
    return null;
  }
}

function applyRunState(data){
  if(!data || !data.hero || !data.roundIndex) return false;
  // Convert Arrays back to Sets
  if(data.usedWeaponTypes) data.usedWeaponTypes = new Set(data.usedWeaponTypes);
  if(data.usedWeapons) data.usedWeapons = new Set(data.usedWeapons);
  if(data.uniqueWordsUsed) data.uniqueWordsUsed = new Set(data.uniqueWordsUsed);

  // Restore hero passive from HEROES array (passives are functions and can't be serialized)
  if(data.hero && data.hero.id){
    const heroTemplate = HEROES.find(h => h.id === data.hero.id);
    if(heroTemplate && heroTemplate.passive){
      data.hero.passive = heroTemplate.passive;
    }
  }

  S={...S,...data};

  // Recalculate skill tree bonuses (functions can't be serialized)
  if(S.hero && S.hero.name){
    initHeroSkills(S.hero.name);
    S.heroSkillBonuses = getHeroSkillBonuses(S.hero.name);
  }

  // Clear transient state that shouldn't persist across sessions
  S.nextEnemyData = null;
  S.belleRandomWeaknesses = null;
  S.nextEnemyBonusWeaknesses = null;

  // Default gamePhase to 'shop' for older saves that don't have it
  // This ensures players always restore to a clean shop state
  if(!S.gamePhase) S.gamePhase = 'shop';

  // Clear forge selections - player should start fresh at shop or round start
  // Don't restore mid-forge state as it creates a poor experience
  S.sel = {item:null, adj1:null, adj2:null, adj3:null, adj4:null, noun1:null};
  S.pendingWord = null;

  return true;
}

function loadStats(){
  try{
    const raw=localStorage.getItem(STATS_KEY);
    if(raw){
      PStats={...PStats,...JSON.parse(raw)};
    }
  }catch(e){console.warn("Failed to load stats",e);}
}

// Async version that tries Steam Cloud first, falls back to localStorage
async function loadStatsAsync(){
  try{
    // Try Steam Cloud first
    const cloudData = await steamCloudLoadStats();
    if(cloudData){
      // Merge cloud data with local (cloud takes precedence for newer data)
      const localRaw = localStorage.getItem(STATS_KEY);
      const localData = localRaw ? JSON.parse(localRaw) : {};
      // Use whichever has more victories/progress as the "newer" save
      if((cloudData.victories || 0) >= (localData.victories || 0)){
        PStats = {...PStats, ...cloudData};
      } else {
        PStats = {...PStats, ...localData};
      }
    } else {
      loadStats();
    }
  }catch(e){
    console.warn("Failed to load stats async",e);
    loadStats();
  }

  // Sync any already-earned achievements up to Steam when available
  try{
    await checkAndUnlockAchievements();
  }catch(e){
    console.warn("Failed to sync achievements after load",e);
  }
}

function saveStats(){
  try{
    localStorage.setItem(STATS_KEY,JSON.stringify(PStats));
    // Also save to Steam Cloud (fire and forget)
    steamCloudSaveStats();
    // Check for achievement unlocks
    checkAndUnlockAchievements();
  }catch(e){console.warn("Failed to save stats",e);}
}

function saveRun(){
  try{
    // Convert Sets to Arrays for serialization
    const saveData = {
      ...S,
      usedWeaponTypes: Array.from(S.usedWeaponTypes || []),
      usedWeapons: Array.from(S.usedWeapons || []),
      uniqueWordsUsed: Array.from(S.uniqueWordsUsed || [])
    };
    localStorage.setItem(SAVE_KEY,JSON.stringify(saveData));
    // Also save to Steam Cloud (fire and forget)
    steamCloudSaveRun();
  }catch(e){console.warn("Failed to save run",e);}finally{updateContinueButtons();}
}
function loadRun(){
  try{
    const raw=localStorage.getItem(SAVE_KEY);
    if(raw){
      const data=JSON.parse(raw);
      if(!data || !data.hero || !data.roundIndex){
        updateContinueButtons();
        return false;
      }
      const success = applyRunState(data);
      updateContinueButtons();
      return success;
    }
  }catch(e){console.warn("Failed to load run",e);}return false;
}

// Async version that tries Steam Cloud first, falls back to localStorage
async function loadRunAsync(){
  try{
    const [cloudData, localRaw] = await Promise.all([
      steamCloudLoadRun(),
      Promise.resolve(localStorage.getItem(SAVE_KEY))
    ]);
    const localData = localRaw ? JSON.parse(localRaw) : null;
    const validCloud = cloudData && cloudData.hero && cloudData.roundIndex;
    const validLocal = localData && localData.hero && localData.roundIndex;

    let chosen = null;
    if(validCloud && validLocal){
      const cloudRound = cloudData.roundIndex || 0;
      const localRound = localData.roundIndex || 0;
      chosen = cloudRound >= localRound ? cloudData : localData;
    } else {
      chosen = validCloud ? cloudData : (validLocal ? localData : null);
    }

    if(chosen){
      let serialized = null;
      try{
        serialized = JSON.stringify(chosen);
      }catch(e){
        console.warn("Failed to serialize chosen run for local cache",e);
      }
      const success = applyRunState(chosen);
      if(success && serialized){
        try{
          localStorage.setItem(SAVE_KEY, serialized);
        }catch(e){
          console.warn("Failed to cache cloud run locally",e);
        }
      }
      updateContinueButtons();
      return success;
    }
  }catch(e){
    console.warn("Failed to load run async",e);
  }
  updateContinueButtons();
  return false;
}
function clearRunSave(){
  try{localStorage.removeItem(SAVE_KEY);}catch(e){console.warn("Failed to clear save",e);}
  // Best-effort cloud wipe so old runs don't resurrect from Steam Cloud
  if(typeof window !== 'undefined' && window.steamAPI && window.steamAPI.cloudSave){
    try{
      window.steamAPI.cloudSave('wordyweapon-save', { cleared: true, ts: Date.now() });
    }catch(e){
      console.warn("Failed to clear Steam Cloud save",e);
    }
  }
  updateContinueButtons();
}

function hasSavedRun(){
  try{return !!localStorage.getItem(SAVE_KEY);}catch(e){return false;}
}

function updateContinueButtons(){
  const contBtn=document.getElementById('continue-btn');
  if(contBtn){
    contBtn.style.display = hasSavedRun()? 'block' : 'none';
  }
}

// Clear run state when abandoning a run mid-game
function clearRunState() {
  S.roundIndex = 0;
  S.heroSelected = false;
  S.hero = null;
  S.enemy = null;
  S.talents = [];
  S.talentLevels = {};
  S.inv = [];
  S.sel = {item:null,adj1:null,adj2:null,adj3:null,adj4:null,noun1:null};
  S.consumables = [];
  S.tempEffects = {};
  S.chapterBoss = null;
  S.blockedSlot = null;
  S.currentChapter = 0;
  S.gamePhase = 'shop';
}

function showMainMenu(keepMusic = false){
  const overlays=['shop-overlay','pause-menu','hero-select-overlay','combat-overlay','talent-overlay','achievements-overlay','victory-overlay','chapter-celebration-overlay','round-intro-overlay'];
  overlays.forEach(id=>{
    const el=document.getElementById(id);
    if(el) el.classList.remove('show');
  });

  // Clear the forge scene completely to save resources
  const forge=document.getElementById('forge');
  if(forge) forge.style.display='none';

  // Hide battle-view explicitly (CSS :has() may have timing issues)
  const battleView=document.getElementById('battle-view');
  if(battleView) battleView.style.display='none';

  // Hide combat result box
  const resultBox=document.getElementById('result-box');
  if(resultBox) resultBox.style.display='none';

  // Hide pause/sound buttons when showing main menu (prevents overlap)
  const pauseBtn = document.getElementById('pause-btn');
  const soundBtn = document.getElementById('sound-btn');
  if(pauseBtn) pauseBtn.style.display = 'none';
  if(soundBtn) soundBtn.style.display = 'none';

  // Hide header during main menu
  const header = document.getElementById('header');
  if(header) header.style.display = 'none';

  // Hide word bank / inventory panel
  const wordBank = document.getElementById('word-bank');
  if(wordBank) wordBank.style.display = 'none';

  // Hide any toast overlays
  const toastOverlay = document.getElementById('toast-overlay');
  if(toastOverlay) toastOverlay.classList.remove('show');

  // Ensure spotlight tint is cleared when returning to main menu
  const spotlightTint = document.getElementById('spotlight-tint');
  if(spotlightTint) spotlightTint.classList.remove('show', 'full', 'crate');

  // Stop and reset music engine so it restarts fresh on next run (unless keepMusic is true)
  if (!keepMusic && musicEngine && musicEngine.playing) {
    musicEngine.stop();
    stopSlotBounce();
  }

  // Reset to Base Art (Red/Orange) for the Title Screen
  setFlameColor('battle');

  const mainMenu=document.getElementById('main-menu');
  if(mainMenu){
    showOverlay(mainMenu);
    mainMenu.focus?.();
  }

  // Update skill points badges
  updateSkillBadges();

  // Show pending hero unlock notification if any (skip in demo mode)
  if(S.pendingHeroUnlock && !IS_DEMO){
    const {hero, boss} = S.pendingHeroUnlock;
    S.pendingHeroUnlock = null; // Clear it
    setTimeout(() => {
      playSample('gem.ogg', 1.0);
      showToast('NEW HERO UNLOCKED!', `Defeated ${boss}!<br><span style="color:#4ade80;font-weight:bold">${hero}</span> is now playable.`, 'CONTINUE');
    }, 500);
  } else if(S.pendingHeroUnlock && IS_DEMO){
    S.pendingHeroUnlock = null; // Clear it silently in demo
  }
}

function showVictoryScreen(){
  const overlays=['shop-overlay','pause-menu','hero-select-overlay','combat-overlay','talent-overlay','achievements-overlay','main-menu'];
  overlays.forEach(id=>{
    const el=document.getElementById(id);
    if(el) el.classList.remove('show');
  });

  const currentRound = S.roundIndex - 1;
  if(!PStats.highestRound || currentRound > PStats.highestRound){
    PStats.highestRound = currentRound;
    saveStats();
  }

  // Award XP to hero for completing the run (with boss bonus)
  if (S.hero && S.hero.name) {
    const xpGained = calcRunXP(S.roundIndex, true); // true = defeated boss
    const result = awardHeroXP(S.hero.name, xpGained);
    S.lastRunXP = { xp: xpGained, ...result };
  }

  const heroName = document.getElementById('victory-hero-name');
  const dialogue = document.getElementById('victory-dialogue');
  const highestRound = document.getElementById('victory-highest-round');

  if(heroName) heroName.textContent = S.hero.name;
  if(dialogue) dialogue.textContent = `"${S.hero.victoryDialogue || 'Thank you, Wordsmith. We could not have done it without you.'}"`;
  if(highestRound) highestRound.textContent = `Highest Round Reached: ${PStats.highestRound}`;

  pulseFlame();
  burstSparks(window.innerWidth / 2, window.innerHeight / 2, 60, ['#ff9933', '#ffcc00', '#ffaa44'], true);

  if (musicEngine && musicEngine.initialized) {
    musicEngine.triggerVictoryEffect();
  }

  const victoryOverlay = document.getElementById('victory-overlay');
  if(victoryOverlay){
    victoryOverlay.classList.add('show');
    victoryOverlay.focus?.();
    if (sparkManager) {
      sparkManager.setColorMode('victory');
    }
  }
}

// === SKILL TREE UI ===
let skillTreeHeroIndex = 0;
const skillTreeHeroNames = ['Graham Moor', 'Quivera', 'Belle Lettres', 'Alexandria Constanza', 'Caesura', 'Reed'];

// Hero accent colors for skill tree
const HERO_COLORS = {
  'Graham Moor': { accent: '#6b8cae', accentDark: '#4a6a8a' },       // Steel blue
  'Quivera': { accent: '#4ade80', accentDark: '#22c55e' },           // Green
  'Belle Lettres': { accent: '#f97316', accentDark: '#ea580c' },     // Orange
  'Alexandria Constanza': { accent: '#fde047', accentDark: '#eab308' }, // Light yellow
  'Caesura': { accent: '#a855f7', accentDark: '#9333ea' },           // Purple
  'Reed': { accent: '#2dd4bf', accentDark: '#14b8a6' }               // Teal
};

function showSkillTree(heroName) {
  // Find hero index
  const idx = skillTreeHeroNames.indexOf(heroName);
  skillTreeHeroIndex = idx >= 0 ? idx : 0;

  renderSkillTree();
  document.getElementById('skill-tree-overlay').classList.add('show');
  playSfxOpen();
}

function closeSkillTree() {
  document.getElementById('skill-tree-overlay').classList.remove('show');
  playSfxBack();
}

// Skill tree zoom/pan state
let skillTreeZoom = 1.0;
let skillTreePanX = 0;
let skillTreePanY = 0;
const SKILL_TREE_ZOOM_MIN = 0.6;
const SKILL_TREE_ZOOM_MAX = 1.8;
const SKILL_TREE_ZOOM_STEP = 0.1;

function renderSkillTree() {
  const heroName = skillTreeHeroNames[skillTreeHeroIndex];
  const tree = SKILL_TREES[heroName];
  if (!tree) return;

  initHeroSkills(heroName);

  // Get hero color and apply to modal
  const heroColor = HERO_COLORS[heroName] || { accent: '#f5c15c', accentDark: '#d4a84a' };
  const modal = document.querySelector('.skill-tree-modal');
  modal.style.setProperty('--hero-accent', heroColor.accent);
  modal.style.setProperty('--hero-accent-dark', heroColor.accentDark);

  // Get hero ID for portrait
  const hero = HEROES.find(h => h.name === heroName);
  const heroId = hero ? hero.id : 'warrior';

  // Update portrait background
  let bgEl = modal.querySelector('.skill-tree-bg');
  if (!bgEl) {
    bgEl = document.createElement('div');
    bgEl.className = 'skill-tree-bg';
    modal.insertBefore(bgEl, modal.firstChild);
  }
  const portraitSvg = getPortraitSVG(heroId);
  bgEl.innerHTML = portraitSvg;

  // Update header
  document.getElementById('skill-tree-hero-name').textContent = heroName;
  document.getElementById('skill-tree-hero-name').style.color = heroColor.accent;
  const level = getHeroLevel(heroName);
  document.getElementById('skill-tree-hero-level').textContent = `Level ${level}`;

  // Update XP bar
  const xp = (PStats.heroXP && PStats.heroXP[heroName]) || 0;
  const progress = getXPProgress(heroName);
  const nextXP = getXPForNextLevel(heroName);
  document.getElementById('skill-tree-xp-fill').style.width = `${progress * 100}%`;
  if (nextXP) {
    const currentThreshold = HERO_XP_THRESHOLDS[level - 1];
    document.getElementById('skill-tree-xp-text').textContent = `${xp - currentThreshold} / ${nextXP - currentThreshold} XP`;
  } else {
    document.getElementById('skill-tree-xp-text').textContent = 'MAX LEVEL';
  }

  // Update skill points
  const points = PStats.heroSkillPoints[heroName] || 0;
  document.getElementById('skill-tree-points').textContent = `Skill Points: ${points}`;

  // Render tree nodes
  const container = document.getElementById('skill-tree-container');
  const nodes = tree.nodes;

  // Group by row
  const rows = {};
  nodes.forEach(node => {
    if (!rows[node.row]) rows[node.row] = [];
    rows[node.row].push(node);
  });

  // Build HTML - wrapper for zoom/pan
  let html = `
    <div class="skill-tree-zoom-controls">
      <button class="skill-tree-zoom-btn" id="skill-tree-zoom-out">‚àí</button>
      <span class="skill-tree-zoom-level" id="skill-tree-zoom-level">${Math.round(skillTreeZoom * 100)}%</span>
      <button class="skill-tree-zoom-btn" id="skill-tree-zoom-in">+</button>
      <button class="skill-tree-zoom-reset" id="skill-tree-zoom-reset">Reset</button>
    </div>
    <div class="skill-tree-viewport" id="skill-tree-viewport">
      <div class="skill-tree-grid" id="skill-tree-grid" style="transform: scale(${skillTreeZoom}) translate(${skillTreePanX}px, ${skillTreePanY}px); transform-origin: center top;">
  `;

  // Render rows 0-7 (expanded 8-row tree)
  for (let row = 0; row <= 7; row++) {
    const rowNodes = rows[row] || [];
    // Create 5-column row
    const cols = [null, null, null, null, null];
    rowNodes.forEach(node => {
      if (node.col >= 0 && node.col <= 4) {
        cols[node.col] = node;
      }
    });

    cols.forEach((node, col) => {
      if (node) {
        const allocated = getSkillPoints(heroName, node.id);
        const unlocked = isSkillUnlocked(heroName, node.id);
        const maxed = allocated >= node.maxPoints;

        let classes = 'skill-node has-tooltip';
        if (!unlocked) classes += ' locked';
        if (allocated > 0) classes += ' allocated';
        if (maxed) classes += ' maxed';
        if (node.type === 'major') classes += ' major';
        if (node.type === 'capstone') classes += ' capstone';

        // Get SVG icon based on bonus type
        let bonusType = node.bonusType;
        if (node.type === 'capstone') bonusType = 'capstone';
        const nodeIcon = getSkillNodeSVG(bonusType);

        html += `
          <div class="${classes}" data-skill="${node.id}" data-hero="${heroName}">
            <div class="skill-node-icon">${nodeIcon}</div>
            <div class="skill-node-name">${node.name}</div>
            <div class="skill-node-points">${allocated}/${node.maxPoints}</div>
            <div class="tooltip">
              <div style="font-weight:bold;margin-bottom:4px;color:${node.type === 'capstone' ? '#c084fc' : '#f5c15c'}">${node.name}</div>
              <div style="margin-bottom:6px;color:#d1d5db">${node.desc}</div>
              ${!unlocked ? '<div style="color:#ef4444;font-size:10px">Requires previous skills</div>' : ''}
              ${unlocked && !maxed && points > 0 ? '<div style="color:#4ade80;font-size:10px">Click to allocate</div>' : ''}
            </div>
          </div>
        `;
      } else {
        html += '<div class="skill-node-empty"></div>';
      }
    });
  }

  html += '</div></div>';
  container.innerHTML = html;

  // Draw connection lines after nodes are rendered
  requestAnimationFrame(() => {
    drawSkillTreeLines(heroName, nodes);
  });

  // Add click handlers for nodes
  container.querySelectorAll('.skill-node:not(.locked)').forEach(el => {
    el.onclick = () => {
      const skillId = el.dataset.skill;
      const hero = el.dataset.hero;
      if (allocateSkillPoint(hero, skillId)) {
        playSfxSkillUp();
        renderSkillTree();
      }
    };
    el.onmouseenter = sfxHover;
  });

  // Add zoom button handlers
  document.getElementById('skill-tree-zoom-in').onclick = () => {
    skillTreeZoom = Math.min(SKILL_TREE_ZOOM_MAX, skillTreeZoom + SKILL_TREE_ZOOM_STEP);
    updateSkillTreeTransform();
  };
  document.getElementById('skill-tree-zoom-out').onclick = () => {
    skillTreeZoom = Math.max(SKILL_TREE_ZOOM_MIN, skillTreeZoom - SKILL_TREE_ZOOM_STEP);
    updateSkillTreeTransform();
  };
  document.getElementById('skill-tree-zoom-reset').onclick = () => {
    skillTreeZoom = 1.0;
    skillTreePanX = 0;
    skillTreePanY = 0;
    updateSkillTreeTransform();
  };

  // Mouse wheel zoom on viewport
  const viewport = document.getElementById('skill-tree-viewport');
  const grid = document.getElementById('skill-tree-grid');

  viewport.onwheel = (e) => {
    e.preventDefault();
    const oldZoom = skillTreeZoom;
    if (e.deltaY < 0) {
      skillTreeZoom = Math.min(SKILL_TREE_ZOOM_MAX, skillTreeZoom + SKILL_TREE_ZOOM_STEP);
    } else {
      skillTreeZoom = Math.max(SKILL_TREE_ZOOM_MIN, skillTreeZoom - SKILL_TREE_ZOOM_STEP);
    }
    // Adjust pan to keep zoom centered
    if (oldZoom !== skillTreeZoom) {
      const zoomRatio = skillTreeZoom / oldZoom;
      skillTreePanX *= zoomRatio;
      skillTreePanY *= zoomRatio;
    }
    updateSkillTreeTransform();
  };

  // Drag to pan
  let isDragging = false;
  let dragStartX = 0;
  let dragStartY = 0;
  let panStartX = 0;
  let panStartY = 0;

  viewport.onmousedown = (e) => {
    // Only drag if clicking on viewport background, not on nodes
    if (e.target.closest('.skill-node')) return;
    isDragging = true;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    panStartX = skillTreePanX;
    panStartY = skillTreePanY;
    viewport.classList.add('dragging');
    e.preventDefault();
  };

  document.addEventListener('mousemove', skillTreeDragMove);
  document.addEventListener('mouseup', skillTreeDragEnd);

  function skillTreeDragMove(e) {
    if (!isDragging) return;
    const dx = (e.clientX - dragStartX) / skillTreeZoom;
    const dy = (e.clientY - dragStartY) / skillTreeZoom;
    skillTreePanX = panStartX + dx;
    skillTreePanY = panStartY + dy;
    updateSkillTreeTransform();
  }

  function skillTreeDragEnd() {
    if (!isDragging) return;
    isDragging = false;
    const vp = document.getElementById('skill-tree-viewport');
    if (vp) vp.classList.remove('dragging');
  }
}

// Update transform without full re-render
function updateSkillTreeTransform() {
  const grid = document.getElementById('skill-tree-grid');
  const zoomLabel = document.getElementById('skill-tree-zoom-level');
  if (grid) {
    grid.style.transform = `scale(${skillTreeZoom}) translate(${skillTreePanX}px, ${skillTreePanY}px)`;
  }
  if (zoomLabel) {
    zoomLabel.textContent = `${Math.round(skillTreeZoom * 100)}%`;
  }
  // Lines use offset positions and are inside the grid, so they scale automatically with zoom
}

function drawSkillTreeLines(heroName, nodes) {
  const heroColor = HERO_COLORS[heroName] || { accent: '#f5c15c' };
  const container = document.getElementById('skill-tree-container');
  const grid = container.querySelector('.skill-tree-grid');
  if (!grid) return;

  // Remove existing SVG
  const existingSvg = grid.querySelector('.skill-tree-lines');
  if (existingSvg) existingSvg.remove();

  // Create SVG overlay - inside grid so it scales with zoom
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.classList.add('skill-tree-lines');
  svg.style.position = 'absolute';
  svg.style.top = '0';
  svg.style.left = '0';
  svg.style.width = '100%';
  svg.style.height = '100%';
  svg.style.pointerEvents = 'none';
  svg.style.zIndex = '0';
  svg.style.overflow = 'visible';

  // Build node position map using offsetLeft/offsetTop (unaffected by transform)
  // Query all skill nodes once and build a Map for O(1) lookup
  const skillElements = new Map();
  grid.querySelectorAll('[data-skill]').forEach(el => {
    skillElements.set(el.dataset.skill, el);
  });

  const nodePositions = {};
  nodes.forEach(node => {
    const el = skillElements.get(node.id);
    if (el) {
      // Use offset position relative to grid - this is unaffected by CSS transforms
      nodePositions[node.id] = {
        x: el.offsetLeft + el.offsetWidth / 2,
        y: el.offsetTop + el.offsetHeight / 2
      };
    }
  });

  // Draw lines from each node to its requirements
  nodes.forEach(node => {
    if (!node.requires || node.requires.length === 0) return;
    const toPos = nodePositions[node.id];
    if (!toPos) return;

    node.requires.forEach(req => {
      const fromPos = nodePositions[req.id];
      if (!fromPos) return;

      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', fromPos.x);
      line.setAttribute('y1', fromPos.y);
      line.setAttribute('x2', toPos.x);
      line.setAttribute('y2', toPos.y);
      line.classList.add('skill-tree-line');

      // Check if this connection is "active" (both nodes have points)
      const fromAllocated = getSkillPoints(heroName, req.id) >= req.points;
      const toAllocated = getSkillPoints(heroName, node.id) > 0;
      if (fromAllocated && toAllocated) {
        line.classList.add('active');
        line.style.stroke = heroColor.accent;
      }

      svg.appendChild(line);
    });
  });

  grid.insertBefore(svg, grid.firstChild);
}

function setupSkillTreeListeners() {
  const backBtn = document.getElementById('skill-tree-back-btn');
  const nextBtn = document.getElementById('skill-tree-next-btn');
  const closeBtn = document.getElementById('skill-tree-close-btn');
  const respecBtn = document.getElementById('skill-tree-respec-btn');

  if (backBtn) {
    backBtn.onclick = () => {
      skillTreeHeroIndex = (skillTreeHeroIndex - 1 + skillTreeHeroNames.length) % skillTreeHeroNames.length;
      skillTreePanX = 0;
      skillTreePanY = 0;
      renderSkillTree();
      playSample('click.ogg', 0.4);
    };
    backBtn.onmouseenter = sfxHover;
  }

  if (nextBtn) {
    nextBtn.onclick = () => {
      skillTreeHeroIndex = (skillTreeHeroIndex + 1) % skillTreeHeroNames.length;
      skillTreePanX = 0;
      skillTreePanY = 0;
      renderSkillTree();
      playSample('click.ogg', 0.4);
    };
    nextBtn.onmouseenter = sfxHover;
  }

  if (closeBtn) {
    closeBtn.onclick = closeSkillTree;
    closeBtn.onmouseenter = sfxHover;
  }

  if (respecBtn) {
    respecBtn.onclick = () => {
      const heroName = skillTreeHeroNames[skillTreeHeroIndex];
      const refunded = respecHeroSkills(heroName);
      if (refunded > 0) {
        playSample('rarity.ogg', 0.5);
        renderSkillTree();
      }
    };
    respecBtn.onmouseenter = sfxHover;
  }
}

async function showChapterCelebration(chapterNum, goldBonus){
  // Hide all overlays and battle view so celebration appears on clean background
  const overlays=['shop-overlay','pause-menu','combat-overlay','talent-overlay','combat-result'];
  overlays.forEach(id=>{
    const el=document.getElementById(id);
    if(el) el.classList.remove('show');
  });
  // Also hide the battle view itself
  const battleView = document.getElementById('battle-view');
  if(battleView) battleView.classList.add('hidden');

  // Check if this is the run completion (Round 18 = roundIndex 19)
  const isRunCompleted = (S.roundIndex === 19);

  try {
    // Populate the chapter overlay
    const titleEl = document.getElementById('chapter-title');
    const goldEl = document.getElementById('chapter-gold-bonus');
    const goldWrapper = document.getElementById('chapter-gold-wrapper');
    const dialogueEl = document.getElementById('chapter-hero-dialogue');
    const continueBtn = document.getElementById('chapter-continue-btn');
    const mainMenuBtn = document.getElementById('chapter-mainmenu-btn');
    const portraitEl = document.getElementById('chapter-hero-portrait');
    const heroNameEl = document.getElementById('chapter-hero-name');
    const godRaysEl = document.getElementById('chapter-god-rays');
    const modalEl = document.querySelector('#chapter-overlay .chapter-modal');

    if(isRunCompleted){
      // Run Completed - personalized celebration with hero portrait
      if(titleEl) titleEl.textContent = 'RUN COMPLETED';

      // Show gold bonus for run completion too
      if(goldWrapper) goldWrapper.style.display = 'flex';
      if(goldEl) goldEl.textContent = `+${goldBonus}g`;

      // Show hero portrait
      if(portraitEl && S.hero){
        portraitEl.innerHTML = getPortraitSVG(S.hero.portrait || S.hero.name);
        portraitEl.classList.add('show');
      }

      // Show hero name
      if(heroNameEl && S.hero){
        heroNameEl.textContent = S.hero.name;
        heroNameEl.classList.add('show');
      }

      // Use hero's victory dialogue
      if(dialogueEl && S.hero && S.hero.victoryDialogue){
        dialogueEl.textContent = `"${S.hero.victoryDialogue}"`;
      } else if(dialogueEl){
        dialogueEl.textContent = '"Thank you, Wordsmith. We could not have done it without you."';
      }

      // Add rainbow effects
      if(godRaysEl) godRaysEl.classList.add('rainbow');
      if(modalEl) modalEl.classList.add('rainbow');

      // Rainbow celebration sparks!
      pulseFlame();
      burstSparks(window.innerWidth / 2, window.innerHeight / 2, 60, ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#54a0ff', '#5f27cd'], true);
      // Second wave of rainbow sparks for extra celebration
      setTimeout(() => {
        burstSparks(window.innerWidth / 2 - 100, window.innerHeight / 2, 40, ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#54a0ff', '#5f27cd'], true);
        burstSparks(window.innerWidth / 2 + 100, window.innerHeight / 2, 40, ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#54a0ff', '#5f27cd'], true);
      }, 300);

      // Show both buttons
      if(continueBtn) continueBtn.textContent = 'CONTINUE TO ENDLESS MODE';
      if(mainMenuBtn) mainMenuBtn.classList.add('show');

      // Trigger victory music effect
      if(musicEngine && musicEngine.initialized){
        musicEngine.triggerVictoryEffect();
      }
    } else {
      // Normal chapter complete
      if(titleEl) titleEl.textContent = `CHAPTER ${chapterNum} COMPLETE`;
      if(goldWrapper) goldWrapper.style.display = 'flex';
      if(goldEl) goldEl.textContent = `+${goldBonus}g`;

      // Hide hero portrait and name for normal chapter completion
      if(portraitEl) portraitEl.classList.remove('show');
      if(heroNameEl) heroNameEl.classList.remove('show');

      // Remove rainbow effects if previously set
      if(godRaysEl) godRaysEl.classList.remove('rainbow');
      if(modalEl) modalEl.classList.remove('rainbow');

      // Use hero's chapter dialogue
      if(dialogueEl && S.hero && S.hero.chapterDialogue){
        dialogueEl.textContent = `"${S.hero.chapterDialogue}"`;
      } else if(dialogueEl){
        dialogueEl.textContent = '';
      }

      // Orange/gold celebration sparks
      pulseFlame();
      burstSparks(window.innerWidth / 2, window.innerHeight / 2, 50, ['#ff9933', '#ffcc00', '#ffaa44'], true);

      // Show only continue button
      if(continueBtn) continueBtn.textContent = 'CONTINUE';
      if(mainMenuBtn) mainMenuBtn.classList.remove('show');
    }

    // Play celebration sound
    try { playSample('rarity.ogg', 0.7); } catch(e){}

    // Show the overlay - use rAF to ensure transition fires
    const overlay = document.getElementById('chapter-overlay');
    if(overlay){
      overlay.classList.remove('show');
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          overlay.classList.add('show');
          overlay.focus?.();
        });
      });
    }

    // Wait for user to click continue or main menu
    await new Promise((resolve) => {
      // Setup continue button
      if(continueBtn){
        continueBtn.onclick = async () => {
          if(isTransitioning) return;
          playSample('click.ogg', 0.8);
          // Unified transition: hide celebration AND show talent select at peak
          await playSceneTransition(() => {
            overlay.classList.remove('show');
            // Clean up rainbow classes and show states
            if(godRaysEl) godRaysEl.classList.remove('rainbow');
            if(modalEl) modalEl.classList.remove('rainbow');
            if(portraitEl) portraitEl.classList.remove('show');
            if(heroNameEl) heroNameEl.classList.remove('show');
            if(mainMenuBtn) mainMenuBtn.classList.remove('show');
          });
          // Go to talent select (chapter boss = true)
          await showTalentSelect(5, 2, true);
          resolve();
        };
        continueBtn.onmouseenter = sfxHover;
      }

      // Setup main menu button (only for run completion)
      if(mainMenuBtn){
        mainMenuBtn.onclick = async () => {
          if(isTransitioning) return;
          playSample('click.ogg', 0.8);
          // Unified transition: hide celebration AND show main menu at peak
          await playSceneTransition(() => {
            overlay.classList.remove('show');
            // Clean up rainbow classes and show states
            if(godRaysEl) godRaysEl.classList.remove('rainbow');
            if(modalEl) modalEl.classList.remove('rainbow');
            if(portraitEl) portraitEl.classList.remove('show');
            if(heroNameEl) heroNameEl.classList.remove('show');
            mainMenuBtn.classList.remove('show');
            // Go back to main menu
            clearRunState();
            showMainMenu();
          });
          resolve();
        };
        mainMenuBtn.onmouseenter = sfxHover;
      }
    });
  } catch(err) {
    console.error('[showChapterCelebration] ERROR:', err);
    // Fallback: just show talent select (chapter boss = true)
    await showTalentSelect(5, 2, true);
  }
}

function showLossScreen(heroName, roundReached, xpGained, leveledUp, newLevel){
  // Hide all overlays and battle view
  const overlays=['shop-overlay','pause-menu','combat-overlay','talent-overlay','combat-result'];
  overlays.forEach(id=>{
    const el=document.getElementById(id);
    if(el) el.classList.remove('show');
  });
  const battleView = document.getElementById('battle-view');
  if(battleView) battleView.classList.add('hidden');

  try {
    // Populate the loss overlay
    const roundEl = document.getElementById('loss-round');
    const heroEl = document.getElementById('loss-hero-name');
    const xpEl = document.getElementById('loss-xp-gained');
    const levelUpEl = document.getElementById('loss-level-up');
    const dialogueEl = document.getElementById('loss-defeat-dialogue');

    if(roundEl) roundEl.textContent = roundReached;
    if(heroEl) heroEl.textContent = heroName;
    if(xpEl) xpEl.textContent = `+${xpGained} XP`;

    // Add defeat dialogue from hero
    if(dialogueEl && S.hero && S.hero.defeatDialogue){
      dialogueEl.textContent = `"${S.hero.defeatDialogue}"`;
    } else if(dialogueEl){
      dialogueEl.textContent = '';
    }
    if(levelUpEl){
      if(leveledUp){
        levelUpEl.style.display = 'block';
        levelUpEl.textContent = `LEVEL UP! ‚Üí Level ${newLevel}`;
      } else {
        levelUpEl.style.display = 'none';
      }
    }

    // Show the overlay
    const overlay = document.getElementById('loss-overlay');
    if(overlay){
      overlay.classList.add('show');
      overlay.focus?.();
    }

    // Setup continue button
    const continueBtn = document.getElementById('loss-continue-btn');
    if(continueBtn){
      continueBtn.onclick = async () => {
        if(isTransitioning) return;
        playSample('click.ogg', 0.8);
        // Unified transition: hide loss screen AND show main menu at peak
        await playSceneTransition(() => {
          overlay.classList.remove('show');
          showMainMenu();
        });
      };
      continueBtn.onmouseenter = sfxHover;
    }
  } catch(err) {
    console.error('[showLossScreen] ERROR:', err);
    showMainMenu();
  }
}

// Execute forfeit - called after confirmation modal
function executeForfeit() {
  // Update stats
  S.losses++;
  S.streak = 0;
  S.heroSelected = false;
  clearRunSave();

  // Award XP to hero for this run (same as loss)
  let xpGained = 0;
  let leveledUp = false;
  let newLevel = 1;
  const heroName = S.hero?.name || 'Hero';
  if (S.hero && S.hero.name) {
    xpGained = calcRunXP(S.roundIndex, false);
    const result = awardHeroXP(S.hero.name, xpGained);
    leveledUp = result.leveledUp;
    newLevel = result.newLevel;
    S.lastRunXP = { xp: xpGained, ...result };
  }

  // Stop music/sfx
  stopAllRarityDrones();
  if (musicEngine && musicEngine.initialized) {
    musicEngine.triggerLoseEffect();
  }

  // Show loss screen
  clrSel();
  showLossScreen(heroName, S.roundIndex, xpGained, leveledUp, newLevel);
}

function renderStats(){
  const box=document.getElementById('stats-container');
  if(!box) return;

  const heroNames = ['Graham Moor', 'Quivera', 'Belle Lettres', 'Alexandria Constanza', 'Caesura', 'Reed'];
  const heroClears = PStats.heroClears || {};
  const clearedCount = heroNames.filter(h => heroClears[h]).length;

  // Boss defeats tracking
  const bossDefeats = PStats.bossDefeats || {};
  const bossCount = Object.keys(bossDefeats).length;
  const bosses = [
    { id: 'cinna_antony', name: 'Cinna & Antony', icon: icon('yinyang'), unlocks: 'Quivera' },
    { id: 'red_aktins', name: 'Red Aktins', icon: icon('scissors'), unlocks: 'Belle Lettres' },
    { id: 'plague_doctor', name: 'Plague Doctor', icon: icon('clipboard'), unlocks: 'Alexandria' },
    { id: 'oxy', name: 'Oxy', icon: icon('crossed-swords'), unlocks: 'Caesura' },
    { id: 'dotdotdot', name: 'Dotdotdot', icon: icon('ellipsis'), unlocks: 'Reed' },
    { id: 'silent_knight', name: 'The Silent Knight', icon: icon('shield'), unlocks: null, secret: true }
  ];

  // Win rate calculation
  const winRate = PStats.attempts > 0 ? Math.round((PStats.victories / PStats.attempts) * 100) : 0;

  // Best weapon display
  const bestWeaponName = PStats.bestWeaponName || 'None yet';
  const bestDamage = PStats.bestDamage || 0;

  box.innerHTML = `
    <!-- Left Column: Run Stats -->
    <div class="stats-section" style="--section-color:#60a5fa">
      <div class="stats-section-title">Run Statistics</div>
      <div class="stat-row">
        <span class="stat-label">Total Attempts</span>
        <span class="stat-value">${PStats.attempts}</span>
      </div>
      <div class="stat-row">
        <span class="stat-label">Victories (Round 9+)</span>
        <span class="stat-value highlight">${PStats.victories}</span>
      </div>
      <div class="stat-row">
        <span class="stat-label">Win Rate</span>
        <span class="stat-value">${winRate}%</span>
      </div>
      <div class="stat-row">
        <span class="stat-label">Highest Round</span>
        <span class="stat-value gold">${PStats.highestRound || 0}</span>
      </div>
      <div class="stat-row">
        <span class="stat-label">Weapons Forged</span>
        <span class="stat-value">${PStats.weaponsForged}</span>
      </div>
    </div>

    <!-- Right Column: Best Weapon -->
    <div class="stats-section" style="--section-color:#f4d03f">
      <div class="stats-section-title">Best Weapon</div>
      ${bestDamage > 0 ? `
        <div class="best-weapon-display">
          <div class="best-weapon-name">${bestWeaponName}</div>
          <div class="best-weapon-damage">${bestDamage} AP</div>
        </div>
      ` : `
        <div style="color:#6b7280;font-size:12px;text-align:center;padding:20px 0">Forge your first weapon to start tracking!</div>
      `}
    </div>

    <!-- Bottom Left: Hero Clears -->
    <div class="stats-section" style="--section-color:#4ade80">
      <div class="stats-section-title">Heroes Cleared (${clearedCount}/6)</div>
      <div class="hero-clears">
        ${heroNames.map(name => `
          <div class="hero-clear-badge ${heroClears[name] ? '' : 'locked'}">${name}</div>
        `).join('')}
      </div>
    </div>

    <!-- Bottom Right: Achievements -->
    <div class="stats-section" style="--section-color:#c084fc">
      <div class="stats-section-title">Achievements</div>
      <div class="achievement-grid">
        <div class="achievement-card ${PStats.victories >= 1 ? 'unlocked' : 'locked'}">
          <div class="achievement-icon">${icon('crossed-swords')}</div>
          <div class="achievement-info">
            <div class="achievement-name">First Victory</div>
            <div class="achievement-desc">Complete a run</div>
          </div>
        </div>
        <div class="achievement-card ${clearedCount >= 6 ? 'unlocked' : 'locked'}">
          <div class="achievement-icon">${icon('crown')}</div>
          <div class="achievement-info">
            <div class="achievement-name">Wordsmith Master</div>
            <div class="achievement-desc">Clear with all 6 heroes</div>
            ${clearedCount < 6 ? `<div class="achievement-progress">${clearedCount}/6</div>` : ''}
          </div>
        </div>
        <div class="achievement-card ${(PStats.highestRound || 0) >= 15 ? 'unlocked' : 'locked'}">
          <div class="achievement-icon">${icon('fire')}</div>
          <div class="achievement-info">
            <div class="achievement-name">Endless Warrior</div>
            <div class="achievement-desc">Reach Round 15</div>
            ${(PStats.highestRound || 0) < 15 ? `<div class="achievement-progress">Round ${PStats.highestRound || 0}/15</div>` : ''}
          </div>
        </div>
      </div>

      <!-- Difficulty Achievements -->
      <div class="stats-section-title" style="margin-top:16px">Difficulty Clears</div>
      <div class="achievement-grid">
        <div class="achievement-card ${(PStats.difficultyClears || {})[0] ? 'unlocked' : 'locked'}">
          <div class="achievement-icon" style="font-size:20px">üî®</div>
          <div class="achievement-info">
            <div class="achievement-name">Apprentice Smith</div>
            <div class="achievement-desc">Clear on Apprentice difficulty</div>
          </div>
        </div>
        <div class="achievement-card ${(PStats.difficultyClears || {})[1] ? 'unlocked' : 'locked'}">
          <div class="achievement-icon" style="font-size:20px">‚öíÔ∏è</div>
          <div class="achievement-info">
            <div class="achievement-name">Adept Forger</div>
            <div class="achievement-desc">Clear on Adept difficulty</div>
          </div>
        </div>
        <div class="achievement-card ${(PStats.difficultyClears || {})[2] ? 'unlocked' : 'locked'}">
          <div class="achievement-icon" style="font-size:20px">üî•</div>
          <div class="achievement-info">
            <div class="achievement-name">Master Blacksmith</div>
            <div class="achievement-desc">Clear on Master difficulty</div>
          </div>
        </div>
      </div>

      <!-- Boss Defeat Achievements -->
      <div class="stats-section-title" style="margin-top:16px">Chapter Bosses (${bossCount}/6)</div>
      <div class="achievement-grid">
        ${bosses.map(boss => `
          <div class="achievement-card ${bossDefeats[boss.id] ? 'unlocked' : 'locked'}">
            <div class="achievement-icon">${boss.icon}</div>
            <div class="achievement-info">
              <div class="achievement-name">${bossDefeats[boss.id] || !boss.secret ? boss.name : '???'}</div>
              <div class="achievement-desc">${boss.unlocks ? `Unlocks ${boss.unlocks}` : (boss.secret ? 'Secret Boss' : '')}</div>
            </div>
          </div>
        `).join('')}
        <div class="achievement-card ${bossCount >= 5 ? 'unlocked' : 'locked'}">
          <div class="achievement-icon">${icon('skull')}</div>
          <div class="achievement-info">
            <div class="achievement-name">Boss Slayer</div>
            <div class="achievement-desc">Defeat all 5 chapter bosses</div>
            ${bossCount < 5 ? `<div class="achievement-progress">${bossCount}/5</div>` : ''}
          </div>
        </div>
      </div>
    </div>
  `;
}

// === AUDIO ===
let audioCtx = null;
let masterGain = null;
let delayNode = null;
let delayGain = null;
const sampleCache = {};
let useClickAlt = false; // Track alternating click sounds

// Element to audio sample mapping
const ELEMENT_SAMPLES = {
  [E.FIRE]: 'fire-element.ogg',
  [E.WATER]: 'water-element.ogg',
  [E.LIGHTNING]: 'lightning-element.ogg',
  [E.LIGHT]: 'holy-element.ogg',
  [E.DARK]: 'dark-element.ogg',
  [E.EARTH]: 'earth-element.ogg',
  [E.POISON]: 'poison-element.ogg',
  [E.PHYS]: 'physical-element.ogg'
};

// Volume controls (0-1)
let volMaster = 1.0;
let volMusic = 0.8;
let volSfx = 1.0;

// Audio settings persistence
const AUDIO_SETTINGS_KEY = 'wordyweapon_audio';

function loadAudioSettings() {
  try {
    const saved = localStorage.getItem(AUDIO_SETTINGS_KEY);
    if (saved) {
      const settings = JSON.parse(saved);
      volMaster = settings.master ?? 1.0;
      volMusic = settings.music ?? 0.8;
      volSfx = settings.sfx ?? 1.0;
    }
  } catch (e) {
    console.warn('Failed to load audio settings', e);
  }
}

function saveAudioSettings() {
  try {
    localStorage.setItem(AUDIO_SETTINGS_KEY, JSON.stringify({
      master: volMaster,
      music: volMusic,
      sfx: volSfx
    }));
  } catch (e) {
    console.warn('Failed to save audio settings', e);
  }
}

function applyAudioSettings() {
  // Apply to audio system
  if (masterGain) masterGain.gain.value = volMaster;
  if (musicEngine && musicEngine.masterGain) {
    musicEngine.masterGain.gain.value = volMaster * volMusic;
  }
  // Update slider UI if visible
  const masterSlider = document.getElementById('vol-master');
  const musicSlider = document.getElementById('vol-music');
  const sfxSlider = document.getElementById('vol-sfx');
  if (masterSlider) {
    masterSlider.value = Math.round(volMaster * 100);
    const span = masterSlider.parentElement?.querySelector('.vol-value');
    if (span) span.textContent = masterSlider.value + '%';
  }
  if (musicSlider) {
    musicSlider.value = Math.round(volMusic * 100);
    const span = musicSlider.parentElement?.querySelector('.vol-value');
    if (span) span.textContent = musicSlider.value + '%';
  }
  if (sfxSlider) {
    sfxSlider.value = Math.round(volSfx * 100);
    const span = sfxSlider.parentElement?.querySelector('.vol-value');
    if (span) span.textContent = sfxSlider.value + '%';
  }
}

// Load audio settings on script load
loadAudioSettings();

// === IN-GAME TOAST NOTIFICATION SYSTEM ===

// Toast notification state
const TOAST_STATE = {
  container: null,
  activeToasts: [],
  nextId: 0
};

// Initialize toast container (called on page load)
function initToastContainer() {
  if (TOAST_STATE.container) return;

  // Create container if it doesn't exist
  let container = document.getElementById('toast-container');
  if (!container) {
    container = document.createElement('div');
    container.id = 'toast-container';
    // Append to game-container for proper scaling, fallback to body
    const gameContainer = document.getElementById('game-container');
    (gameContainer || document.body).appendChild(container);
  }
  TOAST_STATE.container = container;
}

// Helper: Calculate auto-dismiss duration based on word count
function calculateToastDuration(text) {
  const words = text.replace(/<[^>]*>/g, '').split(/\s+/).filter(w => w.length > 0).length;
  const baseTime = 2000; // 2 seconds minimum
  const wordTime = 500; // 500ms per word
  return Math.min(baseTime + (words * wordTime), 10000); // Max 10 seconds
}

// Helper: Get icon for toast type
function getToastIcon(type) {
  switch(type) {
    case 'success': return icon('sparkle');
    case 'error': return icon('skull');
    case 'warning': return icon('lightning');
    case 'info': return icon('coin');
    default: return icon('coin');
  }
}

// Remove a toast from the DOM
function removeToast(toastEl) {
  // Remove from active toasts array
  const id = parseInt(toastEl.dataset.toastId);
  TOAST_STATE.activeToasts = TOAST_STATE.activeToasts.filter(t => t.id !== id);

  // Animate out
  toastEl.classList.add('hiding');
  setTimeout(() => {
    if (toastEl.parentNode) {
      toastEl.parentNode.removeChild(toastEl);
    }
  }, RHYTHM.HALF);
}

// Main toast function - blocking toast with button
function showToast(title, msg, btnText = 'OK', onClose = null, type = 'info') {
  initToastContainer();

  const toastId = TOAST_STATE.nextId++;
  const toastEl = document.createElement('div');
  toastEl.className = `toast ${type}`;
  toastEl.dataset.toastId = toastId;

  // Build HTML
  const iconHtml = getToastIcon(type);
  toastEl.innerHTML = `
    <div class="toast-content">
      <div class="toast-icon">${iconHtml}</div>
      <div class="toast-body">
        ${title ? `<div class="toast-title">${title}</div>` : ''}
        <div class="toast-msg">${msg}</div>
        ${btnText ? `<button class="toast-btn">${btnText}</button>` : ''}
      </div>
    </div>
  `;

  // Add to container
  TOAST_STATE.container.appendChild(toastEl);
  TOAST_STATE.activeToasts.push({ id: toastId, element: toastEl });

  // Trigger entrance animation
  requestAnimationFrame(() => {
    toastEl.classList.add('show');
  });

  // Button click handler
  const btn = toastEl.querySelector('.toast-btn');
  if (btn) {
    btn.onclick = (e) => {
      e.stopPropagation();
      removeToast(toastEl);
      if (onClose) onClose();
    };
  }

  // Allow clicking anywhere on toast to dismiss
  toastEl.onclick = () => {
    if (btn) btn.click();
  };

  return toastEl;
}

// Chromatic aberration effect for specific word chip
function applyChromaticToWord(word, effectType, isSource = false) {
  // Find the word chip in the inventory by matching word name
  const chips = document.querySelectorAll('.chip');
  let targetChip = null;
  let firstMatch = null;

  // For source words (copy source), find the FIRST chip with matching name
  // For new words (generate/copy result), find the LAST chip with matching name
  chips.forEach(chip => {
    const nameEl = chip.querySelector('.chip-name');
    if(nameEl && nameEl.textContent === word.name){
      if(!firstMatch) firstMatch = chip;
      targetChip = chip;
    }
  });

  // For source word, use first match; for result word, use last match
  if(isSource && firstMatch) targetChip = firstMatch;

  if(!targetChip) return;

  // Add chromatic effect class based on effect type
  let effectClass;
  if(isSource && effectType === 'copy'){
    effectClass = 'chromatic-copy-source';
  } else {
    effectClass = effectType === 'transform' ? 'chromatic-transform' :
                  effectType === 'upgrade' ? 'chromatic-upgrade' :
                  effectType === 'copy' ? 'chromatic-copy' : 'chromatic-generate';
  }

  targetChip.classList.add('chromatic-word', effectClass);

  // Remove effect class after animation completes
  const duration = isSource ? 600 : 800;
  setTimeout(() => {
    targetChip.classList.remove('chromatic-word', effectClass);
  }, duration);
}

// Quick toast that auto-dismisses with progress bar
function showQuickToast(msg, duration = null, type = 'info') {
  initToastContainer();

  // Calculate duration based on word count if not specified
  if (!duration) {
    duration = calculateToastDuration(msg);
  }

  const toastId = TOAST_STATE.nextId++;
  const toastEl = document.createElement('div');
  toastEl.className = `toast ${type}`;
  toastEl.dataset.toastId = toastId;

  // Build HTML with progress bar
  const iconHtml = getToastIcon(type);
  toastEl.innerHTML = `
    <div class="toast-content">
      <div class="toast-icon">${iconHtml}</div>
      <div class="toast-body">
        <div class="toast-msg">${msg}</div>
      </div>
    </div>
    <div class="toast-progress" style="width: 100%"></div>
  `;

  // Add to container
  TOAST_STATE.container.appendChild(toastEl);
  TOAST_STATE.activeToasts.push({ id: toastId, element: toastEl });

  // Trigger entrance animation
  requestAnimationFrame(() => {
    toastEl.classList.add('show');

    // Start progress bar countdown
    const progressBar = toastEl.querySelector('.toast-progress');
    if (progressBar) {
      // Small delay before starting countdown for entrance animation
      setTimeout(() => {
        progressBar.style.transition = `width ${duration}ms linear`;
        progressBar.style.width = '0%';
      }, 100);
    }
  });

  // Click to dismiss
  toastEl.onclick = () => {
    if (dismissTimeout) clearTimeout(dismissTimeout);
    removeToast(toastEl);
  };

  // Auto-dismiss after duration
  const dismissTimeout = setTimeout(() => {
    removeToast(toastEl);
  }, duration + 100); // Add small buffer for progress bar animation

  return toastEl;
}

// Pre-warm expensive operations during splash screen
// This runs before the user clicks ENTER to reduce first-interaction stutter
function preWarmGame() {
  const warmStart = performance.now();

  // 1. Pre-create a hidden chip to warm up CSS/layout calculations
  const warmupContainer = document.createElement('div');
  warmupContainer.style.cssText = 'position:absolute;left:-9999px;visibility:hidden';
  document.body.appendChild(warmupContainer);

  // Create a few dummy chips to warm the browser's style calculator
  const dummyWord = { id: 'warmup', name: 'Warmup', type: 'elemental', elem: 0, rarity: 1 };
  for (let i = 0; i < 5; i++) {
    const chip = mkChip(dummyWord, false, false);
    warmupContainer.appendChild(chip);
  }

  // Force layout calculation
  void warmupContainer.offsetHeight;

  // Clean up
  warmupContainer.remove();

  // 2. Initialize bank state tracker
  _lastBankState = { hasItem: false, hasNoun: false };

  // 3. Pre-warm particle managers if they exist
  if (typeof sparkManager !== 'undefined' && sparkManager && sparkManager.init) {
    sparkManager.init();
  }
  if (typeof blacksmithEmberManager !== 'undefined' && blacksmithEmberManager && blacksmithEmberManager.init) {
    blacksmithEmberManager.init();
  }

}

// === REAL LOADING SCREEN ===
// Preload and decode all audio, warm all systems, then enable ENTER button
async function preloadAllSystems(onProgress) {
  const loadStart = performance.now();
  const tasks = [];
  let completed = 0;
  let total = 0;

  const updateProgress = (task) => {
    completed++;
    if (onProgress) onProgress(completed, total, task);
  };

  // === 1. Initialize particle managers ===
  if (!blacksmithEmberManager) {
    blacksmithEmberManager = new BlacksmithEmberManager();
    blacksmithEmberManager.init();
  }
  if (typeof sparkManager !== 'undefined' && sparkManager && sparkManager.init) {
    sparkManager.init();
  }

  // === 2. Pre-load HTML Audio samples ===
  const htmlAudioSamples = [
    'insert sword bow type.ogg', 'insert bow type.ogg', 'insert blunt.ogg',
    'insert wand sound.ogg', 'gem.ogg', 'rarity.ogg', 'highlight word.ogg',
    'click.ogg', 'click alt.ogg', 'buy_crate.ogg'
  ];
  htmlAudioSamples.forEach(name => {
    total++;
    tasks.push(
      loadSample(name)
        .then(() => updateProgress(`HTML Audio: ${name}`))
        .catch(() => updateProgress(`HTML Audio: ${name} (failed)`))
    );
  });

  // === 3. Pre-decode Web Audio buffers (for panned playback) ===
  // Only if not file:// protocol (fetch required)
  if (window.location.protocol !== 'file:') {
    // Create a temporary AudioContext for decoding (will be replaced by initAudio later)
    let tempCtx = null;
    try {
      tempCtx = new (window.AudioContext || window.webkitAudioContext)();
    } catch (e) {
      console.warn('[PRELOAD] Could not create AudioContext for pre-decoding');
    }

    if (tempCtx) {
      const webAudioSamples = [
        'insert sword bow type.ogg', 'insert bow type.ogg', 'insert blunt.ogg',
        'insert wand sound.ogg', 'gem.ogg', 'rarity.ogg', 'highlight word.ogg',
        'fire-element.ogg', 'water-element.ogg', 'lightning-element.ogg',
        'holy-element.ogg', 'dark-element.ogg', 'earth-element.ogg',
        'poison-element.ogg', 'physical-element.ogg'
      ];
      webAudioSamples.forEach(name => {
        total++;
        tasks.push(
          fetch(`sfx/${name}`)
            .then(r => r.arrayBuffer())
            .then(buf => tempCtx.decodeAudioData(buf))
            .then(decoded => {
              audioBufferCache[name] = decoded;
              updateProgress(`Web Audio: ${name}`);
            })
            .catch(() => updateProgress(`Web Audio: ${name} (failed)`))
        );
      });
    }
  }

  // === 4. Warm up CSS/animations + GPU layer promotion ===
  total++;
  tasks.push(new Promise(resolve => {
    // Create a container with multiple chips to warm GPU compositing layers
    const warmupContainer = document.createElement('div');
    warmupContainer.style.cssText = 'position:absolute;left:-9999px;opacity:0;pointer-events:none';
    document.body.appendChild(warmupContainer);

    // Create several chips with will-change to force GPU layer creation
    for (let i = 0; i < 5; i++) {
      const chip = document.createElement('div');
      chip.className = 'chip';
      chip.style.willChange = 'transform, opacity'; // Pre-promote to GPU layer
      chip.innerHTML = '<div class="chip-name">Warmup</div>';
      warmupContainer.appendChild(chip);
    }

    // Force layout calculation to ensure layers are created
    void warmupContainer.offsetHeight;

    // Run actual animations on these GPU-promoted chips
    const chips = warmupContainer.querySelectorAll('.chip');
    let animationsComplete = 0;
    chips.forEach((chip, i) => {
      chip.animate([
        { opacity: 0, transform: 'translateX(-20px) scale(0.8)' },
        { opacity: 1, transform: 'translateX(0) scale(1.05)' },
        { opacity: 1, transform: 'translateX(0) scale(1)' }
      ], { duration: 60, delay: i * 10, fill: 'forwards' }).onfinish = () => {
        animationsComplete++;
        if (animationsComplete === chips.length) {
          warmupContainer.remove();
          updateProgress('GPU layers + animations');
          resolve();
        }
      };
    });
  }));

  // === 5. Warm up chip creation ===
  total++;
  tasks.push(new Promise(resolve => {
    preWarmGame();
    updateProgress('Chip factory');
    resolve();
  }));

  // === 6. NUCLEAR OPTION: Run actual word placement flow hidden offscreen ===
  // This warms the ENTIRE code path: slot onclick, render(), FLIP, sparks, sounds - everything
  total++;
  tasks.push(new Promise(resolve => {
    // Create a hidden container that mimics the forge
    const hiddenForge = document.createElement('div');
    hiddenForge.id = 'warmup-forge';
    hiddenForge.style.cssText = 'position:fixed;left:-9999px;top:-9999px;opacity:0;pointer-events:none;width:1920px;height:1080px';
    hiddenForge.innerHTML = `
      <div id="warmup-bank" style="display:flex;gap:8px"></div>
      <div id="warmup-slots" style="display:flex;gap:8px">
        <div class="slot" data-slot="adj1"></div>
        <div class="slot" data-slot="item"></div>
        <div class="slot" data-slot="noun1"></div>
      </div>
    `;
    document.body.appendChild(hiddenForge);

    const warmupBank = hiddenForge.querySelector('#warmup-bank');
    const warmupSlots = hiddenForge.querySelectorAll('.slot');

    // Create real chips using mkChip
    const dummyWords = [
      { id: 'warmup1', name: 'Fiery', type: 'elemental', elem: 2, rarity: 1 },
      { id: 'warmup2', name: 'Sword', type: 'weapon', category: 'slash', rarity: 1 },
      { id: 'warmup3', name: 'Power', type: 'elemental', elem: 0, rarity: 1 }
    ];

    // Record positions for FLIP
    const warmupFlipPositions = new Map();
    dummyWords.forEach((w, i) => {
      const chip = mkChip(w, false, false);
      chip.dataset.wordId = w.id;
      chip.style.willChange = 'transform, opacity';
      warmupBank.appendChild(chip);
      const rect = chip.getBoundingClientRect();
      warmupFlipPositions.set(w.id, { left: rect.left, top: rect.top });
    });

    // Force layout
    void hiddenForge.offsetHeight;

    // Simulate placing a word - trigger the animations
    const chips = warmupBank.querySelectorAll('.chip');
    chips.forEach((chip, i) => {
      // Move chip to slot (simulates placement)
      warmupSlots[i]?.appendChild(chip);
    });

    // Run FLIP-style animations
    chips.forEach((chip, i) => {
      const oldPos = warmupFlipPositions.get(chip.dataset.wordId);
      if (oldPos) {
        const newRect = chip.getBoundingClientRect();
        const deltaX = oldPos.left - newRect.left;
        const deltaY = oldPos.top - newRect.top;

        chip.animate([
          { transform: `translate(${deltaX}px, ${deltaY}px)`, opacity: 1 },
          { transform: 'translate(0, 0)', opacity: 1 }
        ], { duration: 100, fill: 'forwards' });
      }
    });

    // Trigger a spark burst (hidden, silent)
    if (blacksmithEmberManager) {
      blacksmithEmberManager.burst(-9999, -9999, 5, ['#ff9933'], false);
    }

    // Clean up after animations complete
    setTimeout(() => {
      hiddenForge.remove();
      updateProgress('Full placement simulation');
      resolve();
    }, 150);
  }));

  // Wait for all tasks
  await Promise.all(tasks);

  const elapsed = performance.now() - loadStart;
  return elapsed;
}

// Called once when audio is first needed
function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  // Master gain
  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.8;

  // Short, subtle delay for sparkle
  delayNode = audioCtx.createDelay();
  delayNode.delayTime.value = 0.12; // short delay

  delayGain = audioCtx.createGain();
  delayGain.gain.value = 0.2; // low feedback

  delayNode.connect(delayGain);
  delayGain.connect(delayNode); // feedback loop

  // Route delay into master
  delayNode.connect(masterGain);

  // Connect master to destination
  masterGain.connect(audioCtx.destination);

  // Pre-initialize audio pools for rapid-fire sounds
  initAudioPool('click.ogg');
  initAudioPool('click alt.ogg');
  initHoverSoundPool();

  // Pre-warm Web Audio node types to avoid JIT compilation lag on first use
  // This creates the same node types used in playSamplePanned() and plays silence
  try {
    const warmupBuffer = audioCtx.createBuffer(1, 1, audioCtx.sampleRate);
    const warmupSource = audioCtx.createBufferSource();
    warmupSource.buffer = warmupBuffer;
    const warmupGain = audioCtx.createGain();
    warmupGain.gain.value = 0; // Silent
    const warmupPanner = audioCtx.createStereoPanner();
    warmupPanner.pan.value = 0;
    warmupSource.connect(warmupGain);
    warmupGain.connect(warmupPanner);
    warmupPanner.connect(audioCtx.destination);
    warmupSource.start();
    warmupSource.stop(audioCtx.currentTime + 0.001);
  } catch (e) {}

  // Pre-decode panned audio buffers (prevents first-word-placement lag)
  // These are used with stereo panning on word slot insertion
  const pannedSamples = [
    'insert sword bow type.ogg', 'insert bow type.ogg', 'insert blunt.ogg',
    'insert wand sound.ogg', 'gem.ogg', 'rarity.ogg', 'highlight word.ogg',
    // Element sounds (played with panning when elemental words placed)
    'fire-element.ogg', 'water-element.ogg', 'lightning-element.ogg',
    'holy-element.ogg', 'dark-element.ogg', 'earth-element.ogg',
    'poison-element.ogg', 'physical-element.ogg'
  ];
  pannedSamples.forEach(name => {
    if (!audioBufferCache[name] && window.location.protocol !== 'file:') {
      fetch(`sfx/${name}`)
        .then(r => r.arrayBuffer())
        .then(buf => audioCtx.decodeAudioData(buf))
        .then(decoded => { audioBufferCache[name] = decoded; })
        .catch(() => {});
    }
  });

  // Track mouse position for panned audio
  document.addEventListener('mousemove', (e) => {
    window.lastMouseX = e.clientX;
  });

  // Music engine initialization is now handled by initAudioOnGesture in bindEvents()
}

function playTone(freq, dur = 0.25, type = 'triangle', vol = 0.18) {
  if (!audioOn) return;
  if (!audioCtx) initAudio();

  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();

  osc.type = type;
  osc.frequency.value = freq;

  const now = audioCtx.currentTime;

  // Soft, natural envelope (fake a bit of "reverb tail")
  gain.gain.setValueAtTime(0.0001, now);
  gain.gain.exponentialRampToValueAtTime(vol, now + 0.02);          // attack
  gain.gain.exponentialRampToValueAtTime(vol * 0.6, now + dur*0.4); // decay
  gain.gain.exponentialRampToValueAtTime(0.0001, now + dur);        // release

  // Route through master and delay
  osc.connect(gain);
  gain.connect(masterGain); // dry
  gain.connect(delayNode);  // wet

  osc.start(now);
  osc.stop(now + dur + 0.05);
}

/**
 * Plays a brass/trumpet-like tone using multiple detuned sawtooth oscillators
 * Mimics the Tone.js leadmelody instrument (fatsawtooth with spread)
 */
function playBrassTone(freq, dur = 0.3, vol = 0.12) {
  if (!audioOn) return;
  if (!audioCtx) initAudio();

  const now = audioCtx.currentTime;
  const oscCount = 3;
  const spread = 15; // cents detune spread
  const oscillators = [];
  const gains = [];

  // Create multiple detuned sawtooth oscillators for "fat" brass sound
  for (let i = 0; i < oscCount; i++) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    osc.type = 'sawtooth';
    osc.frequency.value = freq;
    // Spread detuning: -spread, 0, +spread
    osc.detune.value = (i - 1) * spread;

    // Brass-like envelope: quick attack, sustain, longer release
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(vol / oscCount, now + 0.02); // fast attack
    gain.gain.setValueAtTime(vol / oscCount * 0.8, now + dur * 0.3); // sustain
    gain.gain.exponentialRampToValueAtTime(0.0001, now + dur + 0.4); // longer release tail

    osc.connect(gain);
    gain.connect(masterGain);
    gain.connect(delayNode); // reverb via delay

    osc.start(now);
    osc.stop(now + dur + 0.5);

    oscillators.push(osc);
    gains.push(gain);
  }
}

/**
 * Plays an "open" UI sound - subtle JRPG-style brass blip
 * Uses a short high brass note (B4 = 494Hz in E minor)
 */
function playSfxOpen() {
  // Short brass blip on B4 (494Hz) - bright but subtle
  playBrassTone(494, 0.08, 0.06);
}

/**
 * Plays a "back" UI sound - subtle JRPG-style brass blip
 * Uses a short lower brass note (E4 = 330Hz in E minor)
 */
function playSfxBack() {
  // Short brass blip on E4 (330Hz) - lower, resolving feel
  playBrassTone(330, 0.08, 0.05);
}

/**
 * Plays an "invalid" UI sound - dissonant for disabled/greyed out clicks
 * Uses D#4 (major 7th) which creates dissonance against E minor
 */
function playSfxInvalid() {
  // D#4 = 311.13Hz - major 7th creates "nope" dissonance in E minor
  playBrassTone(311.13, 0.06, 0.04);
}

/**
 * Plays a satisfying "skill up" sound - ascending chime arpeggio
 * Quick E5 -> B5 -> E6 arpeggio for that rewarding RPG level-up feel
 */
function playSfxSkillUp() {
  if (!audioOn) return;
  if (!audioCtx) initAudio();

  const now = audioCtx.currentTime;
  // Ascending perfect 5th + octave in E minor (E5 -> B5 -> E6)
  const notes = [659.25, 987.77, 1318.51]; // E5, B5, E6
  const spacing = 0.06; // Time between notes
  const vol = 0.08;

  notes.forEach((freq, i) => {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    osc.type = 'triangle'; // Softer, chime-like tone
    osc.frequency.value = freq;

    const startTime = now + i * spacing;
    // Quick bell-like envelope
    gain.gain.setValueAtTime(0.0001, startTime);
    gain.gain.exponentialRampToValueAtTime(vol, startTime + 0.01);
    gain.gain.exponentialRampToValueAtTime(vol * 0.6, startTime + 0.08);
    gain.gain.exponentialRampToValueAtTime(0.0001, startTime + 0.25);

    osc.connect(gain);
    gain.connect(masterGain);

    osc.start(startTime);
    osc.stop(startTime + 0.3);
  });
}

// COMMENTED OUT - Reverting to original simple tally ending
// Resolution tone for tally finale - plays the NEXT note in pentatonic scale
// Continues the ascending pattern by one more step for satisfying conclusion
/*
function playResolutionChord(lastToneIndex) {
  if (!audioOn) return;
  if (!audioCtx) initAudio();

  const now = audioCtx.currentTime;

  // Calculate next note in pentatonic scale after the last Shepard tone
  // Use the same logic as playShepardTone but for the next index
  const nextIndex = lastToneIndex + 1;
  const scaleIndex = nextIndex % MAGIC_SCALE_SEMITONES.length;
  const semitones = MAGIC_SCALE_SEMITONES[scaleIndex];

  // Calculate frequency using same base as Shepard tones
  const freq = MAGIC_BASE_FREQ * Math.pow(2, semitones / 12);

  const dur = 0.5;
  const vol = 0.25; // Strong and definitive

  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();

  // Use sawtooth for brass-like richness matching Shepard tone
  osc.type = 'sawtooth';
  osc.frequency.value = freq;

  // Volume envelope: quick attack, brief sustain, clean release
  gain.gain.setValueAtTime(0.0001, now);
  gain.gain.exponentialRampToValueAtTime(vol, now + 0.02);
  gain.gain.setValueAtTime(vol * 0.8, now + 0.15);
  gain.gain.exponentialRampToValueAtTime(0.0001, now + dur);

  osc.connect(gain);
  gain.connect(masterGain);

  osc.start(now);
  osc.stop(now + dur + 0.1);
}
*/

// Rarity drone stubs - feature disabled, kept for call site compatibility
function stopRarityDrone() {}
function stopAllRarityDrones() {}
function playRarityDrone() {}

// Magical pentatonic scale for tally sounds (brass trumpet style)
const MAGIC_SCALE_SEMITONES = [0, 3, 5, 7, 10]; // E minor pentatonic: E, G, A, B, D
const MAGIC_BASE_FREQ = 330; // E4 (matches song key)

function playMagicParseTone(i, totalWords, isRetrigger) {
  if (!audioOn) return;
  if (!audioCtx) initAudio();

  const scaleIndex = i % MAGIC_SCALE_SEMITONES.length;
  const octave = Math.floor(i / MAGIC_SCALE_SEMITONES.length);
  const semitones = MAGIC_SCALE_SEMITONES[scaleIndex] + octave * 12;

  const freq = MAGIC_BASE_FREQ * Math.pow(2, semitones / 12);

  // Slightly different dynamics for retriggers
  const dur = isRetrigger ? 0.35 : 0.28;
  const vol = isRetrigger ? 0.14 : 0.10;

  playBrassTone(freq, dur, vol);
}

// Shepard tone: infinitely rising sound effect using octave layering
// Creates illusion of endless ascent by fading between octave layers
function playShepardTone(triggerIndex, totalTriggers, isRetrigger) {
  if (!audioOn) return;
  if (!audioCtx) initAudio();

  // Use pentatonic scale for musicality
  const scaleIndex = triggerIndex % MAGIC_SCALE_SEMITONES.length;
  const semitones = MAGIC_SCALE_SEMITONES[scaleIndex];

  // Shepard tone: layer 3 octaves with volume envelope based on position
  // As pitch rises within an octave, fade it out while fading in the octave below
  const cyclePosition = (triggerIndex % 15) / 15; // 0-1 position in cycle (15 notes per full cycle)

  // Base frequency in middle octave (E4 = 330Hz)
  const baseFreq = MAGIC_BASE_FREQ * Math.pow(2, semitones / 12);

  // Duration and volume - boosted for prominence
  const dur = isRetrigger ? 0.35 : 0.30;
  const baseVol = isRetrigger ? 0.35 : 0.28;

  // Layer 3 octaves with Shepard envelope (bell curve centered on middle)
  const octaves = [-1, 0, 1]; // One octave below, middle, one above
  octaves.forEach(octOffset => {
    const freq = baseFreq * Math.pow(2, octOffset);

    // Shepard envelope: volume based on position in cycle + octave offset
    // Creates smooth crossfade between octaves
    const adjustedPos = cyclePosition + (octOffset + 1) / 3;
    const normalizedPos = adjustedPos % 1;

    // Bell curve envelope: loudest in middle, fades at extremes
    // Using cos^2 for smooth falloff
    const envelope = Math.pow(Math.cos((normalizedPos - 0.5) * Math.PI), 2);
    const vol = baseVol * envelope;

    if (vol > 0.01) { // Only play if audible
      playBrassTone(freq, dur, vol);
    }
  });
}

// Sample loader and cache (using Audio elements for file:// protocol compatibility)
function loadSample(name) {
  if (sampleCache[name]) return Promise.resolve(sampleCache[name]);

  return new Promise((resolve, reject) => {
    const audio = new Audio(`sfx/${name}`);
    audio.addEventListener('canplaythrough', () => {
      sampleCache[name] = audio;
      resolve(audio);
    }, {once: true});
    audio.addEventListener('error', (e) => {
      console.warn(`Failed to load sample: ${name}`, e);
      reject(e);
    });
    audio.load();
  });
}

// Audio pools for rapid-fire sounds that need to overlap
// Each pool contains 3 instances of the same sound, rotated round-robin
const audioPools = {};
const poolIndices = {};

function initAudioPool(name, poolSize = 3) {
  if (audioPools[name]) return; // Already initialized

  audioPools[name] = [];
  poolIndices[name] = 0;

  // Pre-load the sample and create pool instances
  loadSample(name).then(audio => {
    for (let i = 0; i < poolSize; i++) {
      const instance = audio.cloneNode();
      instance.preload = 'auto';
      audioPools[name].push(instance);
    }
  }).catch(() => {});
}

function playSamplePooled(name, vol = 0.9) {
  if (!audioOn) return;

  // Initialize pool if not already done
  if (!audioPools[name]) {
    initAudioPool(name);
    // Fall back to regular playSample while pool is initializing
    playSample(name, vol);
    return;
  }

  const pool = audioPools[name];
  if (pool.length === 0) {
    // Pool not ready yet, fall back
    playSample(name, vol);
    return;
  }

  // Get next instance in round-robin fashion
  const index = poolIndices[name];
  const audio = pool[index];
  poolIndices[name] = (index + 1) % pool.length;

  // Reset and play
  audio.currentTime = 0;
  audio.volume = vol * 0.8;
  audio.play().catch(e => console.warn('Pooled play failed:', e));
}

function playSample(name, vol = 0.9, pan = 0) {
  if (!audioOn) return;

  // If panning is requested and Web Audio API is available, use panned playback
  if (pan !== 0 && audioCtx) {
    playSamplePanned(name, vol, pan);
    return;
  }

  const play = (audio) => {
    if (!audio) return;
    const clone = audio.cloneNode();
    clone.volume = vol * 0.8; // Match masterGain volume
    clone.play().catch(e => console.warn('Play failed:', e));
  };

  if (sampleCache[name]) {
    play(sampleCache[name]);
  } else {
    loadSample(name).then(play).catch(() => {});
  }
}

// Cache for decoded audio buffers (for panned playback)
const audioBufferCache = {};

// Play sample with stereo panning using Web Audio API
async function playSamplePanned(name, vol = 0.9, pan = 0) {
  if (!audioOn || !audioCtx) return;

  // file:// protocol doesn't support fetch, fall back to HTML Audio
  if (window.location.protocol === 'file:') {
    const play = (audio) => {
      if (!audio) return;
      const clone = audio.cloneNode();
      clone.volume = vol * 0.8;
      clone.play().catch(() => {});
    };
    if (sampleCache[name]) {
      play(sampleCache[name]);
    } else {
      loadSample(name).then(play).catch(() => {});
    }
    return;
  }

  try {
    // Check if we have a cached buffer
    if (!audioBufferCache[name]) {
      // Fetch and decode the audio file
      const response = await fetch(`sfx/${name}`);
      const arrayBuffer = await response.arrayBuffer();
      audioBufferCache[name] = await audioCtx.decodeAudioData(arrayBuffer);
    }

    const buffer = audioBufferCache[name];
    if (!buffer) return;

    // Create source and connect through panner
    const source = audioCtx.createBufferSource();
    source.buffer = buffer;

    const gainNode = audioCtx.createGain();
    gainNode.gain.value = vol * 0.8;

    const pannerNode = audioCtx.createStereoPanner();
    pannerNode.pan.value = Math.max(-1, Math.min(1, pan));

    source.connect(gainNode);
    gainNode.connect(pannerNode);
    pannerNode.connect(audioCtx.destination);

    source.start();
  } catch (e) {
    // Fallback to regular playSample without pan (works with file:// protocol)
    console.warn('Panned playback failed, falling back:', e);
    const play = (audio) => {
      if (!audio) return;
      const clone = audio.cloneNode();
      clone.volume = vol * 0.8;
      clone.play().catch(() => {});
    };
    if (sampleCache[name]) {
      play(sampleCache[name]);
    } else {
      loadSample(name).then(play).catch(() => {});
    }
  }
}

// Play sample with reverb effect (delay-based) for physical element
async function playSampleWithReverb(name, vol = 0.9) {
  // file:// protocol doesn't support fetch, fall back to regular playback
  if (!audioOn || !audioCtx || window.location.protocol === 'file:') {
    playSample(name, vol);
    return;
  }
  try {
    if (!audioBufferCache[name]) {
      const response = await fetch(`sfx/${name}`);
      const arrayBuffer = await response.arrayBuffer();
      audioBufferCache[name] = await audioCtx.decodeAudioData(arrayBuffer);
    }
    const buffer = audioBufferCache[name];
    if (!buffer) return;

    // Dry signal
    const source = audioCtx.createBufferSource();
    source.buffer = buffer;
    const dryGain = audioCtx.createGain();
    dryGain.gain.value = vol * 0.7;
    source.connect(dryGain);
    dryGain.connect(audioCtx.destination);

    // Delay-based reverb taps
    const delays = [0.08, 0.16, 0.28, 0.42];
    const gains = [0.35, 0.25, 0.18, 0.12];
    delays.forEach((delayTime, i) => {
      const src = audioCtx.createBufferSource();
      src.buffer = buffer;
      const delay = audioCtx.createDelay();
      delay.delayTime.value = delayTime;
      const gain = audioCtx.createGain();
      gain.gain.value = vol * gains[i];
      src.connect(delay);
      delay.connect(gain);
      gain.connect(audioCtx.destination);
      src.start();
    });
    source.start();
  } catch (e) {
    playSample(name, vol);
  }
}

// Get pan value based on weapon slot position (-1 to 1)
function getSlotPan(slotKey) {
  const slotPanMap = {
    'adj1': -0.5,   // Far left (prefix 1)
    'adj2': -0.25,  // Slight left (prefix 2)
    'item': 0,      // Center (weapon)
    'adj3': 0.25,   // Slight right (suffix 1)
    'adj4': 0.5,    // Far right (suffix 2)
    'noun1': 0      // Center (gem)
  };
  return slotPanMap[slotKey] || 0;
}

// Get pan value from current mouse X position (-1 left to +1 right)
function getMousePan() {
  const x = window.lastMouseX || window.innerWidth / 2;
  return (x / window.innerWidth) * 2 - 1; // Map 0-width to -1 to +1
}

// Page flip sound with pitch-rising effect and pooled audio
let hoverPitchIndex = 0;
let lastHoverTime = 0;

// Pooled hover sound system - pre-create 3 buffer instances to avoid garbage collection
const hoverSoundPool = {
  buffers: [],
  currentIndex: 0,
  poolSize: 3,
  initialized: false
};

function initHoverSoundPool() {
  if (hoverSoundPool.initialized || !audioCtx) return;

  // Pre-generate 3 noise buffers
  const bufferSize = audioCtx.sampleRate * 0.08; // 80ms
  for (let p = 0; p < hoverSoundPool.poolSize; p++) {
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);

    for (let i = 0; i < bufferSize; i++) {
      // Filtered white noise that decays quickly
      data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.3));
    }

    hoverSoundPool.buffers.push(buffer);
  }

  hoverSoundPool.initialized = true;
}

// Track last mouse position for stereo panning
let lastMouseX = 0;
document.addEventListener('mousemove', (e) => { lastMouseX = e.clientX; });

function playPageFlipSound() {
  if (!audioOn) return;
  if (!audioCtx) initAudio();

  // Initialize pool on first use
  if (!hoverSoundPool.initialized) {
    initHoverSoundPool();
  }

  const now = audioCtx.currentTime;
  const currentTime = Date.now();

  // Reset pitch index if more than 0.5 seconds since last hover
  if (currentTime - lastHoverTime > 500) {
    hoverPitchIndex = 0;
  }
  lastHoverTime = currentTime;

  // Get buffer from pool (round-robin)
  const buffer = hoverSoundPool.buffers[hoverSoundPool.currentIndex];
  hoverSoundPool.currentIndex = (hoverSoundPool.currentIndex + 1) % hoverSoundPool.poolSize;

  const noise = audioCtx.createBufferSource();
  noise.buffer = buffer;

  // High-pass filter for papery sound - pitch rises with each hover
  const filter = audioCtx.createBiquadFilter();
  filter.type = 'highpass';
  // Start at 1200Hz and rise by 150Hz per hover (up to 5 hovers)
  const basePitch = 1200;
  const pitchIncrement = 150;
  const maxIndex = 5;
  const pitchIndex = Math.min(hoverPitchIndex, maxIndex);
  filter.frequency.value = basePitch + (pitchIndex * pitchIncrement);
  filter.Q.value = 1;

  // Increment pitch index for next hover
  hoverPitchIndex++;

  // Volume decreases as pitch rises (more natural - rapid hovers get quieter)
  // Start at 0.15, floor at 0.12, with slight random variation for natural feel
  const baseVolume = 0.15;
  const minVolume = 0.12;
  const volumeRange = baseVolume - minVolume; // 0.03
  const volumeReduction = (pitchIndex / maxIndex) * volumeRange;
  const randomVariation = (Math.random() - 0.5) * 0.02; // ¬±0.01 variation
  const peakVolume = Math.max(minVolume, baseVolume - volumeReduction + randomVariation);

  // Stereo panning based on mouse X position (-1 = left, 1 = right)
  const panner = audioCtx.createStereoPanner();
  const screenWidth = window.innerWidth || 1920;
  const panValue = ((lastMouseX / screenWidth) * 2 - 1) * 0.4; // -0.4 to 0.4 range (subtle)
  panner.pan.value = Math.max(-1, Math.min(1, panValue));

  // ADSR envelope - more natural with softer attack and longer decay
  const gain = audioCtx.createGain();
  const attackTime = 0.015 + (pitchIndex * 0.003); // Slightly longer attack as pitch rises
  const decayTime = 0.06 - (pitchIndex * 0.008); // Shorter decay as pitch rises (snappier)
  const totalDuration = attackTime + Math.max(decayTime, 0.03);

  gain.gain.setValueAtTime(0.0001, now);
  gain.gain.exponentialRampToValueAtTime(peakVolume, now + attackTime);
  gain.gain.exponentialRampToValueAtTime(peakVolume * 0.4, now + attackTime + (decayTime * 0.5)); // Sustain at 40%
  gain.gain.exponentialRampToValueAtTime(0.0001, now + totalDuration);

  noise.connect(filter);
  filter.connect(panner);
  panner.connect(gain);
  gain.connect(masterGain);

  noise.start(now);
  noise.stop(now + totalDuration + 0.02);
}
// === UI SOUND EFFECTS (E Minor Key) ===
// E minor scale: E=82/165/330/659, F#=92/185/370, G=98/196/392, A=110/220/440, B=123/247/494, D=147/294/587

function sfxHover(){playPageFlipSound()}
function sfxClick(){playTone(330,0.08,'sine',0.12);setTimeout(()=>playTone(494,0.12,'sine',0.1),RHYTHM.EIGHTH)}
function sfxWin(){[330,392,494,659].forEach((f,i)=>setTimeout(()=>playTone(f,0.4,'sine',0.25),i*RHYTHM.QUARTER))}
function sfxLose(){[330,294,247,165].forEach((f,i)=>setTimeout(()=>playTone(f,0.35,'sine',0.15),i*RHYTHM.HALF))}

// Talking sound for dialogue cycling - mimics Animal Crossing style "babble" using Tone.js
// E minor scale: E, F#, G, A, B, C, D
let talkSynth = null;
let talkPanner = null;

let currentDialogueSession = null;

function cancelDialogueSession() {
  if (!currentDialogueSession) return;
  currentDialogueSession.canceled = true;
  currentDialogueSession.timers.forEach(id => clearTimeout(id));
  currentDialogueSession.resolvers.forEach(res => {
    try { res(); } catch(e){}
  });
  currentDialogueSession.timers = [];
  currentDialogueSession.resolvers = [];
  currentDialogueSession = null;
}

function startDialogueSession() {
  cancelDialogueSession();
  currentDialogueSession = { canceled: false, timers: [], resolvers: [] };
  return currentDialogueSession;
}

function scheduleDialogueTimeout(session, fn, delay) {
  if (!session || session.canceled) return;
  const id = setTimeout(() => {
    cleanup();
    if (session.canceled) return;
    fn();
  }, delay);
  const cleanup = () => {
    session.timers = session.timers.filter(t => t !== id);
  };
  session.timers.push(id);
  return id;
}

function dialogueDelay(session, ms) {
  return new Promise(resolve => {
    if (!session || session.canceled) {
      resolve();
      return;
    }
    const id = setTimeout(() => {
      cleanup();
      if (!session.canceled) resolve();
    }, ms);
    const cleanup = () => {
      session.timers = session.timers.filter(t => t !== id);
      session.resolvers = session.resolvers.filter(r => r !== resolve);
    };
    session.timers.push(id);
    session.resolvers.push(resolve);
  });
}
function playTalkSound(type='hero'){
  if(!audioOn) return;
  // Initialize talk synth with panner if needed (uses Tone.js for consistent sound with music)
  if(typeof Tone !== 'undefined' && !talkSynth){
    try {
      talkPanner = new Tone.Panner(0).toDestination();
      talkSynth = new Tone.Synth({
        oscillator: { type: 'sine' },
        envelope: { attack: 0.01, decay: 0.08, sustain: 0.02, release: 0.05 }
      }).connect(talkPanner);
      talkSynth.volume.value = -12;
    } catch(e){ /* Tone.js not ready */ }
  }
  // Set pan: hero left (-0.7), enemy right (+0.7)
  if(talkPanner){
    talkPanner.pan.value = type === 'hero' ? -0.7 : 0.7;
  }
  // Hero has higher pitch (E4 range), enemy has lower pitch (E3 range) - E minor scale
  const notes = type === 'hero'
    ? ['E4', 'G4', 'A4', 'B4', 'D5']  // E minor pentatonic (high)
    : ['E3', 'G3', 'A3', 'B3', 'D4']; // E minor pentatonic (low)
  // Play 3-5 quick syllables
  const syllables = 3 + Math.floor(Math.random() * 3);
  const now = Tone.now ? Tone.now() : 0;
  for(let i = 0; i < syllables; i++){
    const note = notes[Math.floor(Math.random() * notes.length)];
    const time = now + (i * 0.07);
    if(talkSynth && talkSynth.triggerAttackRelease){
      try {
        talkSynth.triggerAttackRelease(note, '32n', time);
      } catch(e){ /* ignore timing errors */ }
    } else if(audioCtx){
      // Fallback to Web Audio API if Tone.js not available - E minor frequencies
      const pan = type === 'hero' ? -0.7 : 0.7;
      setTimeout(() => {
        const freqMap = {E3:165, G3:196, A3:220, B3:247, D4:294, E4:330, G4:392, A4:440, B4:494, D5:587};
        playTone(freqMap[note] || 330, 0.06, 'sine', 0.12, pan);
      }, i * 70);
    }
  }
}

// Stop talk sound immediately (for skipping dialogue)
function stopTalkSound() {
  if (talkSynth) {
    try {
      talkSynth.triggerRelease();
    } catch(e) { /* ignore */ }
  }
}

// Tier-based crate purchase tones (E minor key)
function sfxCrateTier(words) {
  if (!words || !words.length) {
    playSample('buy_crate.ogg', 0.9);
    return;
  }
  // Determine highest tier in the crate
  const highestRarity = Math.max(...words.map(w => w.rarity || 0));

  if (highestRarity >= 3) {
    // T3 (Rare/Epic/Legendary) - triumphant ascending E minor chord
    playTone(165, 0.15, 'sawtooth', 0.2); // E3
    setTimeout(() => playTone(247, 0.15, 'sawtooth', 0.18), RHYTHM.EIGHTH); // B3
    setTimeout(() => playTone(330, 0.2, 'sawtooth', 0.22), RHYTHM.QUARTER); // E4
    setTimeout(() => playTone(494, 0.3, 'sine', 0.25), RHYTHM.HALF); // B4 (sparkle)
  } else if (highestRarity >= 2) {
    // T2 (Uncommon/Magic) - pleasant two-tone
    playTone(247, 0.12, 'triangle', 0.18); // B3
    setTimeout(() => playTone(392, 0.18, 'triangle', 0.2), RHYTHM.QUARTER); // G4
  } else {
    // T1 (Common) - simple low thud
    playTone(165, 0.1, 'sine', 0.15); // E3
    setTimeout(() => playTone(196, 0.08, 'sine', 0.1), RHYTHM.EIGHTH); // G3
  }
}

// === MUSIC ENGINE (Loop-based) ===
const MUSIC_LOOPS = [
  'bass',
  'dark_counter',
  'earth_drum',
  'fire_r_guitar',
  'light_strings',
  'lightning_snare',
  'physical_main',
  'poison_percussion',
  'water_piano'
];
const MUSIC_LOOP_BARS = 16;
const MUSIC_LOOP_BPM = 136;
const ELEMENT_TO_LOOP = {
  [E.PHYS]: 'physical_main',
  [E.POISON]: 'poison_percussion',
  [E.FIRE]: 'fire_r_guitar',
  [E.WATER]: 'water_piano',
  [E.LIGHT]: 'light_strings',
  [E.DARK]: 'dark_counter',
  [E.EARTH]: 'earth_drum',
  [E.LIGHTNING]: 'lightning_snare'
};

// Safe wrapper for Tone.js rampTo to prevent RangeError from floating point precision
function safeRampTo(param, value, duration) {
  try {
    if (param && typeof param.rampTo === 'function') {
      // Ensure duration is never negative and at least a small positive value
      const safeDuration = Math.max(0.001, duration);
      param.rampTo(value, safeDuration);
    }
  } catch (e) {
    // If rampTo fails, try setting the value directly
    if (param && param.value !== undefined) {
      param.value = value;
    }
    // Silently ignore RangeErrors from floating point precision issues
    if (!e.message?.includes('Value must be within')) {
      console.warn('Tone.js rampTo error:', e);
    }
  }
}

// Simple volume fade helper for HTMLAudio fallback
function fadeHtmlAudio(audio, target, duration = 0.35) {
  if (!audio) return;
  const start = audio.volume;
  const delta = target - start;
  const startTime = performance.now();
  const durMs = Math.max(10, duration * 1000);

  const step = (now) => {
    const t = Math.min(1, (now - startTime) / durMs);
    audio.volume = Math.min(1, Math.max(0, start + delta * t));
    if (t < 1) requestAnimationFrame(step);
  };
  requestAnimationFrame(step);
}

class MusicEngine {
  constructor() {
    this.initialized = false;
    this.playing = false;
    this.loopKeys = MUSIC_LOOPS;
    this.masterGain = null;
    this.shopLowPass = null;
    this.shopHighPass = null;
    this.shopReverb = null;
    this.effectBus = null;
    this.players = {};
    this.gains = {};
    this.playersReady = null;
    this._starting = false;
    this.activeLoops = new Set();
    this._lastNeededKey = '';
    this._startTime = 0;
    // Shop mode state
    this.inShopMode = false;
    this.normalBpm = MUSIC_LOOP_BPM;
    // Check if we're in Electron with the preload bridge available
    this.isElectron = typeof window !== 'undefined' && window.electronAudio && window.electronAudio.isElectron;
    // Only use HTML fallback for file:// in regular browsers (not Electron)
    // Electron uses Tone.js with fetch-based loading (webSecurity: false enables this)
    this.useHtmlFallback = !this.isElectron && (typeof window !== 'undefined' && window.location && window.location.protocol === 'file:');
    this.entries = {}; // for fallback audio pairs
    this.desired = {};
  }

  getTargetGain() {
    const master = typeof volMaster === 'number' ? volMaster : 1;
    const music = typeof volMusic === 'number' ? volMusic : 0.8;
    return master * music;
  }

  async init() {
    if (this.initialized) return;

    // Note: Electron now uses local HTTP server, so standard Tone.js loading works
    // No special Electron handling needed

    if (this.useHtmlFallback) {
      const fallbackDuration = (60 / MUSIC_LOOP_BPM) * 4 * MUSIC_LOOP_BARS;
      this.loopKeys.forEach(key => {
        const makeAudio = () => {
          const a = new Audio(`sfx/loops/${key}.ogg`);
          a.loop = false;
          a.preload = 'auto';
          a.volume = 0;
          return a;
        };
        const a1 = makeAudio();
        const a2 = makeAudio();
        const entry = {
          audios: [a1, a2],
          active: 0,
          desired: key === 'bass' ? 0.9 : 0,
          timer: null,
          duration: fallbackDuration
        };
        const onMeta = () => {
          const d = a1.duration || a2.duration;
          if (d && d > 0) entry.duration = d;
        };
        a1.addEventListener('loadedmetadata', onMeta);
        a2.addEventListener('loadedmetadata', onMeta);
        this.entries[key] = entry;
      });
      this.initialized = true;
      return;
    }

    try {
      await Tone.start();

      // Create effect chain: Players -> Gains -> Filter -> MasterGain
      this.masterGain = new Tone.Gain(this.getTargetGain()).toDestination();
      this.shopLowPass = new Tone.Filter({ frequency: 20000, type: 'lowpass', rolloff: -24 }).connect(this.masterGain);
      this.shopHighPass = new Tone.Filter({ frequency: 20, type: 'highpass', rolloff: -24 }).connect(this.shopLowPass);

      // Skip reverb in Electron - Tone.Reverb.generate() uses OfflineAudioContext which may still crash
      if (this.isElectron) {
        this.shopReverb = null;
        this.effectBus = new Tone.Gain(1).connect(this.shopHighPass);
      } else {
        this.shopReverb = new Tone.Reverb({ decay: 1.2, wet: 0, preDelay: 0.02 });
        await this.shopReverb.generate();
        this.shopReverb.connect(this.shopHighPass);
        this.effectBus = new Tone.Gain(1).connect(this.shopReverb);
      }

      // Use Tone.Player with WAV files (sample-accurate looping, no OGG padding issues)
      const ext = 'wav';
      const folder = 'wav/';

      for (const key of this.loopKeys) {
        const url = `sfx/loops/${folder}${key}.${ext}`;

        const player = new Tone.Player({
          url: url,
          loop: true,
          autostart: false
        });

        const gain = new Tone.Gain(key === 'bass' ? 0.9 : 0).connect(this.effectBus);
        player.connect(gain);
        this.players[key] = player;
        this.gains[key] = gain;
      }

      // Wait for all to load
      this.playersReady = Tone.loaded();
      this.initialized = true;
    } catch (e) {
      // MusicEngine init failed silently
    }
  }

  startEntry(entry, volFactor) {
    if (!entry) return;
    const audio = entry.audios[entry.active];
    try { audio.currentTime = 0; } catch (e) {}
    audio.volume = (entry.desired || 0) * volFactor;
    audio.play().catch(() => {});
    this.scheduleCrossfade(entry, volFactor);
  }

  scheduleCrossfade(entry, volFactor) {
    if (!entry) return;
    if (entry.timer) clearTimeout(entry.timer);
    const dur = entry.duration || ((60 / MUSIC_LOOP_BPM) * 4 * MUSIC_LOOP_BARS);
    const leadMs = 10; // small crossfade window
    const wait = Math.max(50, dur * 1000 - leadMs);
    entry.timer = setTimeout(() => this.crossfadeEntry(entry, volFactor), wait);
  }

  crossfadeEntry(entry, volFactor) {
    const currentIdx = entry.active;
    const nextIdx = currentIdx === 0 ? 1 : 0;
    const cur = entry.audios[currentIdx];
    const nxt = entry.audios[nextIdx];
    try { nxt.currentTime = 0; } catch (e) {}
    nxt.volume = 0;
    nxt.play().catch(() => {});
    fadeHtmlAudio(nxt, (entry.desired || 0) * volFactor, 0.05);
    fadeHtmlAudio(cur, 0, 0.05);
    setTimeout(() => { try { cur.pause(); cur.currentTime = 0; } catch (e) {} }, RHYTHM.EIGHTH);
    entry.active = nextIdx;
    this.scheduleCrossfade(entry, volFactor);
  }

  async start() {
    if (this._starting) return;
    if (!this.initialized) {
      this._starting = true;
      await this.init();
      this._starting = false;
    }
    if (!this.initialized || this.playing) return;

    if (this.useHtmlFallback) {
      const factor = this.getTargetGain();
      this.loopKeys.forEach(key => this.startEntry(this.entries[key], factor));
      this._startTime = performance.now();
      this.setLoopActive('bass', true);
      this.playing = true;
      return;
    }

    if (this.playersReady) await this.playersReady;
    Tone.Transport.bpm.value = MUSIC_LOOP_BPM;
    // Don't use Transport looping - let Players loop themselves (sample-accurate)
    Tone.Transport.loop = false;

    // Start all players at exactly the same time for perfect sync
    // Players loop independently but since they're identical length, they stay in sync
    const startTime = Tone.now() + 0.1; // Small buffer for scheduling
    this.loopKeys.forEach(key => {
      const player = this.players[key];
      if (!player) return;
      try { player.start(startTime); } catch (e) {}
    });
    Tone.Transport.start();
    this._startTime = Tone.Transport.seconds;
    this.setLoopActive('bass', true);
    this.playing = true;
  }

  // Resync HTML Audio elements to combat drift (Electron only)
  _resyncLoop() {
    if (!this.isElectron || !this.electronAudios || !this.playing) return;

    const loopDur = this.loopDuration;
    const elapsed = (performance.now() - this._startTime) / 1000;
    const expectedPos = elapsed % loopDur;

    // Check each audio and correct if drifted more than 50ms
    Object.values(this.electronAudios).forEach(audio => {
      if (audio.paused) return;
      const drift = Math.abs(audio.currentTime - expectedPos);
      if (drift > 0.05 && drift < loopDur - 0.05) {
        audio.currentTime = expectedPos;
      }
    });

    // Schedule next check
    setTimeout(() => this._resyncLoop(), RHYTHM.BEAT);
  }

  stop() {
    this._starting = false;
    this.playing = false;

    if (this.useHtmlFallback) {
      Object.values(this.entries).forEach(entry => {
        if (entry.timer) clearTimeout(entry.timer);
        entry.timer = null;
        entry.audios.forEach(a => { try { a.pause(); a.currentTime = 0; } catch (e) {} });
      });
      this.activeLoops.clear();
      return;
    }

    try { Tone.Transport.stop(); Tone.Transport.position = 0; } catch (e) {}
    Object.values(this.players).forEach(p => {
      try { p.stop(); p.unsync(); } catch (e) {}
    });
    this.activeLoops.clear();

    // Reset shop mode state and effects
    this.inShopMode = false;
    Tone.Transport.swing = 0;
    Tone.Transport.bpm.value = this.normalBpm;
    if (this.shopLowPass) this.shopLowPass.frequency.value = 20000;
    if (this.shopHighPass) this.shopHighPass.frequency.value = 20;
    if (this.shopReverb) this.shopReverb.wet.value = 0;
  }

  pause() { this.stop(); }

  setMuted(muted) {
    if (this.useHtmlFallback) {
      const factor = muted ? 0 : this.getTargetGain();
      Object.keys(this.entries).forEach(key => {
        const entry = this.entries[key];
        if (!entry) return;
        entry.audios.forEach(a => { a.volume = (entry.desired || 0) * factor; });
      });
      return;
    }
    if (this.masterGain) {
      safeRampTo(this.masterGain.gain, muted ? 0 : this.getTargetGain(), 0.1);
    }
  }

  getForgeElements(gameState) {
    const elements = new Set();
    const sel = gameState?.sel || {};
    [sel.item, sel.adj1, sel.adj2, sel.adj3, sel.adj4, sel.noun1].forEach(word => {
      if (word && word.elem !== undefined) elements.add(word.elem);
    });
    return elements;
  }

  setLoopActive(key, active) {
    if (this.useHtmlFallback) {
      const entry = this.entries[key];
      if (!entry) {
        if (active) this.activeLoops.add(key); else this.activeLoops.delete(key);
        return;
      }
      entry.desired = active ? 0.95 : 0;
      const factor = this.getTargetGain();
      entry.audios.forEach((a, idx) => {
        if (idx === entry.active) {
          fadeHtmlAudio(a, entry.desired * factor, active ? 0.25 : 0.2);
        } else {
          a.volume = entry.desired * factor;
        }
      });
      if (active) this.activeLoops.add(key); else this.activeLoops.delete(key);
      return;
    }

    const gainNode = this.gains[key];
    if (!gainNode) {
      if (active) this.activeLoops.add(key); else this.activeLoops.delete(key);
      return;
    }
    const target = (active ? 0.95 : 0) * this.getTargetGain();
    safeRampTo(gainNode.gain, target, active ? 0.2 : 0.15);
    if (active) this.activeLoops.add(key); else this.activeLoops.delete(key);
  }

  updateLayers(gameState) {
    if (!this.initialized || !this.playing) return;
    const forgeElements = this.getForgeElements(gameState);
    const needed = new Set(['bass']);
    forgeElements.forEach(elem => {
      const loopKey = ELEMENT_TO_LOOP[elem];
      if (loopKey) needed.add(loopKey);
    });
    const neededKey = [...needed].sort().join(',');
    if (this._lastNeededKey === neededKey) return;
    this._lastNeededKey = neededKey;
    needed.forEach(key => { if (!this.activeLoops.has(key)) this.setLoopActive(key, true); });
    [...this.activeLoops].forEach(key => {
      if (!needed.has(key) && key !== 'bass') this.setLoopActive(key, false);
    });
  }

  // Reset all loops to bass-only state (for new run)
  resetToBassOnly() {
    if (!this.initialized) return;
    // Reset ALL loop gains to bass-only (regardless of activeLoops state)
    // This ensures gains are reset even after stop() cleared activeLoops
    this.loopKeys.forEach(key => {
      if (key === 'bass') {
        this.setLoopActive(key, true);
      } else {
        // Force gain to 0 even if not in activeLoops
        if (this.useHtmlFallback) {
          const entry = this.entries[key];
          if (entry) {
            entry.desired = 0;
            entry.audios.forEach(a => { a.volume = 0; });
          }
        } else {
          const gainNode = this.gains[key];
          if (gainNode) gainNode.gain.value = 0;
        }
        this.activeLoops.delete(key);
      }
    });
    // Ensure bass is in activeLoops
    this.activeLoops.add('bass');
    // Reset the layer tracking so next updateLayers() works fresh
    this._lastNeededKey = 'bass';

    // Reset any lingering lose effect (restore playback rate, gain, filter)
    if (!this.useHtmlFallback) {
      // Restore playback rate to normal
      this.loopKeys.forEach(key => {
        const player = this.players[key];
        if (player) player.playbackRate = 1;
      });
      // Restore low-pass filter to fully open
      if (this.shopLowPass) this.shopLowPass.frequency.value = 20000;
      // Restore master gain to user's volume setting
      if (this.masterGain) this.masterGain.gain.value = this.getTargetGain();
    }
  }

  // Helper to animate playback rate over time
  _animatePlaybackRate(targetRate, duration) {
    const startTime = performance.now();
    const startRates = {};
    this.loopKeys.forEach(key => {
      const player = this.players[key];
      if (player) startRates[key] = player.playbackRate;
    });

    const animate = () => {
      const elapsed = (performance.now() - startTime) / 1000;
      const progress = Math.min(1, elapsed / duration);
      // Ease out
      const eased = 1 - Math.pow(1 - progress, 2);

      this.loopKeys.forEach(key => {
        const player = this.players[key];
        if (player && startRates[key] !== undefined) {
          player.playbackRate = startRates[key] + (targetRate - startRates[key]) * eased;
        }
      });

      if (progress < 1) {
        requestAnimationFrame(animate);
      }
    };
    requestAnimationFrame(animate);
  }

  enterShopMode() {
    if (this.inShopMode) return;
    this.inShopMode = true;

    if (this.useHtmlFallback) return; // Effects not available in fallback mode

    // Convenience store ceiling speaker effect - same tempo, different vibe
    // Cut the lows gently (tinny cheap speakers, but not too harsh)
    if (this.shopHighPass) {
      safeRampTo(this.shopHighPass.frequency, 200, 0.5);
    }
    // Cut the highs (old dusty speaker cones)
    if (this.shopLowPass) {
      safeRampTo(this.shopLowPass.frequency, 4000, 0.5);
    }
    // Small boxy room reverb (fluorescent-lit tile ceiling)
    if (this.shopReverb) {
      safeRampTo(this.shopReverb.wet, 0.35, 0.5);
    }
    // Slight volume reduction (filters cut perceived loudness, so keep it higher)
    if (this.masterGain) {
      safeRampTo(this.masterGain.gain, this.getTargetGain() * 0.85, 0.5);
    }
  }

  exitShopMode() {
    if (!this.inShopMode) return;
    this.inShopMode = false;

    if (this.useHtmlFallback) return;

    // Exiting the 7-Eleven - door opens, sound floods back in naturally
    // First: brief volume dip as door opens (outdoor ambience would normally mask it)
    if (this.masterGain) {
      safeRampTo(this.masterGain.gain, this.getTargetGain() * 0.3, 0.15);
    }

    // Then: bass comes back first (you feel it before you hear it clearly)
    if (this.shopHighPass) {
      safeRampTo(this.shopHighPass.frequency, 20, 0.6);
    }

    // Highs open up slower (like your ears adjusting to outside)
    setTimeout(() => {
      if (this.shopLowPass) {
        safeRampTo(this.shopLowPass.frequency, 20000, 0.8);
      }
    }, 150);

    // Reverb fades as you leave the boxy room
    if (this.shopReverb) {
      safeRampTo(this.shopReverb.wet, 0, 0.7);
    }

    // Volume swells back up (music hits you full force outside)
    setTimeout(() => {
      if (this.masterGain) {
        safeRampTo(this.masterGain.gain, this.getTargetGain(), 0.5);
      }
    }, 200);
  }

  triggerLoseEffect() {
    if (!this.initialized || !this.playing) return;

    if (!this.useHtmlFallback) {
      // Vinyl power-down effect - slows from current speed to near-stop
      const duration = 2.0;
      const startTime = performance.now();
      const startRate = 1;
      const endRate = 0.05; // Nearly stopped (can't go to 0)

      // Sweep low-pass filter down for muffled dying sound
      if (this.shopLowPass) {
        safeRampTo(this.shopLowPass.frequency, 150, duration);
      }

      // Fade out master gain
      if (this.masterGain) {
        safeRampTo(this.masterGain.gain, 0, duration * 0.9);
      }

      // Animate slowdown with exponential ease (like real vinyl losing power)
      const animate = () => {
        const elapsed = (performance.now() - startTime) / 1000;
        const progress = Math.min(1, elapsed / duration);
        // Exponential ease out - starts fast, really drags at the end
        const eased = 1 - Math.pow(1 - progress, 4);
        const currentRate = startRate - (startRate - endRate) * eased;

        this.loopKeys.forEach(key => {
          const player = this.players[key];
          if (player) player.playbackRate = Math.max(0.01, currentRate);
        });

        if (progress < 1) {
          requestAnimationFrame(animate);
        }
      };
      requestAnimationFrame(animate);

      setTimeout(() => {
        // Reset everything before stopping
        this.loopKeys.forEach(key => {
          const player = this.players[key];
          if (player) player.playbackRate = 1;
        });
        if (this.shopLowPass) this.shopLowPass.frequency.value = 20000;
        if (this.shopHighPass) this.shopHighPass.frequency.value = 20;
        if (this.masterGain) this.masterGain.gain.value = this.getTargetGain();
        this.stop();
      }, duration * 1000 + 100);
    } else {
      // Fallback - just stop
      this.loopKeys.forEach(key => this.setLoopActive(key, false));
      setTimeout(() => this.stop(), RHYTHM.BEAT);
    }
  }

  async triggerVictoryEffect() {
    if (!this.initialized) return;
    if (!this.playing) await this.start();

    // Fade in all instruments with staggered timing for celebratory effect
    const staggerDelay = 150; // ms between each instrument fade-in
    let delay = 0;
    this.loopKeys.forEach(key => {
      if (key === 'bass') return; // Bass is already playing
      setTimeout(() => {
        if (!this.activeLoops.has(key)) {
          this.setLoopActive(key, true);
        }
      }, delay);
      delay += staggerDelay;
    });
    // Update the tracking key so updateLayers doesn't immediately undo this
    this._lastNeededKey = this.loopKeys.join(',');
  }

  getBeatProgress() {
    if (!this.initialized || !this.playing) return 0;
    if (this.useHtmlFallback) {
      const entry = this.entries['bass'];
      const bass = entry?.audios?.[entry.active || 0];
      if (!bass || !bass.duration) return 0;
      const elapsed = bass.currentTime % bass.duration;
      const barLength = (60 / MUSIC_LOOP_BPM) * 4;
      return Math.min(1, Math.max(0, (elapsed % barLength) / barLength));
    }
    try {
      const pos = Tone.Transport.position;
      const [bars, beats, sixteenths] = pos.split(':').map(parseFloat);
      const progressInBar = (beats + sixteenths / 4) / 4;
      return Math.min(1, Math.max(0, progressInBar));
    } catch (e) { return 0; }
  }

  // Get current beat info for slot animations
  // Returns { beat: 0-3, progress: 0-1 within that beat }
  getBeatInfo() {
    if (!this.initialized || !this.playing) return { beat: 0, progress: 0, totalBeats: 0 };

    const beatDuration = 60 / MUSIC_LOOP_BPM; // seconds per beat
    let elapsed = 0;

    if (this.useHtmlFallback) {
      const entry = this.entries['bass'];
      const bass = entry?.audios?.[entry.active || 0];
      if (!bass || !bass.duration) return { beat: 0, progress: 0, totalBeats: 0 };
      elapsed = bass.currentTime;
    } else {
      try {
        elapsed = Tone.Transport.seconds;
      } catch (e) { return { beat: 0, progress: 0, totalBeats: 0 }; }
    }

    const totalBeats = elapsed / beatDuration;
    const beatInBar = Math.floor(totalBeats) % 4; // 0, 1, 2, 3
    const progressInBeat = totalBeats % 1; // 0-1 progress within current beat

    return { beat: beatInBar, progress: progressInBeat, totalBeats };
  }
}
// Singleton instance
let musicEngine = null;

// Helper to get or create music engine
function getMusicEngine() {
  if (!musicEngine) {
    musicEngine = new MusicEngine();
  }
  return musicEngine;
}

// Helper to wait until the next beat (for beat-synced animations)
// Returns immediately if music isn't playing
async function waitForNextBeat() {
  const engine = musicEngine;
  if (!engine || !engine.playing) return;

  const { progress } = engine.getBeatInfo();
  // progress is 0-1 within current beat, wait for remainder
  const msUntilNextBeat = (1 - progress) * RHYTHM.BEAT;

  // Only wait if we're more than 20% into the beat (avoid tiny waits)
  if (msUntilNextBeat > RHYTHM.BEAT * 0.2 && msUntilNextBeat < RHYTHM.BEAT * 0.95) {
    await dly(msUntilNextBeat);
  }
}

// Helper to wait for next quarter beat (for more responsive beat-sync on clicks)
// Catches the nearest 1/4 beat subdivision
async function waitForNextQuarterBeat() {
  const engine = musicEngine;
  if (!engine || !engine.playing) return;

  const { progress } = engine.getBeatInfo();
  // Quarter beat subdivisions: 0, 0.25, 0.5, 0.75, 1.0
  const quarterProgress = progress * 4; // 0-4 range
  const nextQuarter = Math.ceil(quarterProgress);
  const progressToNext = (nextQuarter - quarterProgress) / 4; // Back to 0-1 range
  const msUntilNextQuarter = progressToNext * RHYTHM.BEAT;

  // Only wait if more than 5% away (avoid tiny waits)
  if (msUntilNextQuarter > RHYTHM.BEAT * 0.05 && msUntilNextQuarter < RHYTHM.BEAT * 0.24) {
    await dly(msUntilNextQuarter);
  }
}

// Helper to safely start Tone.js and music engine (called on first user interaction with gameplay)
async function ensureMusicStarted() {
  try {
    if (typeof Tone !== 'undefined' && Tone.context && Tone.context.state !== 'running') {
      await Tone.start();
    }
    const engine = getMusicEngine();
    if (!engine.initialized) {
      await engine.init();
    }
    engine.setMuted(!audioOn);
    if (!engine.playing) {
      engine.start();
    }
    // Start slot bounce animation when music is playing
    startSlotBounce();
  } catch (e) {
    console.warn('Music engine failed to start:', e);
  }
}

const $=s=>document.querySelector(s),$$=s=>document.querySelectorAll(s);
const escapeHtml=str=>String(str).replace(/[&<>"']/g,ch=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[ch]||ch));

// === SLOT BEAT BOUNCE ANIMATION ===
// Slots bounce to the beat based on how many are filled
let slotBounceAnimationId = null;
let lastBouncedBeat = -1;

function getFilledSlots() {
  const filled = [];
  const slotKeys = ['adj1', 'adj2', 'item', 'adj3', 'adj4', 'noun1'];
  slotKeys.forEach((key) => {
    if (S.sel && S.sel[key]) {
      const el = document.querySelector(`.slot[data-slot="${key}"]`);
      if (el) filled.push({ slot: key, element: el });
    }
  });
  return filled;
}

function applyBounce(element) {
  element.style.transition = 'transform 0.06s ease-out';
  element.style.transform = 'translateY(-2px)';
  setTimeout(() => {
    element.style.transition = 'transform 0.1s ease-in';
    element.style.transform = 'translateY(0)';
  }, 60);
}

function updateSlotBounce() {
  if (gfxSettings && gfxSettings.lowFx) {
    slotBounceAnimationId = requestAnimationFrame(updateSlotBounce);
    return;
  }

  const engine = musicEngine;
  if (!engine || !engine.playing) {
    slotBounceAnimationId = requestAnimationFrame(updateSlotBounce);
    return;
  }

  const { beat, totalBeats } = engine.getBeatInfo();
  const currentBeatInt = Math.floor(totalBeats);

  if (currentBeatInt !== lastBouncedBeat) {
    lastBouncedBeat = currentBeatInt;
    const filled = getFilledSlots();
    if (filled.length > 0) {
      // Bounce one slot per beat, cycling through filled slots
      const idx = beat % filled.length;
      applyBounce(filled[idx].element);
    }
  }

  slotBounceAnimationId = requestAnimationFrame(updateSlotBounce);
}

function startSlotBounce() {
  if (slotBounceAnimationId) return; // Already running
  lastBouncedBeat = -1;
  slotBounceAnimationId = requestAnimationFrame(updateSlotBounce);
}

function stopSlotBounce() {
  if (slotBounceAnimationId) {
    cancelAnimationFrame(slotBounceAnimationId);
    slotBounceAnimationId = null;
  }
  lastBouncedBeat = -1;
  // Reset any lingering transforms
  document.querySelectorAll('.slot').forEach(el => {
    el.style.transform = '';
    el.style.transition = '';
  });
}

// === FLIP ANIMATION HELPERS ===
// FLIP = First, Last, Invert, Play - for smooth position animations
let flipPositions = new Map(); // Store positions keyed by word ID
let justPlacedSlot = null; // Track which slot just had a word placed for pop-in animation
let pendingBankFlip = false; // Flag to trigger FLIP animation on next renderBank call

function recordFlipPositions(container) {
  flipPositions.clear();
  if (!container) return;
  const chips = container.querySelectorAll('.chip[data-word-id]');
  chips.forEach(chip => {
    const id = chip.dataset.wordId;
    const rect = chip.getBoundingClientRect();
    flipPositions.set(id, { left: rect.left, top: rect.top });
  });
}

function playFlipAnimation(container) {
  if (!container || flipPositions.size === 0) return;
  const chips = container.querySelectorAll('.chip[data-word-id]');

  // Pre-promote all chips to GPU layers before animation
  chips.forEach(chip => {
    chip.style.willChange = 'transform, opacity';
  });

  chips.forEach(chip => {
    const id = chip.dataset.wordId;
    const oldPos = flipPositions.get(id);
    const isDisabled = chip.classList.contains('disabled');
    // Use appropriate opacity for disabled chips (0.25) vs enabled (1)
    const targetOpacity = isDisabled ? 0.25 : 1;

    if (!oldPos) {
      // New chip - pop in with bounce
      const anim = chip.animate([
        { transform: 'scale(0.3)', opacity: 0 },
        { transform: 'scale(1.1)', opacity: targetOpacity, offset: 0.6 },
        { transform: 'scale(0.97)', opacity: targetOpacity, offset: 0.8 },
        { transform: 'scale(1)', opacity: targetOpacity }
      ], {
        duration: 280,
        easing: 'ease-out',
        fill: 'forwards'
      });
      // Clean up: clear inline styles so CSS classes (e.g., disabled opacity) take over
      anim.onfinish = () => {
        chip.style.willChange = '';
        chip.style.opacity = '';
        chip.style.transform = '';
      };
      return;
    }

    const newRect = chip.getBoundingClientRect();
    const deltaX = oldPos.left - newRect.left;
    const deltaY = oldPos.top - newRect.top;
    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

    if (distance < 2) {
      // No movement needed, but reveal if hidden during RAF gap
      chip.style.opacity = '';
      chip.style.willChange = ''; // Clean up
      return;
    }

    // Detect if this is a row change (vertical movement > threshold)
    const isRowChange = Math.abs(deltaY) > 25;
    const isHorizontal = Math.abs(deltaX) > Math.abs(deltaY);

    // === DISTANCE-BASED DURATION ===
    // Short moves are quick, long moves take more time
    let duration;
    if (distance < 60) {
      duration = 180 + distance * 0.8; // 180-228ms for short moves
    } else if (distance < 150) {
      duration = 230 + (distance - 60) * 0.6; // 230-284ms for medium moves
    } else {
      duration = 290 + Math.min((distance - 150) * 0.4, 100); // 290-390ms for long moves
    }

    // === DISTANCE-BASED SQUASH/STRETCH INTENSITY ===
    // Short moves: subtle effect. Long moves: exaggerated cartoon physics
    const intensity = Math.min(0.08 + (distance / 600), 0.18);

    // For same-row movement: simple horizontal slide with minimal squash
    if (!isRowChange && isHorizontal) {
      const subtleSquash = 1 - (intensity * 0.5);
      const subtleStretch = 1 + (intensity * 0.5);
      const smallOvershoot = Math.min(distance * 0.06, 4);

      // Include opacity to reveal chip hidden during RAF gap (prevents one-frame flash)
      const anim = chip.animate([
        { transform: `translate(${deltaX}px, 0) scaleX(1)`, opacity: targetOpacity, offset: 0 },
        { transform: `translate(${deltaX * 0.5}px, 0) scaleX(${subtleStretch})`, opacity: targetOpacity, offset: 0.4 },
        { transform: `translate(${-smallOvershoot * Math.sign(deltaX)}px, 0) scaleX(${subtleSquash})`, opacity: targetOpacity, offset: 0.75 },
        { transform: 'translate(0, 0) scaleX(1)', opacity: targetOpacity, offset: 1 }
      ], {
        duration: duration,
        easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
        fill: 'forwards'
      });
      anim.onfinish = () => {
        chip.style.willChange = '';
        chip.style.opacity = '';
        chip.style.transform = '';
      };
      return;
    }

    // === CROSS-ROW OR VERTICAL MOVEMENT: Full cartoon physics ===
    const squashX = isHorizontal ? (1 - intensity) : (1 + intensity * 0.7);
    const squashY = isHorizontal ? (1 + intensity * 0.7) : (1 - intensity);
    const stretchX = isHorizontal ? (1 + intensity) : (1 - intensity * 0.5);
    const stretchY = isHorizontal ? (1 - intensity * 0.5) : (1 + intensity);

    // Overshoot scales with distance
    const overshoot = Math.min(distance * 0.08, 6);
    const overshootX = isHorizontal ? -Math.sign(deltaX) * overshoot : 0;
    const overshootY = !isHorizontal ? -Math.sign(deltaY) * overshoot : 0;

    // Include opacity to reveal chip hidden during RAF gap (prevents one-frame flash)
    const anim = chip.animate([
      // Start: at old position
      { transform: `translate(${deltaX}px, ${deltaY}px) scale(1, 1)`, opacity: targetOpacity, offset: 0 },
      // Anticipation squash (subtle for shorter distances)
      { transform: `translate(${deltaX}px, ${deltaY}px) scale(${squashX}, ${squashY})`, opacity: targetOpacity, offset: 0.12 },
      // Stretch while moving
      { transform: `translate(${deltaX * 0.35}px, ${deltaY * 0.35}px) scale(${stretchX}, ${stretchY})`, opacity: targetOpacity, offset: 0.45 },
      // Overshoot
      { transform: `translate(${overshootX}px, ${overshootY}px) scale(${stretchX * 0.97}, ${stretchY * 0.97})`, opacity: targetOpacity, offset: 0.72 },
      // Impact squash
      { transform: `translate(0, 0) scale(${squashX}, ${squashY})`, opacity: targetOpacity, offset: 0.88 },
      // Settle
      { transform: 'translate(0, 0) scale(1, 1)', opacity: targetOpacity, offset: 1 }
    ], {
      duration: duration,
      easing: 'cubic-bezier(0.22, 1, 0.36, 1)',
      fill: 'forwards'
    });
    anim.onfinish = () => {
      chip.style.willChange = '';
      chip.style.opacity = '';
      chip.style.transform = '';
    };
  });

  flipPositions.clear();
}

// === WORD-TO-SLOT FLY ANIMATION ===
// Animates a word chip flying from the bank to a slot with an arc trajectory
function flyToSlot(chip, targetSlot, word, slotKey, callback) {
  if (!chip || !targetSlot) {
    callback();
    return;
  }

  const chipRect = chip.getBoundingClientRect();
  const slotRect = targetSlot.getBoundingClientRect();

  // Calculate deltas
  const dx = slotRect.left + slotRect.width / 2 - (chipRect.left + chipRect.width / 2);
  const dy = slotRect.top + slotRect.height / 2 - (chipRect.top + chipRect.height / 2);
  const distance = Math.sqrt(dx * dx + dy * dy);

  // Arc height - higher for longer distances
  const arcHeight = Math.min(40, distance * 0.15);

  // Clone chip for flying animation
  const flyingChip = chip.cloneNode(true);
  flyingChip.classList.add('flying-chip');
  flyingChip.style.position = 'fixed';
  flyingChip.style.left = chipRect.left + 'px';
  flyingChip.style.top = chipRect.top + 'px';
  flyingChip.style.width = chipRect.width + 'px';
  flyingChip.style.height = chipRect.height + 'px';
  flyingChip.style.zIndex = '10002';
  flyingChip.style.pointerEvents = 'none';
  flyingChip.style.margin = '0';
  document.body.appendChild(flyingChip);

  // Hide original chip
  chip.style.visibility = 'hidden';

  // Duration based on distance
  const duration = Math.min(400, 250 + distance * 0.3);

  // Animate with arc trajectory
  const animation = flyingChip.animate([
    {
      transform: 'translate(0, 0) scale(1) rotate(0deg)',
      opacity: 1,
      offset: 0
    },
    {
      transform: `translate(${dx * 0.5}px, ${dy * 0.5 - arcHeight}px) scale(1.05) rotate(${dx > 0 ? 5 : -5}deg)`,
      opacity: 1,
      offset: 0.5
    },
    {
      transform: `translate(${dx}px, ${dy}px) scale(0.85) rotate(0deg)`,
      opacity: 1,
      offset: 0.85
    },
    {
      transform: `translate(${dx}px, ${dy}px) scale(0.95) rotate(0deg)`,
      opacity: 0.8,
      offset: 1
    }
  ], {
    duration: duration,
    easing: 'cubic-bezier(0.34, 1.2, 0.64, 1)', // Slight overshoot
    fill: 'forwards'
  });

  // Cleanup function to restore visibility and remove flying chip
  const cleanup = () => {
    chip.style.visibility = '';
    flyingChip.remove();
    callback();
  };

  // Use both onfinish handler and setTimeout as fallback
  animation.onfinish = cleanup;

  // Fallback timeout in case onfinish doesn't fire
  setTimeout(() => {
    // Only cleanup if animation didn't already finish
    if (flyingChip.parentNode) {
      cleanup();
    }
  }, duration + 50);
}

// === OVERLAY ANIMATION HELPERS ===
// Show overlay with proper transition (display:flex first, then add 'show' on next frame)
function showOverlay(overlay) {
  if (!overlay) return;
  if (typeof overlay === 'string') overlay = document.querySelector(overlay);
  if (!overlay) return;

  overlay.style.display = 'flex';
  // Force a reflow so the browser registers the display change before adding 'show'
  if (overlay.classList.contains('instant-show')) {
    overlay.classList.add('show');
  } else {
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        overlay.classList.add('show');
      });
    });
  }
}

// Hide overlay with transition (remove 'show', then hide after transition)
function hideOverlay(overlay, duration = 250) {
  if (!overlay) return;
  if (typeof overlay === 'string') overlay = document.querySelector(overlay);
  if (!overlay) return;

  overlay.classList.remove('show');
  setTimeout(() => {
    if (!overlay.classList.contains('show')) {
      overlay.style.display = 'none';
      overlay.classList.remove('instant-show');
    }
  }, duration);
}

// === HEALTH BAR SHATTER EFFECT ===
// Creates dramatic shard particles when enemy HP drops significantly
function shatterHealthBar(barOuter, damageDealt, maxHP) {
  if (!barOuter || gfxSettings.lowFx) return;

  const rect = barOuter.getBoundingClientRect();
  const damagePercent = damageDealt / maxHP;
  const shardCount = Math.min(16, Math.max(8, Math.floor(damagePercent * 20)));

  // Calculate how much of the bar was "destroyed" (as percentage of width)
  const destroyedPercent = Math.min(1, damagePercent);
  const destroyedWidth = rect.width * destroyedPercent;

  // Color gradient based on damage dealt - more damage = more red
  const shardColors = damagePercent >= 1
    ? ['#dc2626', '#ef4444', '#f87171'] // Full kill - bright red
    : damagePercent >= 0.7
    ? ['#ea580c', '#f97316', '#fb923c'] // Heavy damage - orange-red
    : ['#f59e0b', '#fbbf24', '#fcd34d']; // Light damage - yellow-orange

  // Create shards along the destroyed portion of the health bar
  for (let i = 0; i < shardCount; i++) {
    const shard = document.createElement('div');
    shard.className = 'health-shard';

    // Random position along the destroyed health bar portion (right side)
    const xOffset = rect.width - destroyedWidth + Math.random() * destroyedWidth;
    // Triangle shards
    const shardSize = 6 + Math.random() * 10;

    // Pick a random color from the palette
    const shardColor = shardColors[Math.floor(Math.random() * shardColors.length)];

    shard.style.left = (rect.left + xOffset) + 'px';
    shard.style.top = (rect.top + Math.random() * rect.height) + 'px';
    shard.style.width = shardSize + 'px';
    shard.style.height = shardSize + 'px';
    shard.style.background = shardColor;
    shard.style.boxShadow = `0 0 6px ${shardColor}`;
    shard.style.clipPath = 'polygon(50% 0%, 0% 100%, 100% 100%)';

    // Anime-style: explosive burst outward, continuous drift that slows down, fade at end
    const angle = Math.random() * Math.PI * 2;
    const distance = 100 + Math.random() * 60; // Final distance
    const xVel = Math.cos(angle) * distance;
    const yVel = Math.sin(angle) * distance * 0.7;
    const rotation = (Math.random() - 0.5) * 90;

    // Continuous drift: fast start, gradually slowing but always moving until fade
    shard.animate([
      { transform: 'translate(0, 0) rotate(0deg) scale(1)', opacity: 1, offset: 0 },
      { transform: `translate(${xVel * 0.5}px, ${yVel * 0.5}px) rotate(${rotation * 0.5}deg) scale(1)`, opacity: 1, offset: 0.1 },
      { transform: `translate(${xVel * 0.75}px, ${yVel * 0.75}px) rotate(${rotation * 0.75}deg) scale(0.95)`, opacity: 1, offset: 0.25 },
      { transform: `translate(${xVel * 0.88}px, ${yVel * 0.88}px) rotate(${rotation * 0.88}deg) scale(0.9)`, opacity: 1, offset: 0.5 },
      { transform: `translate(${xVel * 0.96}px, ${yVel * 0.96}px) rotate(${rotation * 0.96}deg) scale(0.85)`, opacity: 0.6, offset: 0.8 },
      { transform: `translate(${xVel}px, ${yVel}px) rotate(${rotation}deg) scale(0.7)`, opacity: 0, offset: 1 }
    ], {
      duration: 1100 + Math.random() * 300,
      easing: 'linear', // Linear timing, keyframes handle the deceleration
      fill: 'forwards',
      delay: Math.random() * 20
    });

    document.body.appendChild(shard);

    // Clean up after animation
    setTimeout(() => shard.remove(), RHYTHM.BAR);
  }
}

// === PARALLAX EFFECT ===
function initParallax() {
  const battleView = document.getElementById('battle-view');
  const forgeView = document.getElementById('forge');

  // Setup element for GPU-accelerated parallax (prevents blur on high-DPI/high-refresh displays)
  const setupParallaxElement = (element, duration = '0.15s') => {
    if (element) {
      element.style.transition = `transform ${duration} ease-out`;
      element.style.willChange = 'transform';
      element.style.backfaceVisibility = 'hidden';
      // Force GPU layer with initial transform
      element.style.transform = 'translate3d(0, 0, 0)';
    }
  };

  if (battleView) {
    const heroPortrait = battleView.querySelector('.hero-portrait');
    const enemyPortrait = battleView.querySelector('.enemy-portrait');
    const weaponDisplay = document.getElementById('weapon-display');

    setupParallaxElement(heroPortrait);
    setupParallaxElement(enemyPortrait);
    setupParallaxElement(weaponDisplay);

    document.addEventListener('mousemove', (e) => {
      // Skip parallax in Low FX mode
      if (gfxSettings.lowFx) return;

      const x = (e.clientX / window.innerWidth - 0.5) * 2; // -1 to 1
      const y = (e.clientY / window.innerHeight - 0.5) * 2; // -1 to 1

      // Subtle parallax on hero portrait (moves opposite to cursor)
      // Use translate3d + integer pixels for GPU compositing without sub-pixel blur
      if (heroPortrait) {
        heroPortrait.style.transform = `translate3d(${Math.round(-x * 4)}px, ${Math.round(-y * 4)}px, 0)`;
      }

      // Subtle parallax on enemy portrait (moves opposite to cursor)
      if (enemyPortrait) {
        enemyPortrait.style.transform = `translate3d(${Math.round(-x * 4)}px, ${Math.round(-y * 4)}px, 0)`;
      }

      // Weapon display moves with cursor (more pronounced)
      if (weaponDisplay) {
        weaponDisplay.style.transform = `translate3d(${Math.round(x * 6)}px, ${Math.round(y * 6)}px, 0)`;
      }
    });
  }

  // No parallax in forge to keep badges/chips static
}

// === INIT ===
function init(){
  // Start with a curated subset of words. Provide all common weapons and a mix of Tier 1
  // and Tier 2 words (excluding hidden words) to give players options without filling
  // the entire inventory. This mirrors the starting inventory logic in startNewRun().
  const weaponPool = WORDS.filter(w => w.type === 'weapon' && w.rarity === T.T1);
  const nonWeaponPool = WORDS.filter(w => w.type !== 'weapon' && !w.hiddenInBank &&
    (w.rarity === 0 || w.rarity === 2));
  const shuffledNon = shuf([...nonWeaponPool]);
  const desiredStart = Math.min(nonWeaponPool.length, Math.floor(INV_LIMIT / 2) - weaponPool.length);
  const startNon = shuffledNon.slice(0, Math.max(0, desiredStart)).map(w => ({ ...w }));
  S.inv = [...weaponPool.map(w => ({ ...w })), ...startNon];

  setupEvents();
  initParallax(); // Initialize parallax effects
  const forgeBtn = document.getElementById("forge-btn");
  if(forgeBtn){
    forgeBtn.onclick = forge;
    forgeBtn.onmouseenter = sfxHover;
  }
  const combatContinueBtn = document.getElementById("combat-continue");
  if(combatContinueBtn){
    combatContinueBtn.onclick = () => {
      if(combatContinueBtn.disabled) return;
      combatContinueBtn.disabled = true;
      const combatOverlay = document.getElementById("combat-overlay");
      if(combatOverlay) combatOverlay.classList.add("combat-exit");
      const spotlightTint = document.getElementById("spotlight-tint");
      if(spotlightTint) spotlightTint.classList.add("show", "full");
      afterCombat();
    };
    combatContinueBtn.onmouseenter = sfxHover;
  }
  const shopExitBtn = document.getElementById("exit-shop-btn");
  if(shopExitBtn){
    shopExitBtn.textContent = "EXIT SHOP";
    shopExitBtn.onclick = async () => {
      // Grant interest on shop exit: gold interest + empty slot interest
      const { totalInterest } = calculateInterest();
      if(totalInterest > 0){
        S.gold += totalInterest;
        checkTreasureHunterAchievement();
        playSample('gem.ogg', 0.5);
      }
      saveRun();

      // Prepare next encounter before transition
      S.rerollCost = 5;
      clrSel();
      newEnc();

      // Play transition - scene switch AND intro happen at peak
      await playSceneTransition(() => {
        document.getElementById("shop-overlay").classList.remove("show");
        if (musicEngine && musicEngine.initialized) {
          musicEngine.exitShopMode();
        }
        setFlameColor('battle');

        // Reset floating embers to normal (or boss purple if chapter boss round)
        if (sparkManager) {
          const isBossRound = S.roundIndex % 9 === 0 && S.roundIndex > 0;
          sparkManager.setColorMode(isBossRound ? 'boss' : 'normal');
        }

        // Show intro immediately during transition
        showRoundIntro();
      });

      // Wait for intro to be dismissed
      await waitForIntroDismiss();

      // Show forge after intro completes
      const forgeEl = document.getElementById("forge");
      if (forgeEl) forgeEl.classList.remove("shop-hidden");

      // Mark game phase for save/load restoration
      S.gamePhase = 'forge';
      saveRun();

      render();
    };
    shopExitBtn.onmouseenter = sfxHover;
  }
  const shopMenuBtn = document.getElementById("shop-menu");
  if(shopMenuBtn){
    shopMenuBtn.onclick = () => {
      document.getElementById("shop-overlay").classList.remove("show");
      showOverlay('#pause-menu');
    };
    shopMenuBtn.onmouseenter = sfxHover;
  }
  const shopTalentsBtn = document.getElementById("shop-talents-btn");
  if(shopTalentsBtn){
    shopTalentsBtn.onclick = () => openTalentViewer();
    shopTalentsBtn.onmouseenter = sfxHover;
  }
  const rerollBtn = document.getElementById("reroll-btn");
  if(rerollBtn){
    rerollBtn.onclick = rerollShop;
    rerollBtn.onmouseenter = sfxHover;
  }
  // Attach multiplier breakdown tooltip to the damage preview panel on first init.
  // Reuse the same breakdown builder as the combat result so players see identical
  // math both before and after a fight. Show on hover like empty word slots.
  const previewPanel = document.getElementById('damage-preview-text');
  if(previewPanel){
    attachDamageTooltip(previewPanel);
    previewPanel.__tooltipContent = () => {
      const precomputed = S.sel.item ? calc({ breakdown: true }) : null;
      return getSharedBreakdownContent(precomputed);
    };
  }
  const combatTotalEl = document.getElementById('combat-total');
  const combatResultEl = document.getElementById('combat-result');
  if(combatResultEl) combatResultEl.classList.add('click-tooltip');
  attachDamageTooltip(combatTotalEl);
  attachDamageTooltip(combatResultEl);
  const sellWordBtn = document.getElementById("sell-word-btn");
  if (sellWordBtn) {
    sellWordBtn.onmouseenter = sfxHover;
    sellWordBtn.onclick = (e) => {
      e.stopPropagation(); // Prevent global disabled-click handler from firing after button is disabled
      if (selectedSellWords && selectedSellWords.length > 0) {
        // Sort indices descending so splicing doesn't invalidate indices
        const sortedIdx = selectedSellWords.map(({ idx }) => idx).sort((a, b) => b - a);
        let total = 0;
        selectedSellWords.forEach(({ word }) => {
          const tier = word.rarity || 0;
          // Sell prices: T1=1g, T2=2g, T3=5g
          let sellPrice = tier === 0 ? 1 : tier === 2 ? 2 : 5;
          // Golden Tongue talent: +50% sell price
          if(S.talents && S.talents.includes('golden_tongue')){
            sellPrice = Math.ceil(sellPrice * 1.5);
          }
          total += sellPrice;
        });
        S.gold += total;
        checkTreasureHunterAchievement();
        S.wordsSold = (S.wordsSold || 0) + selectedSellWords.length; // Track total words sold for talents

        // Record positions BEFORE removing words for FLIP animation
        if (!gfxSettings.lowFx) {
          recordFlipPositions($("#shop-word-bank"));
          pendingBankFlip = true;
        }

        sortedIdx.forEach(i => {
          if (i >= 0) S.inv.splice(i, 1);
        });
        playSample('buy_crate.ogg', 0.9);
        // Clear selection
        selectedSellWords = [];
        document.getElementById("sell-word-btn").textContent = "Sell Selected";
        document.getElementById("sell-word-btn").disabled = true;
        // Remove selected class from any highlighted chips
        document.querySelectorAll("#shop-word-bank .chip.selected").forEach(c => c.classList.remove("selected"));
        renderShop();
        // Play FLIP animation on shop word bank after render - defer to avoid layout thrashing
        if (!gfxSettings.lowFx && pendingBankFlip) {
          requestAnimationFrame(() => playFlipAnimation($("#shop-word-bank")));
          pendingBankFlip = false;
        }
        render();
      }
    };
  }

  // Deselect button clears all selected words in the shop inventory
  const deselectBtn = document.getElementById('deselect-btn');
  if(deselectBtn){
    deselectBtn.onclick = () => {
      selectedSellWords = [];
      document.getElementById('sell-word-btn').textContent = "Sell Selected";
      document.getElementById('sell-word-btn').disabled = true;
      // Remove highlight from all chips
      const bank = document.getElementById('shop-word-bank');
      if(bank){
        bank.querySelectorAll('.chip.selected').forEach(c => c.classList.remove('selected'));
      }
      playSfxBack(); // Deselect sound
    };
    // Hover sound for deselect button
    deselectBtn.onmouseenter = sfxHover;
  }

  // Audio initialization function (needs user gesture) - only for samples/sfx, NOT Tone.js music
  // Tone.js music is deferred until player actually starts/continues a game
  const initAudioOnGesture = () => {
    initAudio();
  };

  // Multiple user gestures can trigger audio init (browsers require user interaction)
  document.addEventListener("click", initAudioOnGesture, {once:true});
  document.addEventListener("mousedown", initAudioOnGesture, {once:true});
  document.addEventListener("keydown", initAudioOnGesture, {once:true});
  document.addEventListener("touchstart", initAudioOnGesture, {once:true});

  // Global click sound - play alternating click/click alt on any click, panned by mouse position
  // Excludes: portraits, logo, word chips, header/menu buttons, click-to-continue elements, overlays with UI sounds
  document.addEventListener("click", (e) => {
    if(e.target.closest('.hero-portrait') || e.target.closest('.enemy-portrait')) return;
    if(e.target.closest('.logo-img')) return;
    // Skip click sound for word/chip selection
    if(e.target.closest('.chip') || e.target.closest('.word-bank') || e.target.closest('#word-bank') || e.target.closest('#shop-word-bank')) return;
    // Skip click sound for forge slots (word placement)
    if(e.target.closest('.weapon-slot')) return;
    // Skip click sound for header buttons, menu buttons, pause menu, shop top bar
    if(e.target.closest('#header') || e.target.closest('#pause-menu') || e.target.closest('#shop-menu')) return;
    if(e.target.closest('.shop-top-right') || e.target.closest('.shop-top-left') || e.target.closest('#shop-talents-btn')) return;
    // Skip click sound for shop deselect button (has its own sound)
    if(e.target.closest('#deselect-btn')) return;
    // Skip click sound for click-to-continue elements (intro, chapter, etc.)
    if(e.target.closest('.intro-hint') || e.target.closest('.chapter-intro') || e.target.closest('#round-intro-screen')) return;
    // Skip click sound for combat result modal continue button
    if(e.target.closest('#combat-result-modal')) return;
    // Skip click sound for overlays that have their own open/back sounds
    if(e.target.closest('#achievements-overlay') || e.target.closest('#credits-overlay') || e.target.closest('#graphics-settings')) return;
    if(e.target.closest('#talent-viewer-overlay') || e.target.closest('#sound-panel')) return;
    // Skip click sound for main menu BUTTONS only (they trigger overlays with sounds)
    // Background clicks still play the ambient anvil sound
    if(e.target.closest('#main-menu button')) return;
    // Skip click sound for consumables/tools bar (they have their own sounds)
    if(e.target.closest('#consumables-bar') || e.target.closest('.consumable-item')) return;
    const clickSound = useClickAlt ? 'click alt.ogg' : 'click.ogg';
    const pan = getMousePan();
    playSample(clickSound, 0.6, pan); // Panned by mouse X position
    useClickAlt = !useClickAlt;
  });

  // Invalid click sound - dissonant tone when clicking disabled/greyed elements
  document.addEventListener("click", (e) => {
    const target = e.target;
    // Check for disabled buttons
    const btn = target.closest('button');
    if (btn && (btn.disabled || btn.classList.contains('btn-disabled'))) {
      playSfxInvalid();
      return;
    }
    // Check for disabled chips/words (unselectable at the moment)
    const chip = target.closest('.chip');
    if (chip && chip.classList.contains('disabled')) {
      playSfxInvalid();
      return;
    }
    // Check for sold-out shop items
    if (target.closest('.sold-out') || target.closest('.crate-sold-out')) {
      playSfxInvalid();
      return;
    }
    // Check for locked hero portraits
    const heroPortrait = target.closest('.hero-portrait');
    if (heroPortrait && heroPortrait.classList.contains('locked')) {
      playSfxInvalid();
      return;
    }
  });

  // Click inventory counter to cycle sort modes: Type ‚Üì ‚Üí Type ‚Üë ‚Üí Rarity ‚Üì ‚Üí Rarity ‚Üë
  const invCounter = document.getElementById('inv-counter');
  const sortIndicator = document.getElementById('sort-indicator');
  if(invCounter){
    const sortCycle = [
      {mode:'type', asc:true, label:'Type ‚Üì'},
      {mode:'type', asc:false, label:'Type ‚Üë'},
      {mode:'rarity', asc:true, label:'Rarity ‚Üì'},
      {mode:'rarity', asc:false, label:'Rarity ‚Üë'}
    ];
    let sortIndex = 0;
    invCounter.onclick = () => {
      sortIndex = (sortIndex + 1) % sortCycle.length;
      const s = sortCycle[sortIndex];
      S.sortMode = s.mode;
      S.sortAsc = s.asc;
      if(sortIndicator) sortIndicator.textContent = s.label;
      renderBank();
      sfxHover();
    };
    invCounter.onmouseenter = sfxHover;
  }

  // Sort buttons for shop word bank
  $$("#shop-sort-btns button").forEach(btn=>{
    btn.onclick = () => {
      S.shopSortMode = btn.dataset.sort;
      $$("#shop-sort-btns button").forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
      renderShopWordBank(false); // No animation on sort change
    };
    // Play hover sound on shop sort buttons
    btn.onmouseenter = sfxHover;
  });
  // Sort direction toggle for shop
  const sortDirBtn = document.getElementById('sort-dir-btn');
  if(sortDirBtn){
    sortDirBtn.onclick = () => {
      S.shopSortAsc = !S.shopSortAsc;
      // Update arrow icon to indicate direction (down = ascending, up = descending)
      sortDirBtn.textContent = S.shopSortAsc ? '‚Üì' : '‚Üë';
      renderShopWordBank(false); // No animation on sort direction change
    };
    sortDirBtn.onmouseenter = sfxHover;
  }

  // Portrait hover detail panels removed - all info now shown on portraits directly

  // Bind main menu start button.  When clicked, hide the menu and begin a new run.
  // Note: The start button handler is now bound on DOMContentLoaded for reliability. See below.

}

// ============================================
// ONBOARDING SYSTEM
// Simple contextual guidance for first-time players
// ============================================

// Onboarding state
let ONBOARD = {
  active: false,
  step: 0,
  weaponPlaced: false,
  secondWordPlaced: false,
  forgeAttempted: false
};

// Generate a mini word chip HTML for onboarding examples
function onboardingChip(name, tier = 1, elemIndex = null, type = 'elemental') {
  const tierClass = `tier-${tier}`;
  const elemTabClasses = ['elem-phys','elem-poison','elem-fire','elem-water','elem-light','elem-dark','elem-earth','elem-lightning'];

  let tabHtml = '';
  let elemHtml = '';
  let extraClass = '';

  if (type === 'elemental' && elemIndex !== null) {
    tabHtml = `<div class="chip-tab ${elemTabClasses[elemIndex]}"></div>`;
    elemHtml = `<div class="chip-elem" style="color:${EC[elemIndex]}">${EN[elemIndex]}</div>`;
  } else if (type === 'weapon') {
    extraClass = tierClass;
  }

  return `<div class="chip onboarding-chip" style="pointer-events:none">
    ${tabHtml}
    <div class="chip-tier ${tierClass}">T${tier}</div>
    <div class="chip-name ${extraClass}">${name}</div>
    ${elemHtml}
  </div>`;
}

// Play "talking" sound for onboarding - hero voice (brighter E minor pentatonic)
function playOnboardingTalk() {
  const freqs = [329.63, 392, 440, 493.88, 587.33]; // E4, G4, A4, B4, D5
  const count = 5 + Math.floor(Math.random() * 3); // 5-7 chirps
  for (let i = 0; i < count; i++) {
    setTimeout(() => {
      const freq = freqs[Math.floor(Math.random() * freqs.length)];
      const duration = 0.06 + Math.random() * 0.04;
      try { playTone(freq, duration, 'sine', 0.08); } catch(e) {}
    }, i * 60); // Rapid succession
  }
}

// Show onboarding dialogue (centered full-screen overlay)
function showOnboarding(text, exampleHtml = '', showPortrait = true) {
  const overlay = document.getElementById('onboarding-overlay');
  const portrait = document.getElementById('onboarding-portrait');
  const name = document.getElementById('onboarding-name');
  const textEl = document.getElementById('onboarding-text');
  const exampleEl = document.getElementById('onboarding-example');

  if (!overlay) return Promise.resolve();

  // Set Graham's portrait
  if (portrait && showPortrait) {
    portrait.innerHTML = getPortraitSVG('warrior');
    portrait.style.display = '';
  } else if (portrait) {
    portrait.style.display = 'none';
  }

  if (name) name.textContent = 'Graham Moor';
  if (textEl) textEl.innerHTML = text;

  // Show example chips if provided
  if (exampleEl) {
    exampleEl.innerHTML = exampleHtml;
    exampleEl.style.display = exampleHtml ? 'flex' : 'none';
  }

  overlay.classList.add('visible');

  // Play talking sound when dialogue appears
  playOnboardingTalk();

  return new Promise(resolve => {
    const handler = (e) => {
      overlay.removeEventListener('click', handler);
      sfxClick();
      overlay.classList.remove('visible');
      resolve();
    };
    overlay.addEventListener('click', handler);
  });
}

// Start onboarding for first-time players
async function startOnboarding() {
  ONBOARD.active = true;
  ONBOARD.step = 1;
  ONBOARD.weaponPlaced = false;
  ONBOARD.secondWordPlaced = false;
  ONBOARD.forgeAttempted = false;

  // Step 1: Graham introduces himself - show a Sword chip as example
  const swordExample = onboardingChip('Sword', 1, null, 'weapon');
  await showOnboarding('Wordsmith! I need a <span class="highlight">"Wordy" Weapon</span> to defeat this foe.', swordExample);
}

// Called when a word is placed during onboarding
async function onOnboardingWordPlaced(word, slotKey) {
  if (!ONBOARD.active) return;

  if (slotKey === 'item' && !ONBOARD.weaponPlaced) {
    // First weapon placed
    ONBOARD.weaponPlaced = true;
    ONBOARD.step = 2;

    await dly(RHYTHM.HALF);
    await showOnboarding('Heroes have their preferred weapon. Mine ‚Äî a <span class="highlight">Sword</span>.');

    // Show all element chips as examples
    const elementExamples =
      onboardingChip('Stone', 1, E.PHYS) +
      onboardingChip('Venom', 1, E.POISON) +
      onboardingChip('Fire', 1, E.FIRE) +
      onboardingChip('Water', 1, E.WATER) +
      onboardingChip('Light', 1, E.LIGHT) +
      onboardingChip('Shadow', 1, E.DARK) +
      onboardingChip('Earth', 1, E.EARTH) +
      onboardingChip('Spark', 1, E.LIGHTNING);
    await showOnboarding('A Weapon alone is not enough, it needs to be <span class="highlight">enhanced</span>. Words can be <span class="highlight">Elemental</span> or define its <span class="highlight">Rarity</span>. Keep in mind the Hero and Enemy\'s Strengths and Weaknesses.', elementExamples);

    // Show adjective vs noun form examples
    const formExamples =
      onboardingChip('Fire', 1, E.FIRE) +
      '<span style="color:#6b7280;font-size:20px;align-self:center">‚Üí</span>' +
      onboardingChip('Fiery', 1, E.FIRE);
    await showOnboarding('Select a Word and place it in another slot. Depending where, it\'ll take on its proper form ‚Äî as an <span class="highlight">adjective</span> or a <span class="highlight">noun</span>.', formExamples);

    ONBOARD.step = 4;
  } else if (ONBOARD.weaponPlaced && !ONBOARD.secondWordPlaced && slotKey !== 'item') {
    // Second word placed (in any adjective or noun slot)
    ONBOARD.secondWordPlaced = true;
    ONBOARD.step = 5;

    await dly(RHYTHM.HALF);
    await showOnboarding('That\'s more <span class="highlight">Wordy</span>! Continue forging until the Weapon will be powerful enough to defeat the enemy, indicated by its <span class="highlight">AP</span> in the center and the enemy\'s <span class="highlight">HP bar</span>. When you\'re ready, hit <span class="highlight">"Forge Weapon"</span>.');
  }
}

// Called when forge is attempted during onboarding - returns true if should block
async function onOnboardingForgeAttempt() {
  if (!ONBOARD.active) return false;

  // Calculate if player would lose
  const c = calc();
  const wouldLose = (c.heroDmg || 0) < (S.enemy?.hp || 0);

  if (wouldLose) {
    await showOnboarding('That won\'t do. Add more <span class="highlight">Words</span> and its power will grow.');
    return true; // Block the forge every time
  }

  return false; // Allow the forge
}

// Show onboarding completion after first victory
async function showOnboardingComplete() {
  if (!ONBOARD.active) return;

  ONBOARD.active = false;
  PStats.tutorialComplete = true;
  saveStats();

  await showOnboarding('I see you haven\'t lost your edge, <span class="highlight">Wordsmith</span>.<br><br>Next, you\'ll be able to buy and sell Words, Tools, and more.<br><br>Accompany me on this adventure ‚Äî all I ask is to craft me a <span class="highlight">Wordy Weapon</span>!');
}

// Check if onboarding should start
function shouldStartOnboarding() {
  return !PStats.tutorialComplete && S.roundIndex === 1;
}

async function startNewRun(){
  // Ensure no overlays remain visible when starting a fresh run
  closeRunOverlays();
  // Stop any playing rarity drones
  stopAllRarityDrones();
  // Exit shop mode to clear any lingering audio filters
  if (musicEngine && musicEngine.inShopMode) {
    musicEngine.exitShopMode();
  }
  // Don't start music here - wait until hero is selected and match begins
  // Music will start fresh with bass-only in the hero selection handler
  // Reset flame to battle mode (red)
  setFlameColor('battle');
  // Reset forge guard
  isForging = false;
  // Reset transition guard
  isTransitioning = false;

  // Reset run state
  S.wins=0;S.losses=0;S.streak=0;S.gold=30;
  S.level=1;S.roundIndex=1;S.floor=1;
  S.talents=[]; // Reset talents
  S.talentLevels={}; // Reset talent levels
  S.shadowBonusHP=0; // Reset talent state
  S.battleHardenedBonus=0; // Reset talent state
  S.quickStudyBonus=0; // Reset talent state
  S.pendingBossLoot=null; // Clear any pre-rolled boss loot
  S.tempEffects={};
  S.consumables=[];
  // Reset talent tracking
  S.usedWeaponTypes = new Set();
  S.usedWeapons = new Set();
  S.uniqueWordsUsed = new Set();
  S.bossesDefeated = 0;
  S.carriedOverkill = 0;
  // Reset new talent tracking variables
  S.toolsUsed = 0;
  S.cratesOpened = 0;
  S.goldSpent = 0;
  S.rarityWordsUsed = 0;
  S.tierWordsPlayed = {1:0, 2:0, 3:0};
  S.toolUsedThisBattle = false;
  S.wordsUsedThisRun = 0; // Word Historian tracking
  S.wordsSold = 0; // Liquidation tracking
  S.rereadTriggersThisRun = 0; // Reverberation tracking
  S.elementalWBonus = 0; // Elemental Mastery W bonus (persists across combats)
  S.cumulativeWordCount = 0; // Prismatic Resonance: Cumulative W across run
  // Reset chapter boss tracking
  S.foughtChapterBosses = [];
  S.chapterBoss = null;
  S.blockedSlot = null;
  // Reset chapter tracking
  S.chapterAPBonus = 0; // Cumulative AP bonus from completing chapters
  S.currentChapter = 0;
  S.gamePhase = 'shop'; // Start new runs at shop phase
  // Reset hero selection flag so that a new hero must be chosen on each new run.
  S.heroSelected = false;
  // Populate starting inventory: give all Tier 1 weapons (COMMON rarity) to the player
  // up front, then fill the rest of the starting inventory with a mix of Tier 1 and Tier 2
  // words (affinities, adjectives, nouns). Hidden words are excluded. This provides
  // players with a broad vocabulary from the outset.
  const weaponPool = WORDS.filter(w => w.type === 'weapon' && w.rarity === T.T1);
  const nonWeaponPool = WORDS.filter(w => w.type !== 'weapon' && !w.hiddenInBank &&
    (w.rarity === 0 || w.rarity === 2));
  const shuffledNon = shuf([...nonWeaponPool]);
  // Determine how many non-weapon words to include at start. Fill up to half the
  // inventory limit minus the number of weapons to give players room to loot more.
  const desiredStart = Math.min(nonWeaponPool.length, Math.floor(INV_LIMIT / 2) - weaponPool.length);
  const startNon = shuffledNon.slice(0, Math.max(0, desiredStart)).map(w => ({ ...w }));
  S.inv = [...weaponPool.map(w => ({ ...w })), ...startNon];
  PStats.attempts++;saveStats();clearRunSave();
  clrSel();
  showHeroSelect();
}

let currentHeroIndex = 0;

// Difficulty descriptions for the selector
const DIFF_DESCRIPTIONS = [
  '', // Apprentice - no description needed
  'Enemies have +50% HP. Shop prices +25%.',
  'Enemies have +100% HP. Shop prices +50%.'
];

// Check if a difficulty level is unlocked for current hero (must beat previous difficulty with that hero)
function isDifficultyUnlocked(diff, heroName = null) {
  if (diff === 0) return true; // Apprentice always unlocked
  // Demo: Only Apprentice difficulty available
  if (IS_DEMO) return false;
  // Per-hero difficulty unlocks: must beat previous difficulty with this hero
  const hero = heroName || (S.hero ? S.hero.name : HEROES[currentHeroIndex]?.name);
  if (!hero) return false;
  const heroClears = (PStats.heroDifficultyClears || {})[hero] || {};
  return heroClears[diff - 1] >= 1;
}

function setupDifficultySelector() {
  const selector = document.getElementById('difficulty-selector');
  const descEl = document.getElementById('difficulty-desc');
  if (!selector) return;

  // Restore last selected difficulty, but clamp to highest unlocked
  let savedDiff = PStats.preferredDifficulty || 0;
  while (savedDiff > 0 && !isDifficultyUnlocked(savedDiff)) {
    savedDiff--;
  }
  S.difficulty = savedDiff;

  // Update button states
  const buttons = selector.querySelectorAll('.diff-btn');
  buttons.forEach(btn => {
    const diff = parseInt(btn.dataset.diff);
    const unlocked = isDifficultyUnlocked(diff);

    btn.classList.toggle('selected', diff === S.difficulty);
    btn.classList.toggle('locked', !unlocked);
    btn.disabled = !unlocked;

    if (!unlocked) {
      btn.title = IS_DEMO ? 'Full Game Only' : `Beat ${DIFF_NAMES[diff - 1]} to unlock`;
    } else {
      btn.title = '';
    }

    btn.onclick = () => {
      if (!unlocked) return;
      S.difficulty = diff;
      PStats.preferredDifficulty = diff;
      saveStats();
      buttons.forEach(b => b.classList.toggle('selected', parseInt(b.dataset.diff) === diff));
      updateDifficultyDesc(descEl, diff);
      playSfxOpen();
    };
    btn.onmouseenter = sfxHover;
  });

  // Set initial description
  updateDifficultyDesc(descEl, S.difficulty);
}

function updateDifficultyDesc(descEl, diff) {
  descEl.textContent = DIFF_DESCRIPTIONS[diff];
}

function showHeroSelect(){
  currentHeroIndex = 0;
  // Update skill points badges
  updateSkillBadges();

  // Setup difficulty selector
  setupDifficultySelector();

  // Hide menu button during hero select (first launch)
  const pauseBtn = document.getElementById('pause-btn');
  if (pauseBtn) pauseBtn.style.display = 'none';
  // Hide sound button during hero select
  const soundBtn = document.getElementById('sound-btn');
  if (soundBtn) soundBtn.style.display = 'none';
  // Hide header (round/money pills) during hero select
  const header = document.getElementById('header');
  if (header) header.style.display = 'none';
  // Hide word bank during hero select
  const wordBank = document.getElementById('word-bank');
  if (wordBank) wordBank.style.display = 'none';
  // Hide forge during hero select
  const forge = document.getElementById('forge');
  if (forge) forge.style.display = 'none';

  // Clear battle portrait frames to prevent SVG ID conflicts
  // Each portrait SVG has IDs for gradients/clipPaths, and duplicate IDs cause render issues
  // Note: Shop portraits are managed by renderShop() - don't clear them here
  const heroPortraitFrame = document.querySelector('.hero-portrait .portrait-frame');
  const enemyPortraitFrame = document.querySelector('.enemy-portrait .portrait-frame');
  if (heroPortraitFrame) heroPortraitFrame.innerHTML = '';
  if (enemyPortraitFrame) enemyPortraitFrame.innerHTML = '';

  // Ensure unlockedHeroes exists (Graham is always available)
  if(!PStats.unlockedHeroes) PStats.unlockedHeroes = ['Graham Moor'];

  // Boss-to-hero unlock mapping for display
  const heroUnlockInfo = {
    'Quivera': { boss: 'Cinna & Antony', icon: icon('yinyang') },
    'Belle Lettres': { boss: 'Red Aktins', icon: icon('scissors') },
    'Alexandria Constanza': { boss: 'Plague Doctor', icon: icon('clipboard') },
    'Caesura': { boss: 'Oxy', icon: icon('crossed-swords') },
    'Reed': { boss: 'Dotdotdot', icon: icon('ellipsis') }
  };

  const container = $("#hero-card-container");
  container.innerHTML = "";

  // Show all heroes, but in demo mode heroes beyond DEMO_HERO_LIMIT are locked
  HEROES.forEach((h, idx) => {
    const isDemoLocked = IS_DEMO && idx >= DEMO_HERO_LIMIT;
    const isUnlocked = !isDemoLocked && PStats.unlockedHeroes.includes(h.name);
    const unlockInfo = heroUnlockInfo[h.name];

    const card = document.createElement("div");
    card.className = "card hero" + (isUnlocked ? '' : ' locked-hero');
    card.style.minWidth = "100%";
    card.style.flex = "0 0 100%";
    card.style.cursor = isUnlocked ? "pointer" : "not-allowed";
    if(!isUnlocked) card.style.opacity = "0.6";

    const passiveHtml = h.passive ? `
      <div class="card-section" style="margin-top:8px">
        <div class="card-section-title">PASSIVE</div>
        <div style="color:#fbbf24;font-weight:bold">${h.passive.name}</div>
        <div style="font-size:12px;color:#9ca3af;margin-top:2px">${h.passive.desc}</div>
      </div>
    ` : '';

    // Demo-locked heroes show "Full Game" message, regular locked show boss requirement
    let lockedOverlay = '';
    if (isDemoLocked) {
      lockedOverlay = `
        <div class="hero-locked-overlay" style="position:absolute;inset:0;background:rgba(0,0,0,0.7);display:flex;flex-direction:column;align-items:center;justify-content:center;border-radius:inherit;z-index:10">
          <div style="font-size:28px;margin-bottom:8px">üîí</div>
          <div style="color:#60a5fa;font-size:12px;font-weight:600;text-transform:uppercase;letter-spacing:0.1em">Full Game</div>
          <div style="color:#9ca3af;font-size:11px;margin-top:4px">Available in full version</div>
        </div>
      `;
    } else if (!isUnlocked && unlockInfo) {
      lockedOverlay = `
        <div class="hero-locked-overlay" style="position:absolute;inset:0;background:rgba(0,0,0,0.7);display:flex;flex-direction:column;align-items:center;justify-content:center;border-radius:inherit;z-index:10">
          <div style="font-size:28px;margin-bottom:8px">üîí</div>
          <div style="color:#f87171;font-size:12px;font-weight:600;text-transform:uppercase;letter-spacing:0.1em">Locked</div>
          <div style="color:#9ca3af;font-size:11px;margin-top:4px">Defeat ${unlockInfo.icon} ${unlockInfo.boss}</div>
        </div>
      `;
    }

    const portraitSvg = getPortraitSVG(h.id);
    const heroLevel = getHeroLevel(h.name);
    card.innerHTML = `
      ${lockedOverlay}
      <div class="hero-select-portrait" style="width:80px;height:80px;margin:0 auto 12px;border-radius:50%;overflow:hidden">${portraitSvg}</div>
      <div class="card-name">${h.name}</div>
      <div style="font-size:11px;color:#9ca3af;margin-bottom:4px;text-transform:uppercase;letter-spacing:0.1em">Level ${heroLevel}</div>
      <div class="card-desc">${h.desc}</div>
      <div class="card-section" style="margin-bottom:4px"><div class="card-section-title">Strong using</div><div>${h.str.map(el=>`<span class="tag str">${EN[el]}</span>`).join("")}</div></div>
      <div class="card-section" style="margin-bottom:4px"><div class="card-section-title">Weak using</div><div>${h.weak.map(el=>`<span class="tag weak">${EN[el]}</span>`).join("")}</div></div>
      <div class="card-section"><div class="card-section-title">PROFICIENCIES</div><div><span class="mod-badge add">${h.good.charAt(0).toUpperCase() + h.good.slice(1)} √ó2</span> <span class="mod-badge neg">${h.bad.charAt(0).toUpperCase() + h.bad.slice(1)} √ó0.5</span></div></div>
      ${passiveHtml}
    `;
    container.appendChild(card);
  });

  updateCarousel();

  $("#hero-prev").onclick = () => {
    currentHeroIndex = (currentHeroIndex - 1 + HEROES.length) % HEROES.length;
    updateCarousel();
  };
  $("#hero-prev").onmouseenter=sfxHover;

  $("#hero-next").onclick = () => {
    currentHeroIndex = (currentHeroIndex + 1) % HEROES.length;
    updateCarousel();
  };
  $("#hero-next").onmouseenter=sfxHover;

  $("#hero-select-btn").onclick = async () => {
    const h = HEROES[currentHeroIndex];

    // Check if hero is demo-locked
    if (IS_DEMO && currentHeroIndex >= DEMO_HERO_LIMIT) {
      // Play error sound and shake button (double-rAF avoids forced reflow)
      const btn = $("#hero-select-btn");
      btn.style.animation = 'none';
      requestAnimationFrame(() => {
        requestAnimationFrame(() => btn.style.animation = 'shake 0.3s ease');
      });
      return;
    }

    // Check if hero is unlocked
    if(!PStats.unlockedHeroes) PStats.unlockedHeroes = ['Graham Moor'];
    if(!PStats.unlockedHeroes.includes(h.name)){
      // Play error sound and shake button (double-rAF avoids forced reflow)
      const btn = $("#hero-select-btn");
      btn.style.animation = 'none';
      requestAnimationFrame(() => {
        requestAnimationFrame(() => btn.style.animation = 'shake 0.3s ease');
      });
      return;
    }

    // Scene transition from hero select to battle - show round intro at peak
    await playSceneTransition(async () => {
      S.hero = {...h};
      S.heroId = h.id; // Store hero ID separately for easier lookup
      S.heroSelected = true;
      // Initialize lives (default 1)
      S.lives = 1;

      // Apply skill tree bonuses
      const heroName = S.hero.name;
      initHeroSkills(heroName);
      S.heroSkillBonuses = getHeroSkillBonuses(heroName);

      // Apply starting gold bonus from skills
      const startGoldBonus = S.heroSkillBonuses.startGold || 0;
      if (startGoldBonus > 0) {
        S.gold += startGoldBonus;
      }

      // Apply HERO_INIT modifiers (e.g., Paladin's Vigilant passive)
      applyModifiers('HERO_INIT', {hero: S.hero, state: S});
      $("#hero-select-overlay").classList.remove("show");

      // Show menu and sound buttons now that game has started
      const pauseBtn = document.getElementById('pause-btn');
      const soundBtn = document.getElementById('sound-btn');
      const header = document.getElementById('header');
      if (pauseBtn) pauseBtn.style.display = '';
      if (soundBtn) soundBtn.style.display = '';
      if (header) header.style.display = '';

      // Start music engine fresh with bass-only after hero selection
      if (musicEngine) {
        // Ensure Tone.js context is running
        if (typeof Tone !== 'undefined' && Tone.context && Tone.context.state !== 'running') {
          await Tone.start();
        }
        if (!musicEngine.initialized) {
          await musicEngine.init();
        }
        // Reset to bass-only to clear any leftover instrument layers from previous run
        musicEngine.resetToBassOnly();
        musicEngine.setMuted(!audioOn);
        if (!musicEngine.playing) {
          await musicEngine.start();
        }
      }

      newEnc();

      // Start round intro at the transition peak (while screen is dark)
      showRoundIntro();

      // Save run state after hero selection (prevents losing hero choice on crash)
      saveRun();
    });

    // Wait for intro to be dismissed by player
    await waitForIntroDismiss();

    // Start onboarding for first-time players (Graham Moor, Round 1)
    if (shouldStartOnboarding() && S.hero.name === 'Graham Moor') {
      await startOnboarding();
    }

    render();
  };
  $("#hero-select-btn").onmouseenter=sfxHover;

  // Close button to return to main menu
  $("#hero-select-close").onclick = async () => {
    // Prevent rapid clicking during transitions
    if (isTransitioning) return;
    playSfxBack();
    // Unified transition: hide hero select AND show main menu at peak
    await playSceneTransition(() => {
      $("#hero-select-overlay").classList.remove("show");
      showMainMenu(true); // true = skip stopping music
    });
  };
  $("#hero-select-close").onmouseenter=sfxHover;

  // Start screen Hero Skills button
  $("#start-hero-skills").onclick = () => { showSkillTree(HEROES[currentHeroIndex].name); };
  $("#start-hero-skills").onmouseenter = sfxHover;

  const heroOverlay = document.getElementById('hero-select-overlay');
  if(heroOverlay) heroOverlay.classList.add('instant-show');
  showOverlay(heroOverlay || "#hero-select-overlay");
}

function updateCarousel(){
  const container = $("#hero-card-container");
  container.style.transform = `translateX(-${currentHeroIndex * 100}%)`;

  // Update select button based on whether hero is unlocked
  const h = HEROES[currentHeroIndex];
  if(!PStats.unlockedHeroes) PStats.unlockedHeroes = ['Graham Moor'];
  const isUnlocked = PStats.unlockedHeroes.includes(h.name);
  const btn = $("#hero-select-btn");
  if(btn){
    btn.disabled = !isUnlocked;
    btn.textContent = isUnlocked ? 'SELECT HERO' : 'LOCKED';
    btn.style.opacity = isUnlocked ? '1' : '0.5';
    btn.style.cursor = isUnlocked ? 'pointer' : 'not-allowed';
  }
  // Update difficulty selector for new hero (per-hero difficulty unlocks)
  setupDifficultySelector();
}

function newEnc(){
  if(!S.heroSelected){showHeroSelect();return}

  // Reset per-battle tracking
  S.toolUsedThisBattle = false;

  // Reset dialogue indices for portrait click cycling
  S.heroDialogueIndex = 0;
  S.enemyDialogueIndex = 0;

  // Restore forge, battle-view and word-bank display (may have been hidden by showMainMenu/showHeroSelect)
  const forge=document.getElementById('forge');
  if(forge) forge.style.display='';
  const battleView=document.getElementById('battle-view');
  if(battleView) battleView.style.display='';
  const wordBank=document.getElementById('word-bank');
  if(wordBank) wordBank.style.display='';

  // Scale enemy based on roundIndex - exponential scaling.
  // Use the cached preview enemy so the shop preview matches the upcoming fight.
  const isChapterBossRound = S.roundIndex % 9 === 0;

  if(!S.nextEnemyData){
    const baseEnemy = ENEMIES[Math.random()*ENEMIES.length|0] || ENEMIES[0];
    S.nextEnemyData = {...baseEnemy};
    randomizeEnemyElements(S.nextEnemyData);
  }
  S.enemy = {...S.nextEnemyData};

  // Block-based HP: 3-round blocks with Small/Big/Boss multipliers,
  // exponential growth between blocks
  S.enemy.hp = enemyHp(S.roundIndex);

  // Apply HP multiplier for secret boss
  if(S.enemy.hpMultiplier){
    S.enemy.hp = Math.round(S.enemy.hp * S.enemy.hpMultiplier);
  }

  // Determine boss type:
  // - Chapter Boss: Round 9, 18, 27... (every 9th round) - unique character with ability
  // - Miniboss: Round 3, 6, 12, 15, 21, 24... (every 3rd, not chapter boss) - stat boost only
  const isChapterBoss = isChapterBossRound;
  const isMiniboss = S.roundIndex % 3 === 0 && !isChapterBoss;

  // Minibosses get stat boost (chapter bosses are handled separately with their own scaling)
  if(isMiniboss){
    S.enemy.hp = Math.round(S.enemy.hp * 1.3);
    S.enemy.ap = Math.round(S.enemy.ap * 1.2);
    S.enemy.boss = true;
    S.enemy.isMiniboss = true;
  } else if(!isChapterBoss){
    // Regular enemy (not miniboss, not chapter boss)
    S.enemy.boss = false;
  }
  // Note: Chapter bosses set their own boss flag and HP scaling in the section below

  // Chapter Boss: Select from CHAPTER_BOSSES pool (no repeats until exhausted)
  // 5% chance to spawn SECRET_CHAPTER_BOSS (The Silent Knight) instead
  if(isChapterBoss){
    let selectedBoss;

    // Use pre-selected boss from shop preview if available
    if(S.nextChapterBoss){
      selectedBoss = S.nextChapterBoss;
      S.nextChapterBoss = null;
    } else {
      // 5% chance to spawn The Silent Knight as a rare secret chapter boss
      if(Math.random() < SECRET_BOSS_SPAWN_CHANCE){
        selectedBoss = SECRET_CHAPTER_BOSS;
      } else {
        // Normal chapter boss selection (no repeats until exhausted)
        let availableBosses = CHAPTER_BOSSES.filter(b => !S.foughtChapterBosses.includes(b.id));
        if(availableBosses.length === 0){
          S.foughtChapterBosses = [];
          availableBosses = [...CHAPTER_BOSSES];
        }
        selectedBoss = availableBosses[Math.floor(Math.random() * availableBosses.length)];
      }
    }

    // Track fought bosses (except secret boss, which can always appear)
    if(!selectedBoss.isSecretBoss){
      S.foughtChapterBosses.push(selectedBoss.id);
    }
    S.chapterBoss = selectedBoss;

    // Override enemy name with chapter boss name
    S.enemy.name = selectedBoss.name;
    S.enemy.desc = selectedBoss.desc;
    S.enemy.dialogue = selectedBoss.dialogue;
    S.enemy.isChapterBoss = true;
    S.enemy.isSecretBoss = selectedBoss.isSecretBoss || false;
    S.enemy.ability = selectedBoss.ability;
    S.enemy.id = selectedBoss.id;

    // Chapter bosses: 1 weakness, 2 resistances (unless they have custom arrays)
    if(selectedBoss.weak){
      S.enemy.weak = [...selectedBoss.weak];
    } else {
      S.enemy.weak = S.enemy.weak.slice(0, 1); // 1 weakness
    }
    if(selectedBoss.res){
      S.enemy.res = [...selectedBoss.res];
    } else {
      S.enemy.res = S.enemy.res.slice(0, 2); // Keep 2 resistances (strengths)
    }

    // Apply boss HP scaling
    // Secret boss uses hpMultiplier, normal chapter bosses use 1.3x
    if(selectedBoss.hpMultiplier){
      S.enemy.hp = Math.round(S.enemy.hp * selectedBoss.hpMultiplier);
    } else {
      S.enemy.hp = Math.round(S.enemy.hp * 1.3);
    }
    S.enemy.boss = true;
    S.enemy.isBoss = true;

    // Red Aktins: Block a random word slot (excluding weapon)
    if(selectedBoss.id === 'red_aktins'){
      const blockableSlots = ['adj1', 'adj2', 'adj3', 'adj4', 'noun1'];
      S.blockedSlot = blockableSlots[Math.floor(Math.random() * blockableSlots.length)];
    } else {
      S.blockedSlot = null;
    }

    // Chapter bosses have 1 fewer weakness (makes them harder)
    // Belle Lettres passive adds +2 weaknesses separately, so this won't conflict
    if(S.enemy.weak && S.enemy.weak.length > 1){
      S.enemy.weak = S.enemy.weak.slice(0, S.enemy.weak.length - 1);
    }
  } else {
    S.chapterBoss = null;
    S.enemy.isChapterBoss = false;
    S.enemy.ability = null;
    S.blockedSlot = null;
  }

  // Apply ENEMY_SETUP modifiers (hero passives, future boss modifiers)
  applyModifiers('ENEMY_SETUP', {hero: S.hero, enemy: S.enemy, state: S});

  // Consume cached preview so the next shop call will roll a fresh foe
  S.nextEnemyData = null;

  // [T2] Shadow Pact: Apply HP steal from previous dark word use
  if(S.shadowBonusHP > 0){
    S.enemy.hp = Math.max(1, S.enemy.hp - S.shadowBonusHP);
    S.shadowBonusHP = 0; // Reset after applying
  }

  render();
}

// === RENDER ===
function render(){
  // Safety check: only render if hero and enemy are selected
  if(!S.hero || !S.enemy) return;

  // === PERFORMANCE TRACKING: Render breakdown ===
  const _renderStart = performance.now();
  const _rt = {}; // render timings

  const h=S.hero;
  const e=S.enemy;
  // Get effective enemy after applying modifiers (e.g., Reed's gem weakness)
  const effectiveEnemy = getEffectiveEnemy();

  // Portrait names (enemy name includes boss badge if applicable)
  const heroNameEl = $("#hero-name");
  const enemyNameEl = $("#enemy-name");
  if(heroNameEl) heroNameEl.textContent=h.name;
  if(enemyNameEl){
    // Add boss/miniboss badge next to enemy name
    let nameBadge = '';
    if(e.isChapterBoss){
      nameBadge = ' <span class="tag ability" style="font-size:9px;padding:1px 6px;vertical-align:middle">Boss</span>';
    } else if(S.roundIndex % 3 === 0){
      nameBadge = ' <span class="tag ability" style="font-size:9px;padding:1px 6px;vertical-align:middle">Mini-Boss</span>';
    }
    enemyNameEl.innerHTML = e.name + nameBadge;
  }

  // Render SVG portraits
  const heroPortraitFrame = document.querySelector('.hero-portrait .portrait-frame');
  const enemyPortraitFrame = document.querySelector('.enemy-portrait .portrait-frame');
  if(heroPortraitFrame && h.id) {
    renderPortrait(heroPortraitFrame, h.id, '#4ade80');
  }
  if(enemyPortraitFrame && e.id) {
    // Use boss portrait if chapter boss, otherwise regular enemy portrait
    const portraitId = e.isChapterBoss ? e.id : e.id;
    renderPortrait(enemyPortraitFrame, portraitId, '#f87171');
  }

  // Populate hero and enemy element tags on portraits
  // Calculate total damage with multiplier for display
  const _calcStart = performance.now();
  const c=calc();
  _rt.calcMs = performance.now() - _calcStart;
  const totalDmg = c.heroDmg || 0;
  // Cache for spark manager intensity (avoids calling calc() every frame)
  S.lastCalcDmg = totalDmg;
  // Do not display hero AP on the portrait; AP is shown in the damage preview instead
  const heroApTag = "";
  const heroStrTags=h.str.map(el=>`<span class="tag str">${EN[el]}</span>`).join("");
  const heroWeakTags=h.weak.map(el=>`<span class="tag weak">${EN[el]}</span>`).join("");
  // Determine proficiency display: if Weapon Master is active, treat all weapons as good
  const hasWM=!!(S.tempEffects && S.tempEffects.weaponMaster);
  const hasOvercoming = S.talents && S.talents.includes('overcoming');
  const capFirst = s => s ? s.charAt(0).toUpperCase() + s.slice(1) : '';
  let heroProfHtml="";
  if(hasWM){
    const wmMult = S.tempEffects.weaponMaster || 3;
    heroProfHtml=`<span class="tag prof">All Weapons √ó${wmMult} (Weapon Master)</span>`;
  }else if(hasOvercoming){
    // Overcoming: bad proficiency becomes good (√ó1.5)
    heroProfHtml=`<span class="tag prof">${capFirst(h.good)} √ó2</span><span class="tag prof">${capFirst(h.bad)} √ó1.5 <span style="font-size:9px;opacity:0.7">(Overcoming)</span></span>`;
  }else{
    heroProfHtml=`<span class="tag prof">${capFirst(h.good)} √ó2</span><span class="tag weak">${capFirst(h.bad)} √ó0.5</span>`;
  }
  const heroElementsEl = $("#hero-elements");
  if(heroElementsEl) heroElementsEl.innerHTML=heroApTag+heroStrTags+heroWeakTags+heroProfHtml;

  // Enemy portrait: show only weaknesses and resistances (AP removed)
  // Use effectiveEnemy to show modified state (e.g., Reed's passive adding gem weakness)
  const hasIrony = S.talents && S.talents.includes('irony');
  const enemyWeakTags=effectiveEnemy.weak.map(el=>`<span class="tag str">${EN[el]}</span>`).join("");
  const resList = (S.tempEffects && S.tempEffects.polymorph) ? [] : effectiveEnemy.res;
  // When Irony talent is active, FIRST resistance becomes weakness - show with special badge
  const enemyResTags=resList.length?resList.map((el, idx)=>{
    if(hasIrony && idx === 0){
      return `<span class="tag irony">${EN[el]} <span class="irony-badge">Irony</span></span>`;
    }
    return `<span class="tag weak">${EN[el]}</span>`;
  }).join(""):"";

  // Boss type tag is now shown next to the enemy name, so we skip it here

  // Chapter boss ability tag (plain text, no tooltip)
  let bossAbilityTag = '';
  if(e.isChapterBoss && e.ability){
    // Check if boss ability is disabled by Shackles
    const abilityDisabled = S.tempEffects && S.tempEffects.disableBossAbility;
    if(abilityDisabled){
      bossAbilityTag = `<span class="tag ability" style="opacity:0.5;text-decoration:line-through">${e.ability.name}: SILENCED</span>`;
    } else {
      let abilityDesc = e.ability.desc;
      // For Red Aktins, show which slot is blocked
      if(S.chapterBoss && S.chapterBoss.id === 'red_aktins' && S.blockedSlot){
        const slotNames = {adj1: 'Prefix 1', adj2: 'Prefix 2', adj3: 'Suffix 1', adj4: 'Suffix 2', noun1: 'Gem'};
        abilityDesc = `${slotNames[S.blockedSlot]} [REDACTED]`;
      }
      bossAbilityTag = `<span class="tag ability">${e.ability.name}: "${abilityDesc}"</span>`;
    }
  }

  const enemyElementsEl = $("#enemy-elements");
  if(enemyElementsEl) enemyElementsEl.innerHTML=enemyWeakTags+enemyResTags+bossAbilityTag;

  // Health bars with dynamic preview
  updateHealthBars();

  // Details panels (hidden by default)
  // Update HP in details panel (Base AP removed)
  const heroApDiv = document.getElementById("hero-ap");
  if(heroApDiv){
    heroApDiv.textContent = `HP: ${h.hp}`;
  }
  const heroDescEl = $("#hero-desc");
  const heroDialogueEl = $("#hero-dialogue");
  if(heroDescEl) heroDescEl.textContent=h.desc;

  // Use enemy-specific dialogue if enemy exists, otherwise generic
  const enemySpecificLine = S.enemy ? getHeroEnemyDialogue(h.id, S.enemy.id) : null;
  const heroLine = enemySpecificLine || h.dialogue[Math.random()*h.dialogue.length|0];
  if(heroDialogueEl) heroDialogueEl.textContent=`"${heroLine}"`;

  // Also update the inline portrait dialogue (no quotes) for the hero
  {
    const inline = document.getElementById('hero-inline-dialogue');
    if(inline){
      inline.textContent = heroLine;
    }
  }
  const heroStrEl = $("#hero-str");
  const heroWeakEl = $("#hero-weak");
  const heroProfEl = $("#hero-prof");
  if(heroStrEl) heroStrEl.innerHTML=h.str.map(el=>`<span class="tag str">${EN[el]}</span>`).join("");
  if(heroWeakEl) heroWeakEl.innerHTML=h.weak.map(el=>`<span class="tag weak">${EN[el]}</span>`).join("");
  // Update proficiency display in details panel: reflect Weapon Master if active
  if(heroProfEl){
    if(hasWM){
      const wmMult = S.tempEffects.weaponMaster || 3;
      heroProfEl.innerHTML=`<span class="tag prof">All Weapons √ó${wmMult} W (Weapon Master)</span>`;
    }else{
      heroProfEl.innerHTML=`<span class="tag prof">${h.good} √ó2.0 W</span><span class="tag weak">${h.bad} √ó0.5 W</span>`;
    }
  }

  const enemyDescEl = $("#enemy-desc");
  const enemyDialogueEl = $("#enemy-dialogue");
  if(enemyDescEl) enemyDescEl.textContent=e.desc;
  if(enemyDialogueEl) enemyDialogueEl.textContent=`"${e.dialogue[Math.random()*e.dialogue.length|0]}"`;
  // And update the inline dialogue beneath the enemy portrait
  {
    const inlineE = document.getElementById('enemy-inline-dialogue');
    if(inlineE){
      const line2 = e.dialogue[Math.random()*e.dialogue.length|0];
      inlineE.textContent = line2;
    }
  }
  // Use effectiveEnemy to show modified state in details panel too
  const enemyWeakEl = $("#enemy-weak");
  const enemyResEl = $("#enemy-res");
  if(enemyWeakEl) enemyWeakEl.innerHTML=effectiveEnemy.weak.map(el=>`<span class="tag str">${EN[el]}</span>`).join("");
  const enemyDetailRes = (S.tempEffects && S.tempEffects.polymorph) ? [] : effectiveEnemy.res;
  // Details panel also shows Irony badge when active (only FIRST resistance)
  if(enemyResEl) enemyResEl.innerHTML=enemyDetailRes.length?enemyDetailRes.map((el, idx)=>{
    if(hasIrony && idx === 0){
      return `<span class="tag irony">${EN[el]} <span class="irony-badge">Irony</span></span>`;
    }
    return `<span class="tag weak">${EN[el]}</span>`;
  }).join(""):"";

  // Header stats
  if(document.getElementById('gold')) document.getElementById('gold').textContent = S.gold;
  if(document.getElementById('level')) document.getElementById('level').textContent = S.level;
  if(document.getElementById('round-num')) document.getElementById('round-num').textContent = S.roundIndex;
  // Chapter number (every 9 rounds = 1 chapter)
  const chapter = Math.floor((S.roundIndex - 1) / 9) + 1;
  if(document.getElementById('chapter-num')) document.getElementById('chapter-num').textContent = chapter;

  // Update gold pill with inline interest display (uses difficulty multiplier)
  const { totalInterest } = calculateInterest();
  const goldInterestEl = document.getElementById('gold-interest');
  if(goldInterestEl){
    goldInterestEl.textContent = totalInterest > 0 ? `| +${totalInterest}` : '';
  }

  // Lives counter (only shown for Paladin or when extra lives exist)
  const livesCounter = document.getElementById('lives-counter');
  const livesEl = document.getElementById('lives');
  if(livesCounter && livesEl){
    if(S.hero && S.hero.id === 'paladin' && S.lives > 0){
      livesCounter.style.display = '';
      livesEl.textContent = S.lives;
    } else {
      livesCounter.style.display = 'none';
    }
  }

  // Clear hero talents container - talents are displayed in talent bar and shop overlay
  const talentsEl = document.getElementById("hero-talents");
  if(talentsEl) talentsEl.innerHTML = '';

  // Update inventory counter (current count / limit)
  // Only count visible words (exclude hiddenInBank words)
  const visibleCount = S.inv.filter(w => !w.hiddenInBank).length;
  const invCounterText = document.getElementById("inv-counter-text");
  if(invCounterText){
    invCounterText.textContent = `${visibleCount}/${INV_LIMIT}`;
  }
  // Update breakdown tooltip
  const tooltipEl = document.getElementById('inv-breakdown-tooltip');
  if(tooltipEl) tooltipEl.innerHTML = generateInvBreakdown();

  const _slotsStart = performance.now();
  updSlots();
  _rt.updSlotsMs = performance.now() - _slotsStart;

  const _bankStart = performance.now();
  renderBank(false, _fastRemoveWordId);
  _fastRemoveWordId = null; // Clear after use
  _rt.renderBankMs = performance.now() - _bankStart;

  const _consStart = performance.now();
  renderConsumables();
  _rt.renderConsMs = performance.now() - _consStart;

  const _talStart = performance.now();
  renderTalents();
  _rt.renderTalentsMs = performance.now() - _talStart;

  const _weapStart = performance.now();
  renderWeapon();
  _rt.renderWeaponMs = performance.now() - _weapStart;

  const _slotCalcStart = performance.now();
  updateSlotCalcs();
  _rt.updateSlotCalcsMs = performance.now() - _slotCalcStart;

  // Ensure forge button state is always correct at end of render
  const forgeBtn = document.getElementById("forge-btn");
  if(forgeBtn) {
    forgeBtn.disabled = !S.sel.item;
  }

  _rt.totalMs = performance.now() - _renderStart;

  // Log render breakdown if debug enabled and this was a slow render (>8ms)
  if (typeof window.logPerfEvent === 'function' && _rt.totalMs > 8) {
    window.logPerfEvent('RENDER', _rt);
  }
}

function updateHealthBars(){
  const h=S.hero,e=S.enemy;

  // Hide hero health bar and text. Hero HP is no longer tracked.
  const heroBar = document.getElementById('hero-health-fill');
  const heroText = document.getElementById('hero-health-text');
  if(heroBar) heroBar.style.width = '0%';
  if(heroText) heroText.textContent = '';

  // Enemy health always starts full for preview
  $("#enemy-health-fill").style.width="100%";
  // Show carried overkill from Hyperbole if present
  const enemyHpText = document.getElementById('enemy-health-text');
  if(S.carriedOverkill > 0){
    enemyHpText.innerHTML = `${fmtBig(e.hp)} / ${fmtBig(e.hp)} <span style="color:#f472b6;font-size:10px">(-${fmtBig(S.carriedOverkill)} Hyperbole)</span>`;
  } else {
    enemyHpText.textContent = `${fmtBig(e.hp)} / ${fmtBig(e.hp)}`;
  }

  // Calculate and show damage preview
  if(S.sel.item){
    const c=calc({breakdown: true});
    const heroDmg=Math.round(c.heroDmg);
    const enemyDmg=Math.round(c.enemyDmg);
    const fmtVal = (v)=>Number.isInteger(v)?v:parseFloat(v.toFixed(2));
    const calcLine = `${fmtVal(c.baseAP)} AP √ó ${fmtVal(c.wordCount)}`;

    // Show final damage as the main number (remove italic subtext - badges show same info)
    $("#preview-hero-dmg").textContent = fmtBig(heroDmg);
    $("#preview-base-ap").textContent = ''; // Clear the old subtext

    // Build badges showing TOTAL values (not just bonuses)
    const badgesEl = document.getElementById('preview-bonus-badges');
    if(badgesEl){
      const badges = [];

      // Show total AP
      badges.push(`<span class="mod-badge add">${fmtVal(c.baseAP)} AP</span>`);

      // Show total W (word count)
      const totalW = c.breakdown ? c.breakdown.wordCount : c.wordCount;
      badges.push(`<span class="mod-badge word">${fmtVal(totalW)} W</span>`);

      // Show multiplier if > 1
      if(c.totalMultiplier > 1){
        badges.push(`<span class="mod-badge scale">√ó${fmtVal(c.totalMultiplier)}</span>`);
      }

      badgesEl.innerHTML = badges.join('');
    }

    // Highlight preview panel when damage meets or exceeds enemy HP
    const previewPanel = document.getElementById("damage-preview-text");
    if(previewPanel){
      previewPanel.classList.toggle("goal-achieved", heroDmg >= e.hp);
    }

    // Update enemy HP text to show remaining HP after preview damage
    const remainingHP = Math.max(e.hp - heroDmg, 0);
    document.getElementById('enemy-health-text').textContent = `${fmtBig(remainingHP)} / ${fmtBig(e.hp)}`;
    // Show enemy damage preview (red bar showing how much HP will be lost)
    const enemyDmgPercent = (heroDmg / e.hp) * 100;
    const edp = document.getElementById('enemy-damage-preview');
    edp.style.width = `${enemyDmgPercent}%`;
    edp.style.display = "block";
    // Trigger blink animation on the damage preview bar (double-rAF avoids forced reflow)
    edp.classList.remove('blink');
    requestAnimationFrame(() => {
      requestAnimationFrame(() => edp.classList.add('blink'));
    });

    // Hide hero damage preview since enemy no longer deals damage
    $("#hero-damage-preview").style.display="none";

    // Color code the damage number based on outcome
    if(heroDmg >= e.hp){
      $("#preview-hero-dmg").style.color = "#4ade80";
      $("#preview-hero-dmg").style.fontWeight = "bold";
    } else {
      $("#preview-hero-dmg").style.color = "#fb923c";
      $("#preview-hero-dmg").style.fontWeight = "";
    }
  }else{
    // Show 0 damage when no weapon selected
    $("#preview-hero-dmg").textContent="0";
    $("#enemy-damage-preview").style.display="none";
    $("#hero-damage-preview").style.display="none";

    // Clear calculation and remove highlight when no weapon
    $("#preview-base-ap").textContent = '';
    const previewPanel = document.getElementById("damage-preview-text");
    if(previewPanel){
      previewPanel.classList.remove("goal-achieved");
    }
    // Clear bonus badges
    const badgesEl = document.getElementById('preview-bonus-badges');
    if(badgesEl) badgesEl.innerHTML = '';
  }

  // Update music layers based on forge state
  if (musicEngine && musicEngine.initialized) {
    musicEngine.updateLayers(S);
  }
}

function updateEnemyCalc(){
  const h=S.hero,e=S.enemy;
  const defMult=h.str.includes(e.atk)?0.7:h.weak.includes(e.atk)?1.5:1;
  const finalDmg=Math.round(e.ap*defMult);
  const calc=$("#enemy-calc");
  if(defMult<1){calc.className="enemy-atk-calc reduced";calc.textContent=`${e.ap}√ó0.7 = ${finalDmg} ‚úì`}
  else if(defMult>1){calc.className="enemy-atk-calc amplified";calc.textContent=`${e.ap}√ó1.5 = ${finalDmg} ‚ö†`}
  else{calc.className="enemy-atk-calc neutral";calc.textContent=`= ${finalDmg} dmg`}
}

function hasWeapons(){return S.inv.some(w=>w.type==="weapon")}

function updSlots(){
  const hasItem = !!S.sel.item;
  const hasNoun = !!S.sel.noun1;

  // Dynamic slot visibility: only weapon slot shown by default. When a weapon is selected,
  // reveal the gem slot. Once the gem slot is filled, reveal adjective slots. The "of" label
  // appears only when both a weapon and a gem are present.
  // Determine visibility of slots. Show the gem slot as soon as a weapon is selected.
  // Show the first two adjective slots (adj1, adj2) when a weapon is present. Show the
  // remaining adjective slots (adj3, adj4) only after a gem has been selected. Always
  // display the "of (the)" label once a weapon is chosen so players understand the
  // construction of the phrase even before a gem is applied.
  const showAdj12 = hasItem;
  const showAdj34 = hasItem && hasNoun;

  // If the gem was removed, return hidden suffix adjectives (adj3/adj4) to inventory
  if (!hasNoun) {
    ['adj3','adj4'].forEach(k => {
      const w = S.sel[k];
      if (w) {
        if (!S.inv.includes(w)) S.inv.push(w);
        S.sel[k] = null;
      }
    });
  }

  // Toggle visibility for the first two adjective slots
  ['adj1','adj2'].forEach(k => {
    const cont = document.querySelector(`[data-slot="${k}"].slot-container`);
    if(cont) cont.classList.toggle('hidden', !showAdj12);
  });
  // Toggle visibility for the last two adjective slots
  ['adj3','adj4'].forEach(k => {
    const cont = document.querySelector(`[data-slot="${k}"].slot-container`);
    if(cont) cont.classList.toggle('hidden', !showAdj34);
  });
  // Show the gem slot only if a weapon is selected
  const nounCont = document.querySelector('[data-slot="noun1"].slot-container');
  if(nounCont) nounCont.classList.toggle('hidden', !hasItem);
  // Show "of (the)" label whenever a weapon is selected
  $('#of-label').classList.toggle('hidden', !hasItem);

  // Cache all slots upfront to avoid repeated querySelector calls
  const slots = {};
  ["item","adj1","adj2","adj3","adj4","noun1"].forEach(k => {
    slots[k] = $(`[data-slot="${k}"].slot`);
  });

  // Batch DOM operations
  const elemClasses = ['elem-physical','elem-poison','elem-fire','elem-water','elem-light','elem-dark','elem-earth','elem-lightning'];
  const elemNames = ['physical','poison','fire','water','light','dark','earth','lightning'];

  ["item","adj1","adj2","adj3","adj4","noun1"].forEach(k=>{
    const slot = slots[k];
    if(!slot) return;
    const w=S.sel[k];

    // Clear any previous tooltip elements first
    const existingTip = slot.querySelector('.tooltip');
    if(existingTip) existingTip.remove();
    // Remove tooltip class hooks
    slot.classList.remove('has-tooltip');
    slot.removeAttribute('tabindex');
    slot.__tooltipContent = null;

    // Red Aktins REDACTED overlay handling (disabled if Silencer is active)
    const silencerActive = S.tempEffects && S.tempEffects.disableBossAbility;
    const isBlocked = S.blockedSlot === k && !silencerActive;
    slot.classList.toggle('redacted-slot', isBlocked);
    // Remove existing REDACTED overlay if present
    const existingRedacted = slot.querySelector('.redacted-overlay');
    if(existingRedacted) existingRedacted.remove();
    if(isBlocked){
      const redactedOverlay = document.createElement('div');
      redactedOverlay.className = 'redacted-overlay';
      redactedOverlay.textContent = 'REDACTED';
      slot.appendChild(redactedOverlay);
    }

    if(w){
      // --- FILLED SLOT LOGIC ---
      const rc = TC[w.rarity];
      const displayName = getDisplayForm(w, k, S.sel);
      // Add pop-in animation class if this slot just had a word placed
      const popInClass = (justPlacedSlot === k) ? ' popping-in' : '';
      slot.innerHTML = `<span class="${rc} slot-content${popInClass}" draggable="false">${displayName}</span>`;
      slot.classList.add("filled");
      // Clear the flag after using it
      if (justPlacedSlot === k) justPlacedSlot = null;

      // --- Element Accent for ALL Slots ---
      // Apply element class for gradient top border accent (matches modal style)
      slot.classList.remove(...elemClasses);
      if (w.elem !== undefined) {
        slot.classList.add(`elem-${elemNames[w.elem]}`);
      }

      // --- Dynamic Gem Slot Coloring (more prominent) ---
      if (k === 'noun1') {
        let glowColor = '#9ca3af'; // Default: Common Gray

        if (w.elem !== undefined) {
          // Case A: Word has an element -> Use Element Color
          // EC is defined at top of script.js: [Phys, Poison, Fire, Water, Light, Dark, Earth, Lightning]
          glowColor = EC[w.elem];
        } else {
          // Case B: Non-elemental -> Use Tier Color
          const rank = w.rarity || 0;
          if (rank === 2) glowColor = '#60a5fa'; // Magic Blue
          else if (rank >= 3) glowColor = '#f4d03f'; // Rare Gold
        }

        // Use CSS custom property instead of inline styles for better performance
        slot.style.setProperty('--glow-color', glowColor);
        slot.classList.add('gem-slot-filled');
      }

      // --- Signature Style: Iridescent weapon slot ---
      const hasSignatureStyle = S.talents && S.talents.includes('signature_style');
      if (k === 'item' && hasSignatureStyle && !w.isStick && w.category === S.hero.good) {
        // Apply iridescent effect when proficient weapon + Signature Style
        slot.classList.add('signature-style-active');
      } else if (k === 'item') {
        slot.classList.remove('signature-style-active');
      }

      // --- ATTACH TOOLTIP (Only if filled) ---
      attachDamageTooltip(slot);
      slot.__tooltipContent = () => mkTooltip(w, { bare: true });
      const tipEl = slot.querySelector('.tooltip.modal-tooltip, .tooltip');
      if(tipEl) tipEl.innerHTML = slot.__tooltipContent();

    } else {
      // --- EMPTY SLOT LOGIC ---

      // Clean up element accent classes when empty
      slot.classList.remove(...elemClasses);

      // Clean up dynamic styles when empty (gem slot)
      if (k === 'noun1') {
        slot.classList.remove('gem-slot-filled');
        slot.style.removeProperty('--glow-color');
      }
      // Clean up signature style class when weapon slot is empty
      if (k === 'item') {
        slot.classList.remove('signature-style-active');
      }

      // Crown Jewel talent doubles the Gem slot multiplier (2x -> 4x)
      const hasCrownJewel = S.talents && S.talents.includes('crown_jewel');
      const gemLabel = hasCrownJewel ? "Gem (4x W)" : "Gem (2x W)";
      const labels={
        item:"Weapon",
        adj1:"Adjective",
        adj2:"Adjective",
        adj3:"Adjective",
        adj4:"Adjective",
        noun1: gemLabel
      };
      slot.innerHTML = labels[k] || "";
      slot.classList.remove("filled");

      // FIX 1: Do NOT attach damage tooltip here.
      // We explicitly leave out attachDamageTooltip(slot).
    }
  });
}

function updateSlotCalcs(){
  const s=S.sel;
  const hasTalent = (id) => S.talents && S.talents.includes(id);

  // Safety check: ensure game state is initialized
  if(!S.hero || !S.enemy){
    const forgeButton = document.getElementById("forge-btn");
    if (forgeButton) forgeButton.disabled = !S.sel.item;
    return;
  }

  // If no weapon selected, clear all displays
  if(!s.item){
    ["item","adj1","adj2","adj3","adj4","noun1"].forEach(k=>{
      const el = $("#calc-" + k);
      const multEl = document.getElementById('mult-' + k);
      if(el) {
        el.textContent = "";
        el.className = "slot-calc"; // Reset to base class, removing positive/negative
      }
      if(multEl) multEl.textContent = "";
    });
    const forgeButton = document.getElementById("forge-btn");
    if (forgeButton) forgeButton.disabled = true;
    return;
  }

  // Run actual calc() to get real computed values
  let calcResult, wordDataMap, retriggeredWords;
  try {
    calcResult = calc({wantBreakdown: true});
    wordDataMap = calcResult.wordDataMap;
    retriggeredWords = calcResult.retriggeredWords || [];
  } catch(err) {
    console.error("[updateSlotCalcs] calc() error:", err);
    // Fall back to clearing displays if calc fails
    ["item","adj1","adj2","adj3","adj4","noun1"].forEach(k=>{
      const el = $("#calc-" + k);
      const multEl = document.getElementById('mult-' + k);
      if(el) {
        el.textContent = "";
        el.className = "slot-calc"; // Reset to base class
      }
      if(multEl) multEl.textContent = "";
    });
    // Still update forge button state even if calc fails
    const forgeButton = document.getElementById("forge-btn");
    if (forgeButton) forgeButton.disabled = !S.sel.item;
    return;
  }

  // Helper to count retriggers for a specific word
  function getRetriggerCount(word) {
    if(!word) return 0;
    return retriggeredWords.filter(r => r.word === word).length;
  }

  // Helper to get display info from wordDataMap
  function getWordDisplay(word, slotKey) {
    if(!word) return {apText:"",multText:"",className:"",wordCountText:""};

    // Get actual contribution from calc()
    const wordData = wordDataMap.get(word);
    if(!wordData) return {apText:"",multText:"",className:"",wordCountText:""};

    // Show decimals for AP values (0.5AP, 0.75AP, etc.)
    const apValue = wordData.apContribution;
    const apDisplay = Number.isInteger(apValue) ? apValue : parseFloat(apValue.toFixed(2));

    // Determine className based on AP value
    let className = "";
    if(apValue === 0) className = "negative";
    else if(apValue > 0) className = "positive";

    const apText = `${apDisplay}AP`;

    // Build multiplier text
    let multParts = [];

    // Word's intrinsic multiplier (not in gem slot)
    if (word.mult !== undefined && slotKey !== 'noun1') {
      multParts.push(fmtMod(word.mult, 'scale'));
    }

    // Talent-based per-word multipliers (e.g., Eclipse √ó2.5, One With Nature √ó1.5)
    if (wordData.talentMults && wordData.talentMults.length > 0) {
      wordData.talentMults.forEach(tm => {
        multParts.push(`<span class="mod-badge scale" title="${tm.name}">√ó${tm.mult}</span>`);
      });
    }

    const multText = multParts.join(' ');

    // Word count contribution from calc (includes gem/proficiency/talents that are per-word)
    // Include wTalentBonus so +W from talents is shown (and REREADs with the word)
    const baseWCount = wordData.wCountTotal ?? wordData.wCountDelta ?? 1;
    const wCount = baseWCount + (wordData.wTalentBonus || 0);
    const wCountDisplay = Number.isInteger(wCount) ? wCount : parseFloat(wCount.toFixed(2));
    let wordCountText = wCount ? `<span class="mod-badge word">+${wCountDisplay} W</span>` : '';

    // Echo Chamber bonus (per-word, shown separately)
    if(wordData.echoChamberW && wordData.echoChamberW > 0){
      wordCountText += ` <span class="mod-badge word" style="background:linear-gradient(135deg,#3b82f6,#8b5cf6)">+${wordData.echoChamberW} W</span>`;
    }

    return {apText,multText,className,wordCountText};
  }

  // Helper to render a slot with HTML (for retrigger display)
  function renderSlotCalc(key) {
    const el = $("#calc-" + key);
    const multEl = document.getElementById('mult-' + key);
    if(!el) return;

    const word = s[key];
    if(!word) {
      el.textContent = "";
      el.className = "slot-calc"; // Reset to base class, removing positive/negative
      if(multEl) multEl.textContent = "";
      return;
    }

    const display = getWordDisplay(word, key);
    const retriggerCount = getRetriggerCount(word);

    // Build HTML string
    let htmlContent = "";

    if(retriggerCount > 0) {
      // Show total trigger count (base + rereads) - matches tally display
      const totalTriggers = retriggerCount + 1;
      htmlContent += `<div style="margin-bottom:1px"><span class="mod-badge reread">√ó${totalTriggers}</span></div>`;
    }

    htmlContent += display.apText;

    el.innerHTML = htmlContent;
    el.className = "slot-calc" + (display.className ? ` ${display.className}` : "");

    // Build mult text with word count badge
    let multDisplay = display.multText;
    if(display.wordCountText) {
      multDisplay = display.wordCountText + (multDisplay ? ' ' + multDisplay : '');
    }
    if(multEl) multEl.innerHTML = multDisplay;
  }

  // Render all slots
  ["item","adj1","adj2","adj3","adj4","noun1"].forEach(renderSlotCalc);

  // Update forge button state
  const forgeButton = document.getElementById("forge-btn");
  if (forgeButton) forgeButton.disabled = !S.sel.item;

  // Update flame background intensity based on enemy health
  updateFlameBaseline();
}

function sortInventory(inv, sortMode){
  const list=[...inv];
  const mode = sortMode || S.sortMode;
  if(mode==="type"){
    // Type + Rarity sort: Weapons first (by rarity, then category), then Elements (by rarity, then element)
    // T3 comes before T2 comes before T1
    list.sort((a,b)=>{
      // Weapons come first
      const aIsWeapon = a.type === 'weapon';
      const bIsWeapon = b.type === 'weapon';
      if(aIsWeapon && !bIsWeapon) return -1;
      if(!aIsWeapon && bIsWeapon) return 1;

      // Both weapons: sort by category (type) first, then by rarity (T3 > T2 > T1)
      // Groups weapons together: all Slash weapons, then Pierce, then Blunt, then Magic
      if(aIsWeapon && bIsWeapon){
        const categoryOrder = {slash:0, pierce:1, blunt:2, magic:3};
        const aCat = categoryOrder[a.category] ?? 99;
        const bCat = categoryOrder[b.category] ?? 99;
        if(aCat !== bCat) return aCat - bCat;
        const rarityDiff = b.rarity - a.rarity;
        if(rarityDiff !== 0) return rarityDiff;
        return a.name.localeCompare(b.name);
      }

      // Non-weapons: Elemental words come before non-elemental (rarity words)
      const aHasElem = a.elem !== undefined;
      const bHasElem = b.elem !== undefined;
      if(aHasElem && !bHasElem) return -1;
      if(!aHasElem && bHasElem) return 1;

      // Both elemental: sort by element type first, then by rarity (T3 > T2 > T1)
      // Custom order: Physical, Poison, Fire, Water, Light, Dark, Lightning, Earth (Earth last to avoid Lightning/Legendary clash)
      if(aHasElem && bHasElem){
        const elemOrder = {0:0, 1:1, 2:2, 3:3, 4:4, 5:5, 7:6, 6:7}; // Lightning(7)->6, Earth(6)->7
        const aOrder = elemOrder[a.elem] ?? a.elem;
        const bOrder = elemOrder[b.elem] ?? b.elem;
        const elemDiff = aOrder - bOrder;
        if(elemDiff !== 0) return elemDiff;
        const rarityDiff = b.rarity - a.rarity;
        if(rarityDiff !== 0) return rarityDiff;
        return a.name.localeCompare(b.name);
      }

      // Both non-elemental (rarity words): use semantic order
      // Magic and Rare are both T2, but Rare should come before Magic
      const raritySemanticOrder = {
        'adj_legendary': 6, 'adj_epic': 5, 'adj_rare': 4,
        'adj_magic': 3, 'adj_uncommon': 2, 'adj_common': 1
      };
      const aOrder = raritySemanticOrder[a.id] || 0;
      const bOrder = raritySemanticOrder[b.id] || 0;
      if(aOrder && bOrder){
        return bOrder - aOrder; // Higher order value first (Rare before Magic)
      }
      return b.rarity - a.rarity || a.name.localeCompare(b.name);
    });
  }else if(mode==="rarity"){
    // For rarity words (Common, Uncommon, Magic, Rare, Epic, Legendary),
    // use a semantic order rather than just tier number
    const rarityOrder = {
      'adj_legendary': 6, 'adj_epic': 5, 'adj_rare': 4,
      'adj_magic': 3, 'adj_uncommon': 2, 'adj_common': 1
    };
    list.sort((a,b)=>{
      // First by tier (T3 > T2 > T1 > T0)
      const tierDiff = b.rarity - a.rarity;
      if(tierDiff !== 0) return tierDiff;
      // For same tier, check if they're rarity adjectives and use semantic order
      const aRarityOrder = rarityOrder[a.id] || 0;
      const bRarityOrder = rarityOrder[b.id] || 0;
      if(aRarityOrder && bRarityOrder){
        return bRarityOrder - aRarityOrder; // Higher order value first (Rare before Magic)
      }
      // Fallback to name
      return a.name.localeCompare(b.name);
    });
  }
  return list;
}

function getVisibleBankWords(inv){
  const used = Object.values(S.sel).filter(Boolean);
  return inv.filter(w => !used.includes(w) && !w.hiddenInBank);
}

function getSortedVisibleBankWords(inv, sortMode, sortAsc=true){
  let sorted = sortInventory(getVisibleBankWords(inv), sortMode);
  if(!sortAsc){
    sorted = sorted.slice().reverse();
  }
  return sorted;
}

// Generate inventory breakdown HTML for tooltip
function generateInvBreakdown(){
  const words = S.inv.filter(w => !w.hiddenInBank);

  // Count by element
  const elemCounts = {};
  for(let i = 0; i < EN.length; i++) elemCounts[i] = 0;

  // Count by tier
  const tierCounts = { T1: 0, T2: 0, T3: 0 };

  // Count by category: Weapons, Elemental (has element), Other (no element, not weapon)
  let weaponCount = 0;
  let elementalCount = 0;
  let otherCount = 0;

  words.forEach(w => {
    // Element counting
    if(w.elem !== undefined){
      elemCounts[w.elem]++;
    }
    // Tier
    const rank = w.rarity || 0;
    if(rank === 0 || rank === 1) tierCounts.T1++;
    else if(rank === 2) tierCounts.T2++;
    else if(rank >= 3) tierCounts.T3++;
    // Category
    if(w.type === 'weapon'){
      weaponCount++;
    } else if(w.elem !== undefined){
      elementalCount++;
    } else {
      otherCount++;
    }
  });

  // Build HTML
  let html = '';

  // Elements section
  html += '<div class="inv-section">';
  html += '<div class="inv-section-title">Elements</div>';
  html += '<div class="inv-row">';
  for(let i = 0; i < EN.length; i++){
    const count = elemCounts[i];
    const missing = count === 0;
    html += `<div class="inv-elem${missing ? ' missing' : ''}" style="border-left:3px solid ${EC[i]}">`;
    html += `<span class="inv-elem-count">${count}</span>`;
    html += `<span>${EN[i]}</span>`;
    html += '</div>';
  }
  html += '</div></div>';

  // Tiers section
  html += '<div class="inv-section">';
  html += '<div class="inv-section-title">Rarity</div>';
  html += '<div class="inv-row">';
  html += `<div class="inv-elem" style="border-left:3px solid #9ca3af"><span class="inv-elem-count">${tierCounts.T1}</span><span class="tier-1">T1</span></div>`;
  html += `<div class="inv-elem" style="border-left:3px solid #60a5fa"><span class="inv-elem-count">${tierCounts.T2}</span><span class="tier-2">T2</span></div>`;
  html += `<div class="inv-elem" style="border-left:3px solid #f4d03f"><span class="inv-elem-count">${tierCounts.T3}</span><span class="tier-3">T3</span></div>`;
  html += '</div></div>';

  // Categories section
  html += '<div class="inv-section">';
  html += '<div class="inv-section-title">Categories</div>';
  html += '<div class="inv-row">';
  html += `<div class="inv-elem"><span class="inv-elem-count">${weaponCount}</span><span>Weapons</span></div>`;
  html += `<div class="inv-elem"><span class="inv-elem-count">${elementalCount}</span><span>Elemental</span></div>`;
  html += `<div class="inv-elem"><span class="inv-elem-count">${otherCount}</span><span>Other</span></div>`;
  html += '</div></div>';

  return html;
}

// Track last render state for fast-path optimization
let _lastBankState = { hasItem: false, hasNoun: false };
let _fastRemoveWordId = null; // Set before render() for fast chip removal

function renderBank(animate = true, fastRemoveWordId = null){
  const bank=$("#bank");
  const hasItem=!!S.sel.item,hasNoun=!!S.sel.noun1;
  const noWeapons=!hasWeapons();

  // Check if we have a pending FLIP animation request (positions already recorded)
  const hasPendingFlip = pendingBankFlip;
  const shouldAnimate = (animate || hasPendingFlip) && !gfxSettings.lowFx;
  if (hasPendingFlip) pendingBankFlip = false; // Clear the flag

  // === FAST PATH: Just remove one chip if disabled states haven't changed ===
  // This avoids rebuilding 20+ chips when only one word was placed
  const stateChanged = (hasItem !== _lastBankState.hasItem) || (hasNoun !== _lastBankState.hasNoun);
  _lastBankState = { hasItem, hasNoun };

  if (fastRemoveWordId && !stateChanged && !noWeapons) {
    // Fast path: find and remove just the one chip
    const chipToRemove = bank.querySelector(`[data-word-id="${fastRemoveWordId}"]`);
    if (chipToRemove) {
      if (shouldAnimate) {
        // Animate removal
        chipToRemove.style.transform = 'scale(0.8)';
        chipToRemove.style.opacity = '0';
        chipToRemove.style.transition = 'transform 0.15s, opacity 0.15s';
        setTimeout(() => chipToRemove.remove(), 150);
      } else {
        chipToRemove.remove();
      }
      return; // Skip full rebuild!
    }
  }

  // === FULL REBUILD PATH ===
  // Record positions BEFORE DOM change for FLIP animation (skip if already recorded via pendingBankFlip)
  if (shouldAnimate && !hasPendingFlip) {
    recordFlipPositions(bank);
  }

  $("#backup-weapon").style.display=noWeapons?"block":"none";

  // Use DocumentFragment for batch DOM insertion (reduces reflow)
  const fragment = document.createDocumentFragment();

  if(noWeapons&&!S.sel.item){
    const c=mkChip(STICK,false,true);
    fragment.appendChild(c);
  }

  let sorted = getSortedVisibleBankWords(S.inv, S.sortMode, S.sortAsc);
  sorted.forEach(w=>{
    const disabled=isWordDisabled(w,hasItem,hasNoun);
    const c=mkChip(w,disabled,false);
    // Hide chips that will animate (exist in flipPositions) to prevent one-frame flash
    // They'll be revealed when the FLIP animation starts
    if (shouldAnimate && flipPositions.has(w.id)) {
      c.style.opacity = '0';
    }
    fragment.appendChild(c);
  });

  // Single DOM update: clear and append all at once
  bank.innerHTML="";
  bank.appendChild(fragment);

  // Play FLIP animation AFTER DOM rebuild - defer to next frame to avoid layout thrashing
  if (shouldAnimate) {
    requestAnimationFrame(() => playFlipAnimation(bank));
  }
}

// Render owned consumables during forging
function renderConsumables(){
  const cont=document.getElementById("consumables-inline");
  if(!cont) return;
  cont.innerHTML="";
  const owned=S.consumables||[];
  // Only show slots if player has consumables or has empty slots to fill
  const totalSlots=CONSUMABLE_LIMIT;
  for(let i=0;i<totalSlots;i++){
    const cid=owned[i];
    const cItem=cid?CONSUMABLES.find(x=>x.id===cid):null;
    const div=document.createElement("div");
    div.className="consumable-pill";
    if(cItem){
      div.classList.add("has-tooltip");
      const tooltip=`<div class="tooltip"><div class="tooltip-title">${cItem.name}</div><div class="tooltip-line">${cItem.desc}</div></div>`;
      div.innerHTML=`${cItem.name}${tooltip}`;
      // Event handler is set on the div element, not in innerHTML, so it won't accumulate
      // when renderConsumables is called multiple times (cont.innerHTML="" clears old elements)
      div.onclick=()=>{
        // Prevent multiple clicks during animation
        if(div.dataset.animating === 'true') return;
        div.dataset.animating = 'true';

        // Call consumable use function
        const result=cItem.use(S);
        // ONLY remove the item if result.success === true
        if(result && typeof result === "object" && result.success === true){
          // Play consume animation on the tool chip
          const animation = div.animate([
            { transform: 'scale(1) rotate(0deg)', opacity: 1 },
            { transform: 'scale(1.1) rotate(-3deg)', opacity: 1, offset: 0.15 },
            { transform: 'scale(1.15) rotate(3deg)', opacity: 0.9, offset: 0.3 },
            { transform: 'scale(0.8) rotate(-2deg)', opacity: 0.6, offset: 0.6 },
            { transform: 'scale(0.3) rotate(0deg)', opacity: 0, offset: 1 }
          ], { duration: 350, easing: 'ease-out', fill: 'forwards' });

          // Clear inline styles after animation completes
          animation.onfinish = () => {
            div.style.transform = '';
            div.style.opacity = '';
            div.dataset.animating = 'false';
          };

          // Burst sparks from the tool
          const divRect = div.getBoundingClientRect();
          burstSparks(divRect.left + divRect.width / 2, divRect.top + divRect.height / 2, 15, ['#fbbf24', '#f59e0b', '#d97706']);

          S.consumables.splice(i,1);
          // Track tool usage for talents
          S.toolsUsed = (S.toolsUsed || 0) + 1;
          S.toolUsedThisBattle = true;
          // Store affected word for chromatic effect after render
          if(result.affectedWord){
            S._chromaticTarget = result.affectedWord;
            S._chromaticType = result.effectType;
          }
          // Store source word for copy effects (chromatic shake on original)
          if(result.sourceWord){
            S._chromaticSource = result.sourceWord;
          }
          // Play success sound based on effect type (ascending arpeggio)
          const effectType = result.effectType;
          if(effectType === 'upgrade'){
            // Ascending notes for upgrade (E4 -> G4 -> B4)
            playBrassTone(330, 0.1, 0.07);
            setTimeout(() => playBrassTone(392, 0.1, 0.07), RHYTHM.QUARTER);
            setTimeout(() => playBrassTone(494, 0.15, 0.08), RHYTHM.HALF);
          } else if(effectType === 'transform'){
            // Swirling notes for transform (B4 -> E4 -> G4)
            playBrassTone(494, 0.1, 0.06);
            setTimeout(() => playBrassTone(330, 0.1, 0.06), RHYTHM.QUARTER);
            setTimeout(() => playBrassTone(392, 0.15, 0.07), RHYTHM.HALF);
          } else if(effectType === 'generate' || effectType === 'copy'){
            // Bright sparkle for generate/copy (G4 -> B4 -> E5)
            playBrassTone(392, 0.1, 0.06);
            setTimeout(() => playBrassTone(494, 0.1, 0.07), RHYTHM.EIGHTH);
            setTimeout(() => playBrassTone(659, 0.15, 0.08), RHYTHM.QUARTER);
          } else {
            // Default success sound (single bright note)
            playBrassTone(494, 0.12, 0.08);
          }
        } else {
          // Failed to use - play invalid sound
          playSfxInvalid();
          // Clear animating flag since no animation was played
          div.dataset.animating = 'false';
        }
        // Always alert result.message
        const msg=result && typeof result === "object" ? result.message : result;
        showQuickToast(msg||`${cItem.name} used`, 1500);
        render();
        // Apply chromatic effect to source word first (for copy - shake on original)
        if(S._chromaticSource){
          applyChromaticToWord(S._chromaticSource, S._chromaticType, true);
          S._chromaticSource = null;
        }
        // Apply chromatic effect to affected word chip after render
        if(S._chromaticTarget){
          applyChromaticToWord(S._chromaticTarget, S._chromaticType);
          S._chromaticTarget = null;
          S._chromaticType = null;
        }
      };
    } else {
      div.classList.add("empty");
      div.textContent="‚Äî";
    }
    cont.appendChild(div);
  }
}

// Render active talents in the talent bar.  Each talent appears as a chip with a
// tooltip describing its effect.  Talents are non-interactive.
function renderTalents(){
  const bar = document.getElementById('talent-bar');
  if(!bar) return;
  bar.innerHTML = '';

  // Update the "Talents" button visibility
  const viewBtn = document.getElementById('view-talents-btn');
  if(viewBtn){
    if(S.talents && S.talents.length > 0){
      viewBtn.style.display = 'block';
      viewBtn.textContent = `Talents (${S.talents.length})`;
    } else {
      viewBtn.style.display = 'none';
    }
  }

  if(!S.talents || S.talents.length === 0){
    return;
  }
  S.talents.forEach(tid => {
    // Look up the talent object by ID.  S.talents only stores IDs, so we must
    // retrieve the full data.  Fallback to an empty object if not found.
    const t = TALENTS.find(x => x.id === tid) || {};
    const chip = document.createElement('div');
    chip.className = 'chip talent-chip';
    // Map talent rarity strings to rarity classes and display labels
    const tierClassMap = {common: 'tier-1', uncommon: 'tier-2', rare: 'tier-3'};
    const rarityLabelMap = {common: 'T1', uncommon: 'T2', rare: 'T3'};
    const rc = tierClassMap[t.rarity] || 'tier-1';
    const rarityLabel = rarityLabelMap[t.rarity] || 'T1';

    // Get talent level for display
    const talentLevel = getTalentLevel(tid);
    const levelBadge = talentLevel > 1
      ? `<span class="talent-level-badge">Lv.${talentLevel}</span>`
      : '';

    // Get talent icon (scaled down for chip display)
    const iconHtml = t.id ? `<div class="talent-chip-icon">${getTalentSVG(t.id)}</div>` : '';

    // Build tooltip using the talent definition if available.  mkTooltip
    // gracefully handles words and talents alike.
    const tooltip = t.id ? mkTooltip(t) : '';
    chip.innerHTML = `
      ${iconHtml}
      <div class="talent-chip-content">
        <div class="chip-name ${rc}">${t.name || tid}</div>
        <div class="chip-info">${levelBadge}${levelBadge ? ' ' : ''}${rarityLabel}</div>
      </div>
      ${tooltip}`;
    // Buffs are not clickable; disable pointer events
    chip.classList.add('disabled');
    bar.appendChild(chip);
  });
}

// Open the talent viewer modal to show all acquired talents with full descriptions
function openTalentViewer(){
  const overlay = document.getElementById('talent-viewer-overlay');
  const content = document.getElementById('talent-viewer-content');
  if(!overlay || !content) return;

  playSfxOpen(); // "Open" sound
  content.innerHTML = '';

  // Show hero passive centered under title (lowkey style)
  if(S.hero && S.hero.passive){
    const passive = S.hero.passive;
    const passiveSection = document.createElement('div');
    passiveSection.className = 'talent-viewer-hero-passive';
    passiveSection.innerHTML = `
      <span style="color:#6b7280">${S.hero.name}:</span>
      <span style="color:#9ca3af">${passive.name}</span>
      <span style="color:#4b5563">‚Äî</span>
      <span style="color:#6b7280;font-style:italic">${passive.desc}</span>
    `;
    passiveSection.style.cssText = 'text-align:center;font-size:11px;margin-bottom:2px;padding:4px 0;grid-column:1/-1';
    content.appendChild(passiveSection);
  }

  // Display talent multiplier (each talent = +0.1x) - lowkey, centered under passive
  if(S.talents && S.talents.length > 0){
    const talentMult = 1.0 + (S.talents.length * 0.1);
    const multPill = document.createElement('div');
    multPill.style.cssText = 'text-align:center;font-size:11px;color:#6b7280;margin-bottom:8px;padding-bottom:6px;border-bottom:1px solid #374151;grid-column:1/-1';
    multPill.innerHTML = `Talent Multiplier: <span class="mod-badge scale" style="font-size:10px;padding:2px 6px">√ó${talentMult.toFixed(1)}</span>`;
    content.appendChild(multPill);
  }

  if(!S.talents || S.talents.length === 0){
    const noTalents = document.createElement('div');
    noTalents.style.cssText = 'text-align:center;color:#9ca3af;padding:20px';
    noTalents.textContent = 'No talents acquired yet.';
    content.appendChild(noTalents);
  } else {
    // Build context for calculating current talent effectiveness
    const allWords = [S.sel.adj1, S.sel.adj2, S.sel.item, S.sel.adj3, S.sel.adj4, S.sel.noun1].filter(Boolean);
    const weapon = S.sel.item;
    const hero = HEROES.find(h => h.id === S.heroId) || {};
    const enemy = S.enemy || { weak: [], resist: [] };
    const talentCtx = {
      state: S,
      allWords,
      weapon,
      hero,
      enemy,
      sel: S.sel
    };

    // Define category order (matches calculation order)
    const categoryOrder = [
      { key: 'generator', label: '+W Generators', color: '#60a5fa' },
      { key: 'multiplier', label: '√óMult (Multipliers)', color: '#f472b6' },
      { key: 'retrigger', label: 'REREAD', color: '#fb923c' },
      { key: 'converter', label: 'Converters', color: '#22d3ee' },
      { key: 'threshold', label: 'Thresholds', color: '#a855f7' },
      { key: 'effect', label: 'Effects', color: '#a78bfa' },
      // Legacy categories for backwards compatibility
      { key: 'flat_ap', label: '+AP (Flat Damage)', color: '#4ade80' },
      { key: 'word_ap_bonus', label: '+AP (Per Word)', color: '#4ade80' },
      { key: 'word_count_bonus', label: '+W (Word Count)', color: '#60a5fa' },
      { key: 'multiplicative_mult', label: '√óMult (Multipliers)', color: '#f472b6' },
      { key: 'special', label: 'Special', color: '#a78bfa' },
      { key: 'economy', label: 'Economy', color: '#fbbf24' }
    ];

    // Group talents by category
    const talentsByCategory = {};
    S.talents.forEach(tid => {
      const t = TALENTS.find(x => x.id === tid);
      if(t){
        const cat = t.category || 'effect';
        if(!talentsByCategory[cat]) talentsByCategory[cat] = [];
        talentsByCategory[cat].push(t);
      }
    });

    // Helper to create a talent card
    function createTalentCard(t){
      const tierClassMap = {common: 'tier-1', uncommon: 'tier-2', rare: 'tier-3'};
      const rarityLabelMap = {common: 'T1', uncommon: 'T2', rare: 'T3'};
      const rc = tierClassMap[t.rarity] || 'tier-1';
      const rarityLabel = rarityLabelMap[t.rarity] || 'T1';

      // Calculate current effectiveness
      let effectivenessHtml = '';
      if(t.apply && typeof t.apply === 'function'){
        try {
          const value = t.apply(talentCtx);
          if(t.category === 'flat_ap' && value !== 0){
            const v = Math.round(value * 10) / 10;
            const cls = v < 0 ? 'neg' : 'add';
            const sign = v < 0 ? '' : '+';
            effectivenessHtml = `<span class="mod-badge ${cls}" style="margin-left:8px">${sign}${v} AP</span>`;
          } else if(t.category === 'word_count_bonus' && value !== 0){
            const v = Math.round(value * 10) / 10;
            const sign = v < 0 ? '' : '+';
            effectivenessHtml = `<span class="mod-badge word" style="margin-left:8px">${sign}${v} W</span>`;
          } else if((t.category === 'multiplier' || t.category === 'multiplicative_mult' || t.category === 'threshold') && value !== 1 && value !== 0){
            const v = Math.round(value * 10) / 10;
            const cls = v < 1 ? 'neg' : 'scale';
            effectivenessHtml = `<span class="mod-badge ${cls}" style="margin-left:8px">√ó${v}</span>`;
          }
        } catch(e) {}
      }

      // For per-round and per-chapter talents, show the accumulated total
      let scalingTotal = '';
      let scaledDesc = ''; // Override description for dynamic talents like Momentum
      const descLower = (t.desc || '').toLowerCase();
      // Determine if talent grants W (word count) or AP based on category
      const isWordCountTalent = t.category === 'word_count_bonus';

      if(descLower.includes('per round')){
        const round = S.roundIndex || 1;
        const match = t.desc.match(/\+(\d+\.?\d*)/);
        if(match){
          const baseValue = parseFloat(match[1]);
          const total = baseValue * round;
          const totalVal = total % 1 === 0 ? total : parseFloat(total.toFixed(1));
          const badge = isWordCountTalent ? fmtMod(totalVal, 'word', ' W') : fmtMod(totalVal, 'ap', ' AP');
          const perWord = descLower.includes('each') || descLower.includes('per word') || descLower.includes('/word') ? '/Word' : '';
          scalingTotal = `<div style="font-size:11px;margin-top:4px">Round ${round} this run: ${badge}${perWord}</div>`;
        }
      } else if(descLower.includes('per chapter')){
        const chapter = Math.floor((S.roundIndex - 1) / 9) + 1;
        const match = t.desc.match(/\+(\d+\.?\d*)/);
        if(match){
          const baseValue = parseFloat(match[1]);
          const total = chapterScale(baseValue, chapter);
          const totalVal = total % 1 === 0 ? total : parseFloat(total.toFixed(1));
          const badge = isWordCountTalent ? fmtMod(totalVal, 'word', ' W') : fmtMod(totalVal, 'ap', ' AP');
          const perWord = descLower.includes('each') || descLower.includes('per word') || descLower.includes('/word') ? '/Word' : '';
          scalingTotal = `<div style="font-size:11px;margin-top:4px">Chapter ${chapter} this run: ${badge}${perWord}</div>`;
        }
      } else if(t.id === 'anthology'){
        // Special case: Anthology shows unique words used
        const uniqueCount = S.uniqueWordsUsed ? S.uniqueWordsUsed.size : 0;
        const totalW = Math.min(uniqueCount * 0.5, 10);
        const totalVal = totalW % 1 === 0 ? totalW : parseFloat(totalW.toFixed(1));
        const badge = fmtMod(totalVal, 'word', ' W');
        scalingTotal = `<div style="font-size:11px;margin-top:4px">${uniqueCount} unique words: ${badge}/Word</div>`;
      } else if(t.id === 'bibliography'){
        // Bibliography: +2 AP per word per boss defeated
        const bossCount = S.bossesDefeated || 0;
        const perWordAP = 2 * bossCount;
        // Handle zero case since fmtMod returns empty string for 0
        const badge = perWordAP === 0
          ? '<span class="mod-badge add">+0 AP</span>'
          : fmtMod(perWordAP, 'ap', ' AP');
        scalingTotal = `<div style="font-size:11px;margin-top:4px">${bossCount} bosses √ó 2 = ${badge}/Word</div>`;
      } else if(t.id === 'liquidation'){
        // Liquidation: +0.2 AP per Word per Word sold this run
        const wordsSold = S.wordsSold || 0;
        const perWordAP = wordsSold * 0.2;
        const totalVal = perWordAP % 1 === 0 ? perWordAP : parseFloat(perWordAP.toFixed(1));
        // Handle zero case since fmtMod returns empty string for 0
        const badge = totalVal === 0
          ? '<span class="mod-badge add">+0 AP</span>'
          : fmtMod(totalVal, 'ap', ' AP');
        scalingTotal = `<div style="font-size:11px;margin-top:4px">${wordsSold} sold √ó 0.2 = ${badge}/Word</div>`;
      } else if(t.category === 'economy' && t.goldBonus){
        // Economy talents: show current gold bonus
        try {
          const goldAmt = t.goldBonus(talentCtx);
          if(goldAmt > 0){
            scalingTotal = `<div style="font-size:11px;margin-top:4px;color:#fbbf24">End of battle: <span style="font-weight:bold">+${goldAmt}g</span></div>`;
          } else {
            scalingTotal = `<div style="font-size:11px;margin-top:4px;color:#6b7280">No bonus yet (use more words!)</div>`;
          }
        } catch(e) {}
      } else if(t.id === 'golden_tongue'){
        // Golden Tongue: Each 20 Gold held ‚Üí +1 W - scales with level
        const gold = S.gold || 0;
        const basePerStack = scaleTalentBonus('golden_tongue', 1);
        const stacks = Math.floor(gold / 20);
        const bonus = stacks * basePerStack;
        const badge = fmtMod(bonus, 'word', ' W');
        const levelText = getTalentLevel('golden_tongue') > 1 ? ` (Lv.${getTalentLevel('golden_tongue')})` : '';
        scalingTotal = `<div style="font-size:11px;margin-top:4px">${gold}g √∑ 20 √ó ${basePerStack} = ${badge}${levelText}</div>`;
      } else if(t.id === 'tithe'){
        // Tithe: Each 20 Gold spent this run ‚Üí +2 W - scales with level
        const spent = S.goldSpent || 0;
        const basePerStack = scaleTalentBonus('tithe', 2);
        const stacks = Math.floor(spent / 20);
        const bonus = stacks * basePerStack;
        const badge = fmtMod(bonus, 'word', ' W');
        const levelText = getTalentLevel('tithe') > 1 ? ` (Lv.${getTalentLevel('tithe')})` : '';
        scalingTotal = `<div style="font-size:11px;margin-top:4px">${spent}g spent √∑ 20 √ó ${basePerStack} = ${badge}${levelText}</div>`;
      } else if(t.id === 'momentum'){
        // Momentum: +1 W per Word per round played (max 10) - scales with level
        const roundsPlayed = Math.min((S.roundIndex || 1) - 1, 10);
        const basePerRound = scaleTalentBonus('momentum', 1);
        const bonusPerWord = roundsPlayed * basePerRound;
        const levelText = getTalentLevel('momentum') > 1 ? ` (Lv.${getTalentLevel('momentum')})` : '';
        // Override description to show current total W per word
        scaledDesc = `Each Word: <span class="mod-badge word">+${bonusPerWord} W</span>`;
        scalingTotal = `<div style="font-size:11px;margin-top:4px">${basePerRound} W √ó ${roundsPlayed} rounds${levelText}</div>`;
      } else if(t.id === 'word_historian'){
        // Word Historian: +0.25 W per Word used this run - scales with level
        const wordsUsed = S.wordsUsedThisRun || 0;
        const basePerWord = scaleTalentBonus('word_historian', 0.25);
        const bonus = Math.floor(wordsUsed * basePerWord);
        const badge = bonus > 0 ? fmtMod(bonus, 'word', ' W') : '<span class="mod-badge word">+0 W</span>';
        const levelText = getTalentLevel('word_historian') > 1 ? ` (Lv.${getTalentLevel('word_historian')})` : '';
        scalingTotal = `<div style="font-size:11px;margin-top:4px">${wordsUsed} words used: ${badge}${levelText}</div>`;
      } else if(t.id === 'reverberation'){
        // Reverberation: +2 W per REREAD triggered this run - scales with level
        const rereadsTriggered = S.rereadTriggersThisRun || 0;
        const basePerReread = scaleTalentBonus('reverberation', 2);
        const bonus = rereadsTriggered * basePerReread;
        const badge = bonus > 0 ? fmtMod(bonus, 'word', ' W') : '<span class="mod-badge word">+0 W</span>';
        const levelText = getTalentLevel('reverberation') > 1 ? ` (Lv.${getTalentLevel('reverberation')})` : '';
        scalingTotal = `<div style="font-size:11px;margin-top:4px">${rereadsTriggered} rereads: ${badge}${levelText}</div>`;
      } else if(t.id === 'verbose_surplus'){
        // Verbose Surplus: +10 W per word √ó word count (quadratic)
        const basePerWord = scaleTalentBonus('verbose_surplus', 10);
        const badge = fmtMod(basePerWord, 'word', ' W');
        const levelText = getTalentLevel('verbose_surplus') > 1 ? ` (Lv.${getTalentLevel('verbose_surplus')})` : '';
        scalingTotal = `<div style="font-size:11px;margin-top:4px">Bonus: ${badge} √ó Words √ó Words${levelText}</div>`;
      } else if(t.id === 'linguistic_density'){
        // Linguistic Density: +5 W per word per word (4+ words)
        const basePerWord = scaleTalentBonus('linguistic_density', 5);
        const badge = fmtMod(basePerWord, 'word', ' W');
        const levelText = getTalentLevel('linguistic_density') > 1 ? ` (Lv.${getTalentLevel('linguistic_density')})` : '';
        scalingTotal = `<div style="font-size:11px;margin-top:4px">4+ Words: ${badge} √ó Word count¬≤${levelText}</div>`;
      } else if(t.id === 'elemental_mastery'){
        // Elemental Mastery: Track accumulated elemental W
        const elementalW = S.elementalWBonus || 0;
        const badge = fmtMod(elementalW, 'word', ' W');
        scalingTotal = `<div style="font-size:11px;margin-top:4px">Accumulated: ${badge}</div>`;
      } else if(t.id === 'prismatic_resonance'){
        // Prismatic Resonance: √ó1.2 per 5 Word Count
        const cumulativeW = S.cumulativeWordCount || 0;
        const tiers = Math.floor(cumulativeW / 5);
        const scaledMult = scaleTalentMult('prismatic_resonance', 1.2);
        const mult = tiers > 0 ? Math.pow(scaledMult, tiers) : 1;
        const badge = fmtMod(mult, 'scale');
        const levelText = getTalentLevel('prismatic_resonance') > 1 ? ` (Lv.${getTalentLevel('prismatic_resonance')})` : '';
        scalingTotal = `<div style="font-size:11px;margin-top:4px">${cumulativeW} Word Count √∑ 5 = ${tiers} tiers = ${badge}${levelText}</div>`;
      } else if(t.id === 'weakness_exploit_amp'){
        // Weakness Exploit Amp: +4 W per weakness hit
        const elementalW = S.elementalWBonus || 0;
        const badge = fmtMod(elementalW, 'word', ' W');
        scalingTotal = `<div style="font-size:11px;margin-top:4px">Accumulated: ${badge}</div>`;
      } else if(t.id === 'lexicon_growth'){
        // Lexicon Growth: +1 W per Word per Boss defeated - scales with level
        const bosses = S.bossesDefeated || 0;
        const basePerBoss = scaleTalentBonus('lexicon_growth', 1);
        const bonus = bosses * basePerBoss;
        const badge = bonus === 0
          ? '<span class="mod-badge word">+0 W</span>'
          : fmtMod(bonus, 'word', ' W');
        const levelText = getTalentLevel('lexicon_growth') > 1 ? ` (Lv.${getTalentLevel('lexicon_growth')})` : '';
        scalingTotal = `<div style="font-size:11px;margin-top:4px">${bosses} bosses: ${badge}/Word${levelText}</div>`;
      } else if(t.id === 'compound_interest'){
        // Compound Interest: Each 50 Gold held ‚Üí √ó1.15
        const gold = S.gold || 0;
        const stacks = Math.floor(gold / 50);
        const mult = Math.pow(1.15, stacks);
        const multRound = Math.round(mult * 100) / 100;
        scalingTotal = `<div style="font-size:11px;margin-top:4px">${gold}g √∑ 50 = ${stacks} stacks: <span class="mod-badge scale">√ó${multRound}</span></div>`;
      } else if(t.id === 'overflow'){
        // Overflow: Per 10 W above 50 ‚Üí √ó1.5
        const slots = [S.sel?.item, S.sel?.adj1, S.sel?.adj2, S.sel?.adj3, S.sel?.adj4, S.sel?.noun1].filter(Boolean);
        const baseW = slots.reduce((sum, w) => sum + (w.word?.length || w.name?.length || 0), 0);
        if(baseW > 50){
          const excessW = baseW - 50;
          const stacks = Math.floor(excessW / 10);
          const mult = Math.pow(1.5, stacks);
          const multRound = Math.round(mult * 100) / 100;
          scalingTotal = `<div style="font-size:11px;margin-top:4px;color:#4ade80">~${baseW} W: ${stacks} stacks = <span class="mod-badge scale">√ó${multRound}</span></div>`;
        } else {
          scalingTotal = `<div style="font-size:11px;margin-top:4px;color:#6b7280">~${baseW} W (need 50+ to activate)</div>`;
        }
      } else if(t.id === 'word_hoard'){
        // Word Hoard: Each Word in inventory ‚Üí +0.2 W - scales with level
        const invCount = (S.inv || []).filter(w => !w.hiddenInBank).length;
        const basePerWord = scaleTalentBonus('word_hoard', 0.2);
        const bonus = Math.floor(invCount * basePerWord * 10) / 10;
        const badge = fmtMod(bonus, 'word', ' W');
        const levelText = getTalentLevel('word_hoard') > 1 ? ` (Lv.${getTalentLevel('word_hoard')})` : '';
        scalingTotal = `<div style="font-size:11px;margin-top:4px">${invCount} Words √ó ${basePerWord} = ${badge}${levelText}</div>`;
      } else if(t.id === 'slow_burn'){
        // Slow Burn: +2 W per Round number - scales with level
        const round = S.roundIndex || 1;
        const basePerRound = scaleTalentBonus('slow_burn', 2);
        const bonus = round * basePerRound;
        const badge = fmtMod(bonus, 'word', ' W');
        const levelText = getTalentLevel('slow_burn') > 1 ? ` (Lv.${getTalentLevel('slow_burn')})` : '';
        scalingTotal = `<div style="font-size:11px;margin-top:4px">Round ${round} √ó ${basePerRound} = ${badge}${levelText}</div>`;
      } else if(t.id === 'world_sky_focus' || t.id === 'body_soul_focus'){
        // Focus talents: +5 W per matching word, scales with talent level
        const level = getTalentLevel(t.id);
        const baseW = 5;
        const scaledW = baseW * level;
        const badge = fmtMod(scaledW, 'word', ' W');
        const levelText = level > 1 ? ` (Lv.${level})` : '';
        scalingTotal = `<div style="font-size:11px;margin-top:4px">${badge} each${levelText}</div>`;
      } else if(t.id === 'proficiency_focus'){
        // Proficiency Focus: +8 W for proficient weapon, scales with chapter
        const chapter = Math.floor((S.roundIndex - 1) / 9) + 1;
        const baseW = 8;
        const scaledW = typeof chapterScaleW === 'function' ? chapterScaleW(baseW, chapter) : baseW * chapter;
        const badge = fmtMod(scaledW, 'word', ' W');
        const weaponType = S.hero && S.hero.good ? S.hero.good : '?';
        scalingTotal = `<div style="font-size:11px;margin-top:4px">Chapter ${chapter} (${weaponType}): ${badge}</div>`;
      } else if(t.id === 'weakness_exploit'){
        // Weakness Exploit: +6 W per word hitting weakness, scales with chapter
        const chapter = Math.floor((S.roundIndex - 1) / 9) + 1;
        const baseW = 6;
        const scaledW = typeof chapterScaleW === 'function' ? chapterScaleW(baseW, chapter) : baseW * chapter;
        const badge = fmtMod(scaledW, 'word', ' W');
        scalingTotal = `<div style="font-size:11px;margin-top:4px">Chapter ${chapter}: ${badge}/Word</div>`;
      } else if(t.id === 'isocolon'){
        // Isocolon: All words same tier ‚Üí +10 W, scales with chapter
        const chapter = Math.floor((S.roundIndex - 1) / 9) + 1;
        const baseW = 10;
        const scaledW = typeof chapterScaleW === 'function' ? chapterScaleW(baseW, chapter) : baseW * chapter;
        const badge = fmtMod(scaledW, 'word', ' W');
        scalingTotal = `<div style="font-size:11px;margin-top:4px">Chapter ${chapter}: ${badge}</div>`;
      } else if(t.id === 'hendiadys'){
        // Hendiadys: 2+ Adjective slots filled ‚Üí +6 W, scales with chapter
        const chapter = Math.floor((S.roundIndex - 1) / 9) + 1;
        const baseW = 6;
        const scaledW = typeof chapterScaleW === 'function' ? chapterScaleW(baseW, chapter) : baseW * chapter;
        const badge = fmtMod(scaledW, 'word', ' W');
        scalingTotal = `<div style="font-size:11px;margin-top:4px">Chapter ${chapter}: ${badge}</div>`;
      } else if(t.id === 'stony_brook'){
        // Stony Brook: Water + Earth ‚Üí +12 W (flat)
        const badge = fmtMod(12, 'word', ' W');
        scalingTotal = `<div style="font-size:11px;margin-top:4px">Bonus: ${badge}</div>`;
      } else if(t.id === 'alliteration'){
        // Alliteration: 2+ consecutive same-letter words ‚Üí +8 W each (flat)
        const badge = fmtMod(8, 'word', ' W');
        scalingTotal = `<div style="font-size:11px;margin-top:4px">Bonus: ${badge} each</div>`;
      } else if(t.category === 'threshold' && t.resource === 'W'){
        // W-based threshold talents: show current W progress
        const threshold = t.threshold || 0;
        // Calculate current W (simplified - just show base from slots)
        const slots = [S.sel?.item, S.sel?.adj1, S.sel?.adj2, S.sel?.adj3, S.sel?.adj4, S.sel?.noun1].filter(Boolean);
        const baseW = slots.reduce((sum, w) => sum + (w.word?.length || w.name?.length || 0), 0);
        const color = baseW >= threshold ? '#4ade80' : '#9ca3af';
        scalingTotal = `<div style="font-size:11px;margin-top:4px;color:${color}">Current W: ~${baseW} / ${threshold}</div>`;
      } else if(t.id === 'fortuna'){
        // Fortuna: 100+ Gold threshold
        const gold = S.gold || 0;
        const threshold = 100;
        const color = gold >= threshold ? '#4ade80' : '#9ca3af';
        scalingTotal = `<div style="font-size:11px;margin-top:4px;color:${color}">Current Gold: ${gold} / ${threshold}</div>`;
      }

      const card = document.createElement('div');
      card.style.cssText = `
        padding: 12px;
        border-radius: 8px;
        background: linear-gradient(135deg, rgba(30,40,54,0.9), rgba(21,25,33,0.95));
        border: 1px solid ${t.rarity === 'rare' ? 'rgba(244,208,63,0.3)' : t.rarity === 'uncommon' ? 'rgba(77,153,255,0.3)' : 'rgba(156,163,175,0.2)'};
        display: flex;
        gap: 12px;
        align-items: flex-start;
      `;
      const talentLevel = getTalentLevel(t.id);
      const levelColor = talentLevel > 1 ? '#4ade80' : '#9ca3af';
      card.innerHTML = `
        <div style="flex-shrink:0;width:44px;height:57px;display:flex;align-items:center;justify-content:center">${getTalentSVG(t.id)}</div>
        <div style="flex:1;min-width:0">
          <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px;flex-wrap:wrap">
            <span class="${rc}" style="font-size:13px;font-weight:600">${t.name}</span>
            <span style="font-size:10px;color:${levelColor};font-weight:600">Lv.${talentLevel}</span>
            <span style="font-size:9px;padding:1px 5px;border-radius:3px;background:${t.rarity === 'rare' ? '#f4d03f' : t.rarity === 'uncommon' ? '#4d99ff' : '#9ca3af'};color:#000;font-weight:600">${rarityLabel}</span>
            ${effectivenessHtml}
          </div>
          <div style="font-size:11px;color:#d1d5db;line-height:1.4">${scaledDesc || formatTalentDesc(t, t.id)}</div>
          ${scalingTotal ? `<div style="font-size:10px;margin-top:6px;color:#9ca3af">${scalingTotal.replace(/<div[^>]*>|<\/div>/g, '')}</div>` : ''}
        </div>
      `;
      return card;
    }

    // Render talents grouped by category in calculation order
    categoryOrder.forEach(catInfo => {
      const talents = talentsByCategory[catInfo.key];
      if(!talents || talents.length === 0) return;

      // Create category section
      const section = document.createElement('div');
      section.style.cssText = 'margin-bottom:16px';

      // Category header
      const header = document.createElement('div');
      header.style.cssText = `font-size:12px;font-weight:bold;color:${catInfo.color};margin-bottom:8px;padding-bottom:4px;border-bottom:1px solid ${catInfo.color}33;letter-spacing:0.1em;text-transform:uppercase`;
      header.textContent = catInfo.label;
      section.appendChild(header);

      // Talent cards in a grid
      const grid = document.createElement('div');
      grid.style.cssText = 'display:grid;grid-template-columns:repeat(2,1fr);gap:8px';
      talents.forEach(t => grid.appendChild(createTalentCard(t)));
      section.appendChild(grid);

      content.appendChild(section);
    });
  }

  overlay.classList.add('show');
}

function mkChip(w,disabled,isStickChip){
  const c=document.createElement("div");
  c.className="chip"+(disabled?" disabled":"")+(isStickChip?" rusty":"");
  if(w.type === 'weapon') c.classList.add('weapon-tile');
  // Assign dataset index only for words in the main inventory; talents and stick chips are excluded
  if(!isStickChip && w.type !== 'talent') c.dataset.idx=S.inv.indexOf(w);
  // Assign word ID for FLIP animations
  if(w.id) c.dataset.wordId = w.id;
  // Store element for beat bounce animation
  if(w.elem !== undefined) c.dataset.elem = w.elem;
  
  const rc=TC[w.rarity];
  // Determine the label that appears underneath each chip (tier is now in badge)
  // For weapons, show category. For talents, show "Talent". Others show nothing.
  let chipInfo = '';
  if(w.isStick){
    chipInfo = 'Backup';
  } else if(w.type === 'weapon'){
    const cat = w.category || '';
    chipInfo = cat.charAt(0).toUpperCase() + cat.slice(1);
  } else if(w.type === 'talent'){
    chipInfo = 'Talent';
  }
  
  // Element display (or multiplier for non-elemental words)
  let elemHtml="";
  if(w.elem!==undefined){
    elemHtml=`<div class="chip-elem" style="color:${EC[w.elem]}">${EN[w.elem]}</div>`;
  } else if(w.mult && w.mult !== 1){
    // Non-elemental words (Common->Legendary adjectives) show multiplier as a badge with mono font
    elemHtml=`<span class="mod-badge scale" style="margin-top:2px;font-size:9px">√ó${w.mult}</span>`;
  }

  // Generate color tab and tier classes based on word type
  let tabHtml = "";
  let chipExtraClasses = "";
  const elemTabClasses = ['elem-phys','elem-poison','elem-fire','elem-water','elem-light','elem-dark','elem-earth','elem-lightning'];
  const elemWashClasses = ['elem-wash-phys','elem-wash-poison','elem-wash-fire','elem-wash-water','elem-wash-light','elem-wash-dark','elem-wash-earth','elem-wash-lightning'];

  if(w.type === 'elemental' && w.elem !== undefined){
    // Elemental words get solid element color tab
    tabHtml = `<div class="chip-tab ${elemTabClasses[w.elem] || ''}"></div>`;
    // Add tier wash effect (T2 = light, T3 = strong + shimmer)
    if(w.rarity === T.T2){
      chipExtraClasses = ` tier-wash-2 ${elemWashClasses[w.elem] || ''}`;
    } else if(w.rarity === T.T3){
      chipExtraClasses = ` tier-wash-3 ${elemWashClasses[w.elem] || ''}`;
    }
  } else if(w.type === 'rarity'){
    // Rarity words get metallic sheen background (no tab)
    const rarityTier = w.rarity === T.T3 ? 'rarity-t3' : w.rarity === T.T2 ? 'rarity-t2' : 'rarity-t1';
    chipExtraClasses = ` rarity-word ${rarityTier}`;
  }
  // Weapons get no tab

  // Apply extra classes
  if(chipExtraClasses) c.className += chipExtraClasses;

  // Use the noun form for the chip name for all non‚Äëweapon words to present the most basic form
  // in the inventory.  Weapons retain their own name.
  let displayName = w.name;
  if(w.type !== 'weapon' && !w.isStick){
    // Display the noun form (e.g. "Shade" instead of "Shadowy"), alt adjectives not needed here
    displayName = getDisplayForm(w, 'noun1', null) || w.name;
  }

  // Word name color: neutral white for elemental (tab shows element), tier color for others
  const nameColorClass = (w.type === 'elemental') ? '' : rc;

  // Tier badge in top-right corner (card style)
  const tierBadge = w.isStick ? '' : `<div class="chip-tier tier-${w.rarity}">${TN[w.rarity] || 'T1'}</div>`;

  c.innerHTML=`
    ${tabHtml}
    ${tierBadge}
    <div class="chip-name ${nameColorClass}">${displayName}</div>
    <div class="chip-info">${chipInfo}</div>
    ${elemHtml}
  `;

  // Show the contextual tooltip for this specific word (AP, multipliers, hero/enemy effectiveness)
  // instead of the global damage breakdown so hovering a word displays its own details.
  attachDamageTooltip(c);
  c.__tooltipContent = () => mkTooltip(w, { bare: true });
  const chipTip = c.querySelector('.tooltip.modal-tooltip, .tooltip');
  if(chipTip) chipTip.innerHTML = c.__tooltipContent();
  
  if(!disabled){
    c.onclick = () => {
      // Toggle selection on left click - play highlight sound
      playSample('highlight word.ogg', 0.5);
      // For stick chip, use STICK object for selection
      const wordToSelect = isStickChip ? STICK : w;
      if(S.pendingWord === wordToSelect || (isStickChip && S.pendingWord?.isStick)){
        // Deselect if already selected
        S.pendingWord = null;
      } else {
        // Select this word
        S.pendingWord = wordToSelect;
      }
      // Re-render to update highlight and other UI
      render();
    };

    // Disable right-click context menu on word chips
    c.oncontextmenu = (e) => e.preventDefault();
    c.onmouseenter = sfxHover;
  }

  // Highlight this chip if it is currently selected
  if(S.pendingWord === w || (isStickChip && S.pendingWord?.isStick)){
    c.classList.add('selected');
  }
  return c;
}

function mkTooltip(w, opts={}){
  // Special handling for talents: display only their description and rarity.  Talents do
  // not have elemental interactions, multipliers or morphological forms.  The rarity
  // colour is still used for the title bar.
  // Check if this is actually a talent (has a talent category like 'flat_ap', 'retrigger', etc.)
  const isTalent = w.type === 'talent' || (w.category && ['flat_ap', 'additive_mult', 'multiplicative_mult', 'multiplier', 'retrigger', 'converter', 'threshold', 'generator', 'effect'].includes(w.category));
  if(isTalent){
    // Map talent rarity strings to rarity classes
    const tierClassMap = {common: 'tier-1', uncommon: 'tier-2', rare: 'tier-3'};
    const rarityLabelMap = {common: 'T1', uncommon: 'T2', rare: 'T3'};
    const rc = tierClassMap[w.rarity] || 'tier-1';
    const rarityLabel = rarityLabelMap[w.rarity] || 'T1';

    // Get talent level
    const talentLevel = w.id ? getTalentLevel(w.id) : 1;
    const levelText = talentLevel > 1 ? `<span style="color:#4ade80;font-size:10px;margin-left:6px">Lv.${talentLevel}</span>` : '';

    // Build effectiveness badge based on category
    let effectivenessHtml = '';
    if(w.apply && typeof w.apply === 'function'){
      try {
        const allWords = [S.sel?.adj1, S.sel?.adj2, S.sel?.item, S.sel?.adj3, S.sel?.adj4, S.sel?.noun1].filter(Boolean);
        const talentCtx = { state: S, allWords, weapon: S.sel?.item, hero: S.hero, enemy: S.enemy || { weak: [], resist: [] }, sel: S.sel };
        const value = w.apply(talentCtx);
        if((w.category === 'generator' || w.category === 'word_count_bonus') && value > 0){
          const v = Math.round(value * 10) / 10;
          effectivenessHtml = `<div class="tooltip-line" style="margin-top:4px">Current: <span class="mod-badge word">+${v} W</span></div>`;
        } else if((w.category === 'multiplier' || w.category === 'multiplicative_mult' || w.category === 'threshold') && value !== 1 && value > 0){
          const v = Math.round(value * 100) / 100;
          effectivenessHtml = `<div class="tooltip-line" style="margin-top:4px">Current: <span class="mod-badge scale">√ó${v}</span></div>`;
        }
      } catch(e) {}
    }

    let lines = [];
    if(w.desc) lines.push(`<div class="tooltip-line">${formatTalentDesc(w, w.id)}</div>`);
    const inner = `
      <div class="tooltip-title ${rc}">${w.name}${levelText} <span style="font-size:9px;padding:1px 5px;border-radius:3px;background:${w.rarity === 'rare' ? '#f4d03f' : w.rarity === 'uncommon' ? '#60a5fa' : '#9ca3af'};color:#000;font-weight:600;margin-left:6px">${rarityLabel}</span></div>
      ${lines.join('')}
      ${effectivenessHtml}
    `;
    return opts?.bare ? inner : `<div class="tooltip">${inner}</div>`;
  }
  const rc=TC[w.rarity];
  const rarityRank = w.rarity ?? w.rarity ?? 0;
  const tierLabel = w.isStick?"Backup":(TN[rarityRank] || TN[w.rarity] || "T1");
  const isModifier = w.type === 'elemental' || w.type === 'rarity';

  // Check for Signature Style weapon early (needed for element checks below)
  const hasSignatureStyle = S.talents && S.talents.includes('signature_style');
  const isSignatureStyleWeapon = hasSignatureStyle &&
    w.type === 'weapon' &&
    !w.isStick &&
    S.hero &&
    w.category === S.hero.good &&
    w.elem === undefined;

  let lines=[];
  // Skip description if it's just restating the AP (e.g. "+2 AP Fire") - this is shown in Base AP line
  const isRedundantAPDesc = w.desc && /^\+\d+ AP \w+$/.test(w.desc);
  if(w.desc && !isRedundantAPDesc) lines.push(`<div class="tooltip-line">${w.desc}</div>`);

  if(w.type==="weapon"&&!w.isStick){
    // Show proficiency information (now uses category), respecting Weapon Master which overrides category checks
    const hasWM = !!(S.tempEffects && S.tempEffects.weaponMaster);
    const good=S.hero?.good===w.category,bad=S.hero?.bad===w.category;
    let profLabel="No proficiency";
    let profMult=1.0;
    let profBadgeCls="neutral";
    if(hasWM){
      profLabel="Weapon Master active";
      profMult=S.tempEffects.weaponMaster || 3;
      profBadgeCls="word";
    } else if(good){
      profLabel="Good proficiency";
      profMult=2.0;
      profBadgeCls="word";
    } else if(bad){
      profLabel="Poor proficiency";
      profMult=0.5;
      profBadgeCls="penalty";
    }
    lines.push(`<div class="tooltip-line">${profLabel}: <span class="mod-badge ${profBadgeCls}">√ó${profMult} W</span></div>`);
  }

  // Show multiplier line for words with mult
  if(w.mult){
    lines.push(`<div class="tooltip-line">Multiplier: ${fmtMod(w.mult,'scale')}</div>`);
  }
  // Show AP for all word types
  if(w.type === "weapon" || w.type === "elemental" || w.type === "rarity"){
    // Build a context object similar to calc() to use getWordAP()
    // This ensures tooltips show the same AP values as damage calculations
    const {hero: h, enemy: e} = getCombatants();
    const allWords = [S.sel?.adj1, S.sel?.adj2, S.sel?.item, S.sel?.adj3, S.sel?.adj4, S.sel?.noun1].filter(Boolean);
    const ctx = {
      hero: h,
      enemy: e,
      allWords: allWords,
      weapon: S.sel?.item,
      state: S,
      talentCount: S.talents?.length || 0
    };

    // Use the centralized getWordAP() function to get total AP including all talent bonuses
    // We don't pass a slotKey here since we're just showing the word's potential AP
    const totalWordAP = getWordAP(w, ctx, null);

    // Calculate base AP without talents for breakdown
    const baseAP = getBaseAP(w);
    const talentBonus = totalWordAP - baseAP;

    // Get skill tree bonuses for display
    const skillBonuses = S.heroSkillBonuses || {};
    let skillBonusText = '';
    if (w.type === 'weapon') {
      const weaponBonus = skillBonuses.weaponAP || 0;
      if (weaponBonus > 0) {
        skillBonusText = ` <span class="dim">(+${weaponBonus} Skills)</span>`;
      }
    } else if (w.type === 'rarity') {
      const adjBonus = skillBonuses.adjAP || 0;
      if (adjBonus > 0) {
        skillBonusText = ` <span class="dim">(+${adjBonus} Skills in Adj slot)</span>`;
      }
    } else if (w.type === 'elemental') {
      // Gems can go in noun slots
      const nounBonus = skillBonuses.nounAP || 0;
      if (nounBonus > 0) {
        skillBonusText = ` <span class="dim">(+${nounBonus} Skills in Noun slot)</span>`;
      }
    }

    // Show total AP with breakdown if there are bonuses
    let breakdownParts = [];
    if (talentBonus > 0) breakdownParts.push(`+${Math.floor(talentBonus)} Talents`);

    if (breakdownParts.length > 0 || skillBonusText) {
      const breakdownText = breakdownParts.length > 0 ? ` <span class="dim">(${breakdownParts.join(', ')})</span>` : '';
      lines.push(`<div class="tooltip-line">Base AP: ${fmtMod(Math.floor(totalWordAP),'ap')}${breakdownText}${skillBonusText}</div>`);
    } else {
      lines.push(`<div class="tooltip-line">Base AP: ${fmtMod(totalWordAP,'ap')}</div>`);
    }
  }

  // Check effectiveness vs current enemy (if both hero and enemy exist)
  // Moved right below Base AP for easier readability
  // Also handle Signature Style weapons which gain hero's elements
  const elementsToCheck = [];
  if(w.elem !== undefined){
    elementsToCheck.push(w.elem);
  } else if(isSignatureStyleWeapon && S.hero.str){
    // Signature Style weapons use both hero strength elements
    elementsToCheck.push(...S.hero.str);
  }

  if(elementsToCheck.length > 0 && S.hero && S.enemy){
    // Get a copy of the enemy and apply CALC_INIT modifiers (e.g., Druid passive)
    // to ensure tooltips show the same modified state as calc()
    const {hero: h, enemy: e} = getCombatants();
    applyModifiers('CALC_INIT', {hero: h, enemy: e, sel: S.sel, state: S});

    // Respect Polymorph: if active, treat enemy as having no resistances
    const effectiveRes = (S.tempEffects && S.tempEffects.polymorph) ? [] : e.res;
    const hasIrony = S.talents && S.talents.includes('irony');

    // Use the same matrix as in calc()
    const elemMatrix = {
      strong:  { weak: 3.0,   neutral: 1.5, strong: 1.0 },
      neutral: { weak: 2.0,   neutral: 1.0, strong: 0.5 },
      weak:    { weak: 1.5,   neutral: 0.5, strong: 0.0 }
    };

    const getMatrixBadgeClass = (mult) => {
      if(mult >= 3) return 'strong';
      if(mult >= 2) return 'add';
      if(mult === 1.5) return 'stalemate';
      if(mult === 1) return 'neutral';
      if(mult === 0.5) return 'penalty';
      return 'neg';
    };

    // For Signature Style, show combined effectiveness for both elements
    if(isSignatureStyleWeapon && elementsToCheck.length > 1){
      let totalMult = 0;
      const elemDetails = [];
      elementsToCheck.forEach(elem => {
        const heroStrong = S.hero.str.includes(elem);
        const heroWeak = S.hero.weak.includes(elem);
        const enemyWeak = e.weak.includes(elem);
        const enemyResist = effectiveRes.includes(elem);
        const isFirstResist = effectiveRes.length > 0 && effectiveRes[0] === elem;
        const ironyApplies = hasIrony && enemyResist && isFirstResist;

        const heroAffinity = heroStrong ? 'strong' : heroWeak ? 'weak' : 'neutral';
        const enemyAffinity = enemyWeak ? 'weak' : (ironyApplies) ? 'weak' : enemyResist ? 'strong' : 'neutral';
        const mult = elemMatrix[heroAffinity][enemyAffinity];
        totalMult += mult;
        elemDetails.push({ elem, mult, ironyApplies: ironyApplies && !enemyWeak });
      });

      // Show combined effectiveness
      if(totalMult > 0){
        const badgeCls = getMatrixBadgeClass(totalMult / elementsToCheck.length * 2); // Scale for display
        const detailStr = elemDetails.map(d => `${EN[d.elem]}: √ó${d.mult}`).join(', ');
        lines.push(`<div class="tooltip-line">Combined: <span class="mod-badge ${badgeCls}">√ó${totalMult} AP</span> <span class="dim">(${detailStr})</span></div>`);
      }
    } else {
      // Single element handling (original logic)
      const elem = elementsToCheck[0];
      const heroStrong = S.hero.str.includes(elem);
      const heroWeak = S.hero.weak.includes(elem);
      const enemyWeak = e.weak.includes(elem);
      const enemyResist = effectiveRes.includes(elem);
      const isFirstResist = effectiveRes.length > 0 && effectiveRes[0] === elem;
      const ironyApplies = hasIrony && enemyResist && isFirstResist;

      const heroAffinity = heroStrong ? 'strong' : heroWeak ? 'weak' : 'neutral';
      const enemyAffinity = enemyWeak ? 'weak' : (ironyApplies) ? 'weak' : enemyResist ? 'strong' : 'neutral';
      const multiplier = elemMatrix[heroAffinity][enemyAffinity];
      const ironyFlipped = ironyApplies && !enemyWeak;

      if(multiplier >= 2.0){
        const badgeCls = getMatrixBadgeClass(multiplier);
        const ironyNote = ironyFlipped ? ' <span class="irony-badge">Irony</span>' : '';
        lines.push(`<div class="tooltip-line">Effective vs Enemy <span class="mod-badge ${badgeCls}">√ó${multiplier} AP</span>${ironyNote}</div>`);
      } else if(multiplier <= 0.5){
        const badgeCls = multiplier === 0 ? 'neg' : 'penalty';
        const resistBadge = `<span class="mod-badge ${badgeCls}">√ó${multiplier} AP</span>`;
        lines.push(`<div class="tooltip-line">Resisted by Enemy ${resistBadge}</div>`);
      } else if(multiplier > 1.0){
        const badgeCls = getMatrixBadgeClass(multiplier);
        const ironyNote = ironyFlipped ? ' <span class="irony-badge">Irony</span>' : '';
        lines.push(`<div class="tooltip-line">Boosted <span class="mod-badge ${badgeCls}">√ó${multiplier} AP</span>${ironyNote}</div>`);
      }
    }
  }

  // Show Elemental Mastery bonus if player has the talent and word has an element
  if(w.elem !== undefined && S.talents && S.talents.includes('elemental_mastery')){
    let wBonus = 2; // Base +2 W from Elemental Mastery
    // Check for Weakness Exploit Amp bonus (requires enemy data)
    if(S.talents.includes('weakness_exploit_amp') && S.enemy && S.enemy.weak && S.enemy.weak.includes(w.elem)){
      wBonus += 4; // Additional +4 W from Weakness Exploit Amp
      lines.push(`<div class="tooltip-line"><span class="mod-badge word">+${wBonus} W</span> <span style="color:#60a5fa">Elemental Mastery</span> + <span style="color:#fbbf24">Weakness Exploit</span></div>`);
    } else {
      lines.push(`<div class="tooltip-line"><span class="mod-badge word">+${wBonus} W</span> <span style="color:#60a5fa">Elemental Mastery</span> <span style="color:#6b7280">(persists)</span></div>`);
    }
  }

  // Show morphological variants based on the WORD_FORMS mapping.  If a word has
  // adjective or noun forms different from its own name, display them so the
  // player understands how the word will change when placed in different slots.
  const forms = WORD_FORMS[w.id];
  if(forms){
    const adjVar = forms.adjPrimary || forms.adjForm || w.name;
    const altVar = forms.adjAlt && forms.adjAlt !== adjVar ? forms.adjAlt : null;
    const nounVar = forms.noun || forms.nounForm || w.name;
    // Only show if the adjective or noun forms differ from the word's name to avoid clutter
    if(adjVar !== w.name || nounVar !== w.name || altVar){
      const adjLine = altVar ? `${adjVar} (alt: ${altVar})` : adjVar;
      lines.push(`<div class="tooltip-line dim">Adjective form: ${adjLine}</div>`);
      lines.push(`<div class="tooltip-line dim">Noun form: ${nounVar}</div>`);
    }
  }

  // Show talent bonuses that specifically affect this word
  if(S.talents && S.talents.length > 0){
    const talentBonuses = getTalentBonusesForWord(w);
    if(talentBonuses.length > 0){
      lines.push(`<div class="tooltip-talents">`);
      talentBonuses.forEach(tb => {
        const badgeType = tb.type === 'W' ? 'word' : tb.type === 'AP' ? 'ap' : 'scale';
        const prefix = tb.type === 'x' ? '' : '+';
        const suffix = tb.type === 'x' ? '' : ` ${tb.type}`;
        lines.push(`<div class="tooltip-talent-row"><span class="talent-name-badge">${tb.name}</span> ${fmtMod(tb.value, badgeType, suffix)}</div>`);
      });
      lines.push(`</div>`);
    }
  }

  let elemBadge="";
  if(w.elem!==undefined){
    elemBadge=`<span class="tooltip-elem" style="background:${EC[w.elem]}33;color:${EC[w.elem]}">${EN[w.elem]}</span>`;
  }

  // Signature Style: show that this weapon gains hero's strong elements
  if(isSignatureStyleWeapon && S.hero.str && S.hero.str.length > 0){
    // Show both hero elements as badges with iridescent styling
    const elemBadges = S.hero.str.map(e =>
      `<span class="tooltip-elem" style="background:${EC[e]}33;color:${EC[e]}">${EN[e]}</span>`
    ).join(' ');
    elemBadge = elemBadges;
    // Also add a line explaining the Signature Style effect
    lines.push(`<div class="tooltip-line"><span class="talent-name-badge">Signature Style</span> Gains ${S.hero.str.map(e => EN[e]).join(' + ')}</div>`);
  }

  const typeParts = [tierLabel];
  if(elemBadge) typeParts.push(elemBadge);

  const inner = `
    <div class="tooltip-title ${rc}">${w.name}</div>
    <div class="tooltip-type">${typeParts.join(" ")}</div>
    ${lines.join("")}
  `;

  return opts?.bare ? inner : `<div class="tooltip">${inner}</div>`;
}

// Build a breakdown of all AP contributions and multipliers currently affecting the damage preview.
function formatDamageBreakdown(source){
  const calculated = source || (S.sel.item ? calc({ breakdown: true }) : null);
  if(!calculated || !calculated.breakdown) return '';
  const c = calculated;
  const fmtNum=(v)=>Number.isInteger(v)?v:parseFloat(v.toFixed(2));

  // Helper to consolidate duplicate lines by source name
  // Groups lines like "+5 AP (TalentName)" or "√ó1.5 TalentName" and combines values
  function consolidateLines(lines, mode = 'ap') {
    const grouped = {};
    const ungrouped = [];

    lines.forEach(line => {
      // Try to extract source name and value
      // Patterns: "+5 AP (SourceName)", "<span...>+5</span> SourceName", "√ó1.5 SourceName"
      let sourceName = null;
      let value = 0;

      if (mode === 'ap') {
        // AP patterns
        const parenMatch = line.match(/\(([^)]+)\)\s*$/);
        const badgeMatch = line.match(/<\/span>\s*(.+?)(?:\s*\(|$)/);
        const simpleMatch = line.match(/AP\s+(.+?)(?:\s*\(|$)/);

        if (parenMatch) sourceName = parenMatch[1].trim();
        else if (badgeMatch) sourceName = badgeMatch[1].trim();
        else if (simpleMatch) sourceName = simpleMatch[1].trim();

        const valMatch = line.match(/[+]?([\d.]+)\s*(?:AP)?/);
        if (valMatch) value = parseFloat(valMatch[1]);
      } else if (mode === 'mult') {
        // Multiplier patterns
        const multMatch = line.match(/√ó([\d.]+)/);
        const nameMatch = line.match(/<\/span>\s*(.+?)(?:\s*\(|$)/) || line.match(/√ó[\d.]+\s+(.+?)(?:\s*\(|$)/);

        if (nameMatch) sourceName = nameMatch[1].trim();
        if (multMatch) value = parseFloat(multMatch[1]);
      } else if (mode === 'word') {
        // Word count patterns (+N W SourceName)
        const wMatch = line.match(/[+]?([\d.]+)\s*W/i);
        const nameMatch = line.match(/<\/span>\s*(.+?)(?:\s*\(|$)/) || line.match(/W\s+(.+?)(?:\s*\(|$)/i);

        if (nameMatch) sourceName = nameMatch[1].trim();
        if (wMatch) value = parseFloat(wMatch[1]);
      }

      // Clean up source name (remove HTML tags)
      if (sourceName) {
        sourceName = sourceName.replace(/<[^>]+>/g, '').trim();
      }

      if (sourceName && value && sourceName.length > 0 && sourceName.length < 50) {
        if (!grouped[sourceName]) grouped[sourceName] = { total: 0, count: 0, mode };
        if (mode === 'mult') {
          // Multipliers combine multiplicatively
          grouped[sourceName].total = grouped[sourceName].total === 0 ? value : grouped[sourceName].total * value;
        } else {
          // AP and W combine additively
          grouped[sourceName].total += value;
        }
        grouped[sourceName].count++;
      } else {
        ungrouped.push(line);
      }
    });

    // Convert back to formatted lines
    const result = [];
    Object.entries(grouped).forEach(([name, data]) => {
      const countStr = data.count > 1 ? ` (√ó${data.count})` : '';
      if (data.mode === 'ap') {
        result.push(`${fmtMod(data.total, 'ap', ' AP')} ${name}${countStr}`);
      } else if (data.mode === 'mult') {
        result.push(`${fmtMod(data.total, 'scale')} ${name}${countStr}`);
      } else if (data.mode === 'word') {
        result.push(`${fmtMod(data.total, 'word', ' W')} ${name}${countStr}`);
      }
    });

    return [...result, ...ungrouped];
  }

  // Separate AP sources into base words vs talent/bonus
  const baseWordLines = [];
  const talentAPLines = [];
  const rereadLines = [];

  c.breakdown.base.forEach(line => {
    if(line.includes('REREAD')){
      rereadLines.push(line);
    } else if(line.match(/^\+[\d.]+ [A-Z]/i) && !line.includes('(') || line.match(/^\+[\d.]+ [A-Z][a-z]+\s*\(/)){
      // Word contributions (e.g., "+2 Sword (slash)" or "+3 Fire")
      baseWordLines.push(line);
    } else {
      // Talent/bonus contributions
      talentAPLines.push(line);
    }
  });

  // Separate multipliers into word count vs scale multipliers
  const wordCountLines = [];
  const scaleMultLines = [];

  c.breakdown.multipliers.forEach(line => {
    if(line.includes('REREAD')){
      rereadLines.push(line);
    } else if(line.includes(' W ') || line.includes(' W<')){
      wordCountLines.push(line);
    } else {
      scaleMultLines.push(line);
    }
  });

  // Consolidate duplicates in each section
  const consolidatedTalentAP = consolidateLines(talentAPLines, 'ap');
  const consolidatedWordCount = consolidateLines(wordCountLines, 'word');
  const consolidatedScaleMult = consolidateLines(scaleMultLines, 'mult');

  // Sort consolidated scale multipliers by value (highest first) for consistent display
  consolidatedScaleMult.sort((a, b) => {
    const extractMult = (line) => {
      const match = line.match(/√ó([\d.]+)/);
      return match ? parseFloat(match[1]) : 1;
    };
    return extractMult(b) - extractMult(a); // Highest first
  });

  // Build HTML with two-column layout
  let html = '<div class="tooltip-title">Damage Breakdown</div>';
  html += '<div class="breakdown-grid">';

  // Left column: AP Sources
  html += '<div class="breakdown-col">';
  html += '<div class="breakdown-section-title">AP Sources</div>';
  baseWordLines.forEach(line => {
    html += `<div class="tooltip-line" style="font-size:10px">${line}</div>`;
  });
  if(consolidatedTalentAP.length){
    consolidatedTalentAP.forEach(line => {
      html += `<div class="tooltip-line" style="font-size:10px;color:#4ade80">${line}</div>`;
    });
  }
  html += '</div>';

  // Right column: Word Count
  html += '<div class="breakdown-col">';
  html += '<div class="breakdown-section-title">Word Count</div>';
  html += `<div class="tooltip-line" style="font-size:10px">${fmtMod(c.breakdown.wordCount,'word',' W')} Base Words</div>`;
  if(consolidatedWordCount.length){
    consolidatedWordCount.forEach(line => {
      html += `<div class="tooltip-line" style="font-size:10px">${line}</div>`;
    });
  }
  html += '</div>';

  html += '</div>'; // End grid

  // Compact totals row for quick read
  html += `<div class="breakdown-row" style="justify-content:center;gap:12px;margin:6px 0 8px 0;flex-wrap:wrap">`;
  html += `<div class="breakdown-total" style="min-width:120px"><span class="label">Total AP</span><span class="value">${fmtNum(c.baseAP)}</span></div>`;
  html += `<div class="breakdown-total" style="min-width:120px"><span class="label">Total W</span><span class="value">${fmtNum(c.breakdown.wordCount)}</span></div>`;
  html += `</div>`;

  // Global multipliers full-width
  html += '<div class="breakdown-section">';
  html += '<div class="breakdown-section-title">Global Multipliers</div>';
  if(consolidatedScaleMult.length){
    consolidatedScaleMult.forEach(line => {
      html += `<div class="tooltip-line" style="font-size:10px">${line}</div>`;
    });
  } else {
    html += `<div class="tooltip-line" style="font-size:10px;color:#9ca3af">None</div>`;
  }
  html += `<div class="breakdown-total"><span class="label">Total √ó</span><span class="value">${fmtMod(c.totalMultiplier,'scale')}</span></div>`;
  html += '</div>';

  // Rereads section (if any) - aggregate by talent name with (xN) count
  if(rereadLines.length){
    html += '<div class="breakdown-section">';
    html += '<div class="breakdown-section-title" style="color:#fb923c">Rereads</div>';

    // Group reread lines by talent name and aggregate
    const rereadByTalent = {};
    rereadLines.forEach(line => {
      // Extract talent name from "(TalentName REREAD)" pattern
      const talentMatch = line.match(/\((\w+)\s+REREAD\)/);
      if(talentMatch){
        const talentName = talentMatch[1];
        if(!rereadByTalent[talentName]) rereadByTalent[talentName] = { apTotal: 0, multTotal: 1, count: 0, hasMult: false };

        // Check if it's an AP line or multiplier line
        const apMatch = line.match(/^\+?([\d.]+)\s*AP/i) || line.match(/>([+-]?[\d.]+)<\/span>\s*AP/i);
        const multMatch = line.match(/√ó([\d.]+)/);

        if(apMatch){
          rereadByTalent[talentName].apTotal += parseFloat(apMatch[1]);
          rereadByTalent[talentName].count++;
        } else if(multMatch){
          rereadByTalent[talentName].multTotal *= parseFloat(multMatch[1]);
          rereadByTalent[talentName].hasMult = true;
        }
      } else {
        // Fallback for lines without talent pattern
        html += `<div class="tooltip-line breakdown-reread" style="font-size:10px">${line}</div>`;
      }
    });

    // Render aggregated talent rereads
    Object.entries(rereadByTalent).forEach(([talentName, data]) => {
      const countStr = data.count > 1 ? ` (√ó${data.count})` : '';
      if(data.apTotal > 0){
        html += `<div class="tooltip-line breakdown-reread" style="font-size:10px">${fmtMod(data.apTotal, 'ap', ' AP')} ${talentName} REREAD${countStr}</div>`;
      }
      if(data.hasMult && data.multTotal !== 1){
        html += `<div class="tooltip-line breakdown-reread" style="font-size:10px">${fmtMod(data.multTotal, 'scale')} ${talentName} REREAD${countStr}</div>`;
      }
    });

    html += '</div>';
  }

    // Word modifiers (gem, weapon type) - proficiency now affects W (handled in calc)
    if(c.breakdown.words.length){
      const nonRereadWords = c.breakdown.words.filter(l => !l.includes('REREAD'));
      // Consolidate word effects - try AP first, then mult
      let consolidatedWordEffects = consolidateLines(nonRereadWords, 'ap');
      // If AP consolidation didn't reduce much, try mult consolidation on remainder
      const stillUngrouped = consolidatedWordEffects.filter(l => !l.includes('(√ó'));
      if (stillUngrouped.length > 3) {
        consolidatedWordEffects = consolidateLines(consolidatedWordEffects, 'mult');
      }
      if(consolidatedWordEffects.length){
        html += '<div style="margin-top:6px">';
        html += '<div class="breakdown-section-title">Word Effects</div>';
        consolidatedWordEffects.forEach(line => {
          html += `<div class="tooltip-line" style="font-size:10px">${line}</div>`;
        });
        html += '</div>';
      }
    }

  // Final damage formula: (AP √ó W) √ó Multipliers with total in separate box
  const finalDmg = c.heroDmg;
  const hasTalentMult = c.totalMultiplier > 1;
  const formulaStr = hasTalentMult
    ? `(${fmtNum(c.baseAP)} AP √ó ${fmtNum(c.breakdown.wordCount)} W) √ó ${fmtNum(c.totalMultiplier)}`
    : `${fmtNum(c.baseAP)} AP √ó ${fmtNum(c.breakdown.wordCount)} W`;
  html += `<div class="breakdown-formula-row">`;
  html += `<div class="breakdown-formula">${formulaStr}</div>`;
  html += `<div class="breakdown-formula-equals">=</div>`;
  html += `<div class="breakdown-formula-total">${finalDmg}</div>`;
  html += `</div>`;

  return html;
}

// Scale the combat breakdown tooltip to fit viewport without adding scrollbars
function fitCombatBreakdownTooltip(el){
  if(!el) return;
  el.style.transform = 'translate(-50%, -50%) scale(1)';
  el.style.maxHeight = 'none';
  el.style.overflow = 'visible';
  el.style.transformOrigin = 'center center';

  requestAnimationFrame(() => {
    const rect = el.getBoundingClientRect();
    const maxH = window.innerHeight * 0.82;
    const maxW = window.innerWidth * 0.92;
    const scaleH = rect.height > maxH ? maxH / rect.height : 1;
    const scaleW = rect.width > maxW ? maxW / rect.width : 1;
    const scale = Math.min(scaleH, scaleW);
    const clamped = scale < 1 ? Math.max(scale, 0.6) : 1;
    const scaledHeight = rect.height * clamped;
    const topPx = Math.max(12, (window.innerHeight - scaledHeight) / 2);
    el.style.left = '50%';
    el.style.top = `${topPx}px`;
    el.style.transform = `translate(-50%, 0) scale(${clamped})`;
    el.style.maxHeight = `${Math.floor(maxH)}px`;
    el.style.overflow = 'auto';
  });
}

function getSharedBreakdownContent(precomputed){
  return formatDamageBreakdown(precomputed) || '<div class="tooltip-line">Forge a weapon to see the breakdown.</div>';
}

function attachDamageTooltip(el){
  if(!el) return;
  el.classList.add('has-tooltip');
  el.setAttribute('tabindex','0');

  let tooltip;
  const isPreviewNode = (el.id === 'damage-preview-text' || el.id === 'combat-result' || el.id === 'combat-total');

  if(isPreviewNode) {
    // 1. CLEANUP: Remove any "trapped" tooltips inside the element from previous logic
    const trappedTooltip = el.querySelector('.tooltip.modal-tooltip');
    if(trappedTooltip) trappedTooltip.remove();

    // 2. PORTAL STRATEGY: Create tooltip on <body> to escape Z-index traps
    const portalId = el.id + '-tooltip-portal';
    tooltip = document.getElementById(portalId);

    if(!tooltip){
      tooltip = document.createElement('div');
      tooltip.id = portalId;
      // FIX: Removed 'tooltip' class to prevent width:260px conflict from styles.css
      tooltip.className = 'modal-tooltip';
      tooltip.classList.add('breakdown-tooltip');

      // --- FORCE INLINE STYLES TO FIX SIZING/LAYERING ---
      tooltip.style.cssText = `
        position: fixed !important;
        z-index: 999999 !important;
        pointer-events: none !important;
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.98);
        transition: opacity 0.12s ease, transform 0.12s ease;

        /* Sizing Logic: Grow with text, but don't get too wide */
        width: auto !important;
        min-width: 300px !important;
        height: auto !important;
        max-width: 560px !important;
        white-space: normal !important;
        word-wrap: break-word !important;
        overflow-wrap: break-word !important;

        /* Visuals (Replicating .tooltip style manually since we removed the class) */
        background: #1a1d24 !important;
        border: 1px solid #4b5563 !important;
        border-radius: 8px !important;
        padding: 12px !important;
        box-shadow: 0 10px 30px rgba(0,0,0,0.9) !important;
        color: #e5e7eb !important;
        font-size: 11px !important;
        line-height: 1.4 !important;
        text-align: left !important;
        max-height: none !important;
        overflow: visible !important;
      `;

      document.body.appendChild(tooltip);
    } else {
      tooltip.classList.add('breakdown-tooltip');
    }
  } else {
    // STANDARD STRATEGY
    tooltip = el.querySelector('.tooltip.modal-tooltip');
    if(!tooltip){
      tooltip = document.createElement('div');
      tooltip.className = 'tooltip modal-tooltip';
      tooltip.style.whiteSpace = 'normal';
      tooltip.style.pointerEvents = 'none';
      el.appendChild(tooltip);
    }
  }

  if(el.__tooltipAttached) return;
  el.__tooltipAttached = true;

  const clickToggle = el.classList.contains('click-tooltip');

  const show = () => {
    // 1. Set Content
    const content = typeof el.__tooltipContent === 'function'
      ? (el.__tooltipContent() || '')
      : (el.__tooltipContent || '');

    tooltip.innerHTML = content;

    // 2. Calculate Position (CENTERED on screen like combat breakdown)
    if(isPreviewNode) {
      tooltip.style.left = '50%';
      tooltip.style.top = '50%';
      tooltip.style.transform = 'translate(-50%, -50%) scale(1)';
    }

    if(clickToggle) tooltip.style.pointerEvents = 'auto';

    // 3. Fade In
    tooltip.style.opacity = content ? '1' : '0';
    tooltip.dataset.visible = content ? 'true' : 'false';
  };

  const hide = () => {
    tooltip.style.opacity = '0';
    tooltip.dataset.visible = 'false';
    if(isPreviewNode){
      tooltip.style.transform = 'translate(-50%, -50%) scale(0.98)';
    }
  };

  if(clickToggle){
    const toggle = (e) => {
      e.stopPropagation();
      const isOpen = tooltip.dataset.visible === 'true';
      if(isOpen){ hide(); } else { show(); }
    };

    // Store listeners on element for cleanup
    const keydownHandler = (e) => {
      if(e.key === 'Enter' || e.key === ' '){
        e.preventDefault();
        toggle(e);
      }
    };

    const documentClickHandler = (evt) => {
      if(!el.contains(evt.target)) hide();
    };

    // Remove old listeners if they exist
    if(el.__tooltipKeydownHandler){
      el.removeEventListener('keydown', el.__tooltipKeydownHandler);
    }
    if(el.__tooltipDocumentClickHandler){
      document.removeEventListener('click', el.__tooltipDocumentClickHandler);
    }

    // Store new listeners on element
    el.__tooltipKeydownHandler = keydownHandler;
    el.__tooltipDocumentClickHandler = documentClickHandler;

    // Add new listeners
    el.addEventListener('click', toggle);
    el.addEventListener('keydown', keydownHandler);
    document.addEventListener('click', documentClickHandler);
  } else {
    ['mouseenter','focus'].forEach(evt=>el.addEventListener(evt,show));
    ['mouseleave','blur'].forEach(evt=>el.addEventListener(evt,hide));
  }
}

function isWordDisabled(w,hasItem,hasNoun){
  // Basic rules:
  // 1. Require selecting a weapon first; non‚Äëweapons are disabled until a weapon is chosen.
  if(w.type !== 'weapon' && !hasItem) return true;
  // 2. Only one weapon can be selected at a time (except the backup stick).
  if(w.type === 'weapon' && S.sel.item) return true;
  // 3. Only one rarity word can be selected at a time.
  if(w.type === 'rarity'){
    const hasRarityInSlots = ['adj1','adj2','adj3','adj4','noun1'].some(
      slotKey => S.sel[slotKey] && S.sel[slotKey].type === 'rarity'
    );
    if(hasRarityInSlots) return true;
  }
  // Determine if all modifier slots are full (four adjective slots and one gem)
  const adjFull = !!(S.sel.adj1 && S.sel.adj2 && S.sel.adj3 && S.sel.adj4);
  const nounFull = !!S.sel.noun1;
  // 4. For all non‚Äëweapons: disable only when no modifier slots are available.
  if(w.type !== 'weapon'){
    return adjFull && nounFull;
  }
  return false;
}

function clickWord(w, clickedChip = null){
  // Add pop-out animation to the clicked chip (if provided and not in low FX mode)
  if (clickedChip && !gfxSettings.lowFx) {
    clickedChip.classList.add('popping-out');
  }

  // Determine which slot will receive this word
  let targetSlot;
  if(w.type === 'weapon'){
    // Selecting a weapon resets all modifier slots
    S.sel.item = w;
    targetSlot = 'item';
  } else {
    // For all non-weapons, fill the first available adjective slot, then the gem slot.
    if(!S.sel.adj1) { S.sel.adj1 = w; targetSlot = 'adj1'; }
    else if(!S.sel.adj2) { S.sel.adj2 = w; targetSlot = 'adj2'; }
    else if(!S.sel.adj3) { S.sel.adj3 = w; targetSlot = 'adj3'; }
    else if(!S.sel.adj4) { S.sel.adj4 = w; targetSlot = 'adj4'; }
    else if(!S.sel.noun1) { S.sel.noun1 = w; targetSlot = 'noun1'; }
    else { S.sel.adj1 = w; targetSlot = 'adj1'; }
  }

  // Delay the render and slot effects to let pop-out animation play
  const delay = (clickedChip && !gfxSettings.lowFx) ? 120 : 0;

  // Cache slot reference and bounding rect before setTimeout to avoid layout reflow during animation
  const slot = document.querySelector(`[data-slot="${targetSlot}"].slot`);
  const slotRect = slot ? slot.getBoundingClientRect() : null;

  setTimeout(() => {
    // Create dust puff effect at the target slot
    setTimeout(() => {
      if(slot && slotRect){
        const dustX = slotRect.left + slotRect.width / 2;
        const dustY = slotRect.top + slotRect.height / 2;
        // Use element-colored anvil sparks
        const sparkColors = getElementSparkColors(w);
        burstSparks(dustX, dustY, 10, sparkColors, false);

        // Add pop-in animation to the slot content
        if (!gfxSettings.lowFx) {
          const slotContent = slot.querySelector('.slot-content');
          if (slotContent) {
            slotContent.classList.add('popping-in');
            setTimeout(() => slotContent.classList.remove('popping-in'), RHYTHM.HALF);
          }
        }
      }
    }, 50);

    render();
  }, delay);
}

// Wrapper that triggers elemental FX from slot to weapon
function createAuraAnimation(fromSlot, slotKey, word) {
  // Target is always the central weapon SVG
  const weaponSvg = document.getElementById("weapon-svg");
  playElementalEffect(fromSlot, weaponSvg, word);
}

function attachParallaxTilt(wrapper){
  if(!wrapper || wrapper.dataset.parallaxInit) return;
  const prefersReduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  const hoverable = window.matchMedia ? window.matchMedia('(hover: hover)').matches : true;
  if(prefersReduce || !hoverable){
    wrapper.dataset.parallaxEnabled = 'false';
    wrapper.dataset.parallaxInit = '1';
    return;
  }

  const maxTilt = 3;
  const handleMove = (e)=>{
    // Skip parallax in Low FX mode
    if (gfxSettings.lowFx) return;
    const rect = wrapper.getBoundingClientRect();
    const x = (e.clientX - rect.left) / rect.width - 0.5;
    const y = (e.clientY - rect.top) / rect.height - 0.5;
    wrapper.style.setProperty('--tilt-y', `${(x * maxTilt).toFixed(2)}deg`);
    wrapper.style.setProperty('--tilt-x', `${(-y * maxTilt).toFixed(2)}deg`);
  };
  const reset = ()=>{
    wrapper.style.setProperty('--tilt-x','0deg');
    wrapper.style.setProperty('--tilt-y','0deg');
  };
  wrapper.addEventListener('pointermove', handleMove);
  wrapper.addEventListener('pointerleave', reset);
  wrapper.dataset.parallaxEnabled = 'true';
  wrapper.dataset.parallaxInit = '1';
}

function ensureWeaponLayers(target){
  const host = typeof target === 'string' ? $(target) : target;
  if(!host) return null;
  host.classList.add('weapon-canvas');
  // Check if we need to recreate layers (missing new structure or old flair-based structure)
  const existing = host.querySelector('.weapon-layered');
  const needsRecreate = !existing || !existing.querySelector('.weapon-layer.gem');
  if(needsRecreate){
    // New modular layers: base, gem (noun1), adj1-4 effects
    // Weapon tilted 15deg right for depth with parallax
    host.innerHTML = `<div class="weapon-layered" style="transform:rotate(15deg)"><div class="weapon-shadow"></div><svg class="weapon-layer base" viewBox="0 0 100 130"></svg><svg class="weapon-layer gem" viewBox="0 0 100 130"></svg><svg class="weapon-layer adj adj1" viewBox="0 0 100 130"></svg><svg class="weapon-layer adj adj2" viewBox="0 0 100 130"></svg><svg class="weapon-layer adj adj3" viewBox="0 0 100 130"></svg><svg class="weapon-layer adj adj4" viewBox="0 0 100 130"></svg><div class="weapon-glow"></div></div>`;
    attachParallaxTilt(host.querySelector('.weapon-layered'));
  }
  const wrapper = host.querySelector('.weapon-layered');
  // Ensure rotation is always applied (for existing structures)
  wrapper.style.transform = 'rotate(15deg)';
  const base = host.querySelector('.weapon-layer.base');
  const gem = host.querySelector('.weapon-layer.gem');
  const adj1 = host.querySelector('.weapon-layer.adj1');
  const adj2 = host.querySelector('.weapon-layer.adj2');
  const adj3 = host.querySelector('.weapon-layer.adj3');
  const adj4 = host.querySelector('.weapon-layer.adj4');
  const glow = host.querySelector('.weapon-glow');
  const shadow = host.querySelector('.weapon-shadow');
  // Legacy compatibility - map flair1 to gem, flair2 to adj1
  return {host, wrapper, base, gem, adj1, adj2, adj3, adj4, flair1: gem, flair2: adj1, glow, shadow};
}

function clearWeaponLayers(layers){
  if(!layers) return;
  if(layers.base) layers.base.innerHTML = '';
  if(layers.gem) layers.gem.innerHTML = '';
  if(layers.adj1) layers.adj1.innerHTML = '';
  if(layers.adj2) layers.adj2.innerHTML = '';
  if(layers.adj3) layers.adj3.innerHTML = '';
  if(layers.adj4) layers.adj4.innerHTML = '';
  if(layers.glow) layers.glow.style.background = 'none';
  if(layers.shadow) layers.shadow.style.background = 'none';
}

function setupEvents(){
  // Attach click handlers to each slot to support assigning selected words or removing existing ones.
  ["item","adj1","adj2","adj3","adj4","noun1"].forEach(k=>{
    const slot = document.querySelector(`[data-slot="${k}"].slot`);
    if(!slot) return;
    slot.onclick = () => {
      const selected = S.pendingWord;
      // If a word is selected from the bank, attempt to place it into this slot
      if(selected){
        // Only restrict weapons: they must occupy the weapon slot.  Non-weapons
        // cannot be placed into the weapon slot, and weapons cannot occupy other
        // slots.  Otherwise, allow placement freely; nouns, adjectives and
        // affinities can occupy any modifier slot.
        if(selected.type === 'weapon' && k !== 'item'){
          return;
        }
        if(selected.type !== 'weapon' && k === 'item'){
          return;
        }

        // Only one rarity word allowed - check if another slot already has one
        // (unless we're replacing the rarity word in the same slot)
        if(selected.type === 'rarity'){
          const hasRarityElsewhere = ['adj1','adj2','adj3','adj4','noun1'].some(
            slotKey => slotKey !== k && S.sel[slotKey] && S.sel[slotKey].type === 'rarity'
          );
          if(hasRarityElsewhere) return;
        }

        // === PERFORMANCE TRACKING: Word Slot Placement ===
        const slotStart = performance.now();
        const timings = {};

        // SWAP LOGIC: If slot already has a word, remove it first
        // Track if we're swapping so we know to do a full bank rebuild (not fast path)
        const isSwapping = !!(S.sel[k] && k !== 'item');
        if(isSwapping){
          stopRarityDrone(k); // Stop drone if swapping out a rarity adjective
          S.sel[k] = null;
        }

        // If placing a weapon, clear all modifier slots
        if(k === 'item'){
          clrSel();
          S.sel.item = selected;
        } else {
          // Place the selected word into the chosen slot
          S.sel[k] = selected;
        }
        // Clear the selection and re-render UI
        S.pendingWord = null;

        // Add visual feedback when placing word
        slot.classList.add('word-placed');
        setTimeout(() => slot.classList.remove('word-placed'), RHYTHM.HALF);

        timings.stateMs = performance.now() - slotStart;
        const soundStart = performance.now();

        // Play sounds based on word type and element
        try{
          // Play rarity drone pad AND rarity.ogg for rarity adjective words
          const rarityAdjIds = ['adj_common', 'adj_uncommon', 'adj_magic', 'adj_rare', 'adj_epic', 'adj_legendary'];
          if (selected.id && rarityAdjIds.includes(selected.id)) {
            playRarityDrone(selected.id);
            playSample('rarity.ogg', 0.5);
          }

          // Get stereo pan based on slot position
          const slotPan = getSlotPan(k);

          // Add gem tink sound for noun slot (gem socket)
          if (k === 'noun1') {
            playSample('gem.ogg', 0.7, slotPan);
          }

          // Play weapon-specific insertion sounds for weapon slot
          if (k === 'item' && selected.type === 'weapon' && !selected.isStick) {
            if (selected.category === 'slash') {
              playSample('insert sword bow type.ogg', 0.8, slotPan);
            } else if (selected.category === 'pierce') {
              playSample('insert bow type.ogg', 0.8, slotPan);
            } else if (selected.category === 'blunt') {
              playSample('insert blunt.ogg', 0.8, slotPan);
            } else if (selected.category === 'magic') {
              playSample('insert wand sound.ogg', 0.8, slotPan);
            }
          }

          // Play element-specific sounds with position-based panning
          if (selected.elem !== undefined) {
            const elemSample = ELEMENT_SAMPLES[selected.elem];
            if (elemSample) {
              const volume = (selected.elem === E.LIGHTNING || selected.elem === E.PHYS) ? 0.5 : 0.3;
              playSample(elemSample, volume, slotPan);
            }
          }
        }catch(err){}

        timings.soundMs = performance.now() - soundStart;
        const fxStart = performance.now();

        // Create anvil sparks at slot position with element colors
        const slotRect = slot.getBoundingClientRect();
        const dustX = slotRect.left + slotRect.width / 2;
        const dustY = slotRect.top + slotRect.height / 2;
        const sparkColors = getElementSparkColors(selected);
        burstSparks(dustX, dustY, 10, sparkColors, false);

        // Trigger elemental FX from slot to weapon
        createAuraAnimation(slot, k, selected);

        timings.fxMs = performance.now() - fxStart;
        const flipStart = performance.now();

        // Set flag for pop-in animation on the placed slot and trigger FLIP
        if (!gfxSettings.lowFx) {
          justPlacedSlot = k;
          // Record positions NOW before state change, then set flag for playback after render
          recordFlipPositions($("#bank"));
          pendingBankFlip = true;
        }

        timings.flipMs = performance.now() - flipStart;
        const renderStart = performance.now();

        // Set fast remove hint for renderBank optimization
        // Skip fast path when swapping - need full rebuild to add old word back to bank
        _fastRemoveWordId = isSwapping ? null : (selected.id || null);
        render();

        timings.renderMs = performance.now() - renderStart;
        timings.totalMs = performance.now() - slotStart;

        // Log performance event
        if (typeof window.logPerfEvent === 'function') {
          window.logPerfEvent('WORD_SLOT', {
            word: selected.text || selected.id || 'unknown',
            slot: k,
            lowFx: gfxSettings.lowFx,
            ...timings
          });
        }

        // Onboarding hook
        if (ONBOARD.active) {
          onOnboardingWordPlaced(selected, k);
        }

        return;
      }
      // If no word is selected, clicking a filled slot removes the word
      if(S.sel[k]){
        const removedWord = S.sel[k]; // Store before clearing
        playSample('highlight word.ogg', 0.5);
        stopRarityDrone(k); // Stop drone if this slot had a rarity adjective

        // Record positions NOW for FLIP animation when word returns to bank
        if (!gfxSettings.lowFx) {
          recordFlipPositions($("#bank"));
          pendingBankFlip = true;
        }

        S.sel[k] = null;
        // Removing the weapon clears all modifier slots and the noun
        if(k === 'item'){
          stopAllRarityDrones(); // Stop all drones when weapon removed
          S.sel.adj1 = null; S.sel.adj2 = null; S.sel.adj3 = null; S.sel.adj4 = null;
          S.sel.noun1 = null;
        }
        render();
      }
    };

    // Drag-and-drop disabled - use click-to-select instead
  });

  // Add global click sparks for blacksmith workshop feel (controlled by Combat Effects setting)
  if(!document.body.__clickSparksAttached){
    document.body.__clickSparksAttached = true;
    document.body.addEventListener('click', (e) => {
      // Skip click sparks in Low FX mode
      if (gfxSettings.lowFx) return;

      // Don't trigger sparks on UI buttons or interactive elements
      const target = e.target;
      if(target.tagName === 'BUTTON' || target.closest('button') ||
         target.classList.contains('word') || target.classList.contains('slot') ||
         target.classList.contains('consumable-item') || target.classList.contains('crate')) {
        return;
      }

      // Blacksmith anvil strike sparks - thin, long streaks
      createFizzySparks(e.clientX, e.clientY, {
        count: 6,
        colors: ['#ff9933', '#ffcc00', '#ffaa44'],
        shape: 'line',
        size: 4,
        velocity: 3,
        gravity: 0.15,
        duration: 800,
        initialOpacity: 0.85
      });
    });
  }
}

function renderWeapon(target="#weapon-svg"){
  const layers = ensureWeaponLayers(target);
  const s=S.sel;
  if(!layers){return}

  // Remove fly-out animation class when re-rendering main weapon display
  if(target==="#weapon-svg"){
    const mainWeaponCanvas = document.querySelector('#weapon-display .weapon-canvas');
    if(mainWeaponCanvas) mainWeaponCanvas.classList.remove('fly-out');
  }

  if(!s.item){
    clearWeaponLayers(layers);
    if(target==="#weapon-svg"){
      $("#weapon-name").textContent="";
      const aura = document.getElementById("weapon-aura");
      if(aura) aura.style.background = 'none';
    } else if(target==="#combat-weapon-svg"){
      const aura = document.getElementById("combat-weapon-aura");
      if(aura) aura.style.background = 'none';
    }
    return;
  }

  const wt=s.item.isStick?"stick":s.item.id;
  const tmpl=WEAPON_SVG[wt];
  const baseCol=BASE_COLORS[wt];

  // Get colors for each slot
  const gemCol = s.noun1 && s.noun1.elem !== undefined ? EC[s.noun1.elem] : "transparent";
  const adj1Col = s.adj1 && s.adj1.elem !== undefined ? EC[s.adj1.elem] : "transparent";
  const adj2Col = s.adj2 && s.adj2.elem !== undefined ? EC[s.adj2.elem] : "transparent";
  const adj3Col = s.adj3 && s.adj3.elem !== undefined ? EC[s.adj3.elem] : "transparent";
  const adj4Col = s.adj4 && s.adj4.elem !== undefined ? EC[s.adj4.elem] : "transparent";

  // Render base weapon
  if(layers.base) layers.base.innerHTML=tmpl.base.replace(/BASECOLOR/g,baseCol);

  // Render gem (noun1 slot) - new modular system
  if(layers.gem && tmpl.gem){
    layers.gem.innerHTML = s.noun1 ? tmpl.gem.replace(/GEMCOLOR/g,gemCol) : "";
  }

  // Render adjective effects (adj1-4 slots) - new modular system
  if(layers.adj1 && tmpl.adj1){
    layers.adj1.innerHTML = s.adj1 ? tmpl.adj1.replace(/ADJ1COLOR/g,adj1Col) : "";
  }
  if(layers.adj2 && tmpl.adj2){
    layers.adj2.innerHTML = s.adj2 ? tmpl.adj2.replace(/ADJ2COLOR/g,adj2Col) : "";
  }
  if(layers.adj3 && tmpl.adj3){
    layers.adj3.innerHTML = s.adj3 ? tmpl.adj3.replace(/ADJ3COLOR/g,adj3Col) : "";
  }
  if(layers.adj4 && tmpl.adj4){
    layers.adj4.innerHTML = s.adj4 ? tmpl.adj4.replace(/ADJ4COLOR/g,adj4Col) : "";
  }

  // Pre-baked soft shadow gradient (no CSS blur filter needed)
  if(layers.shadow) layers.shadow.style.background = `radial-gradient(circle at 50% 10%, ${baseCol}40 0%, ${baseCol}30 15%, ${baseCol}18 30%, ${baseCol}08 45%, transparent 65%)`;

  // Use the new #weapon-aura element for background glow (for main weapon and combat weapon)
  // Pre-baked soft gradient with feathered edges (no CSS blur filter needed)
  if(target==="#weapon-svg"){
    const aura = document.getElementById("weapon-aura");
    if(aura){
      // Use noun color (gemCol) or base color
      const color = (s.noun1 && s.noun1.elem !== undefined) ? gemCol : baseCol;
      aura.style.background = `radial-gradient(circle, ${color}50 0%, ${color}40 10%, ${color}30 20%, ${color}20 35%, ${color}10 50%, ${color}08 60%, ${color}04 70%, ${color}02 80%, transparent 90%)`;
    }
  } else if(target==="#combat-weapon-svg"){
    const aura = document.getElementById("combat-weapon-aura");
    if(aura){
      // Use noun color (gemCol) or base color
      const color = (s.noun1 && s.noun1.elem !== undefined) ? gemCol : baseCol;
      aura.style.background = `radial-gradient(circle, ${color}50 0%, ${color}40 10%, ${color}30 20%, ${color}20 35%, ${color}10 50%, ${color}08 60%, ${color}04 70%, ${color}02 80%, transparent 90%)`;
    }
  }

  if(target==="#weapon-svg"){
    const parts=buildWeaponNameParts();
    const nm=buildWeaponNameFromParts(parts);
    const weaponNameEl=$("#weapon-name");
    if(weaponNameEl){
      weaponNameEl.setAttribute('aria-label', nm);
      weaponNameEl.innerHTML=parts.map(p=>{
        const safeText=escapeHtml(p.text);
        return p.italic?`<em class="connector-phrase">${safeText}</em>`:safeText;
      }).join(' ');
    }
  }
}

// Render a partial weapon based on progress (0‚Äì1).  At 0, nothing is shown;
// progress 0-0.3: base weapon, 0.3-0.5: adj1/adj2, 0.5-0.7: adj3/adj4, 0.7-1.0: gem
// Colours are derived from the currently selected words.
// This helper is used during combat to visually build the weapon as each word is tallied.
function renderWeaponProgress(target, progress){
  const layers = ensureWeaponLayers(target);
  const s = S.sel || {};
  if(!layers) return;
  if(!s.item){
    clearWeaponLayers(layers);
    return;
  }
  const wt = s.item.isStick ? 'stick' : s.item.id;
  const tmpl = WEAPON_SVG[wt];
  if(!tmpl){
    clearWeaponLayers(layers);
    return;
  }
  const baseCol = BASE_COLORS[wt] || '#888';
  const gemCol = s.noun1 && s.noun1.elem !== undefined ? EC[s.noun1.elem] : 'transparent';
  const adj1Col = s.adj1 && s.adj1.elem !== undefined ? EC[s.adj1.elem] : 'transparent';
  const adj2Col = s.adj2 && s.adj2.elem !== undefined ? EC[s.adj2.elem] : 'transparent';
  const adj3Col = s.adj3 && s.adj3.elem !== undefined ? EC[s.adj3.elem] : 'transparent';
  const adj4Col = s.adj4 && s.adj4.elem !== undefined ? EC[s.adj4.elem] : 'transparent';

  // Helper to set layer content with slam animation
  function setLayerWithSlam(layer, content){
    if(!layer) return;
    const hadContent = layer.innerHTML.trim() !== '';
    const willHaveContent = content && content.trim() !== '';
    layer.innerHTML = content || '';
    // Trigger slam animation when content appears for the first time (double-rAF avoids forced reflow)
    if(!hadContent && willHaveContent){
      layer.classList.remove('slam-in');
      requestAnimationFrame(() => {
        requestAnimationFrame(() => layer.classList.add('slam-in'));
      });
    }
  }

  // Progressive reveal: base -> adj1/2 -> adj3/4 -> gem
  setLayerWithSlam(layers.base, progress > 0 ? tmpl.base.replace(/BASECOLOR/g, baseCol) : '');
  if(tmpl.adj1) setLayerWithSlam(layers.adj1, (progress >= 0.3 && s.adj1) ? tmpl.adj1.replace(/ADJ1COLOR/g, adj1Col) : '');
  if(tmpl.adj2) setLayerWithSlam(layers.adj2, (progress >= 0.4 && s.adj2) ? tmpl.adj2.replace(/ADJ2COLOR/g, adj2Col) : '');
  if(tmpl.adj3) setLayerWithSlam(layers.adj3, (progress >= 0.5 && s.adj3) ? tmpl.adj3.replace(/ADJ3COLOR/g, adj3Col) : '');
  if(tmpl.adj4) setLayerWithSlam(layers.adj4, (progress >= 0.6 && s.adj4) ? tmpl.adj4.replace(/ADJ4COLOR/g, adj4Col) : '');
  if(tmpl.gem) setLayerWithSlam(layers.gem, (progress >= 0.8 && s.noun1) ? tmpl.gem.replace(/GEMCOLOR/g, gemCol) : '');
  if(layers.glow) layers.glow.style.background = progress >= 1.0 ? `radial-gradient(circle at 50% 35%, ${gemCol!=="transparent"?gemCol:baseCol}55, transparent 70%)` : 'none';
  // Pre-baked soft shadow gradient (no CSS blur filter needed)
  if(layers.shadow) layers.shadow.style.background = `radial-gradient(circle at 50% 10%, ${baseCol}40 0%, ${baseCol}30 15%, ${baseCol}18 30%, ${baseCol}08 45%, transparent 65%)`;
}

function buildWeaponNameParts(){
  const s=S.sel;
  const parts=[];

  function addWord(word, slotKey){
    if(!word) return;
    parts.push({text:getDisplayForm(word, slotKey, s), italic:false});
  }

  // Order: adj1 adj2 weapon of [the] adj3 adj4 noun1
  addWord(s.adj1, 'adj1');
  addWord(s.adj2, 'adj2');
  addWord(s.item, 'item');

  // If a gem is present, always include "of the" and then any adjectives
  // after the gem and the gem itself.  This removes ambiguity between
  // "of" and "of the" and makes the sentence structure consistent.
  if(s.noun1){
    parts.push({text:'of the', italic:true});
    addWord(s.adj3, 'adj3');
    addWord(s.adj4, 'adj4');
    addWord(s.noun1, 'noun1');
  }
  return parts;
}

function buildWeaponNameFromParts(parts=buildWeaponNameParts()){
  return parts.map(p=>p.text).join(' ');
}

// === CALCULATION WITH TALENT HOOKS ===
function getCombatants(){
  const defaultHero={hp:100,str:[],weak:[],good:null,bad:null,name:"Hero"};
  const defaultEnemy={hp:50,ap:0,weak:[],res:[],name:"Enemy"};
  if(!S.hero) console.warn("[combat] Missing hero data; using defaults");
  if(!S.enemy) console.warn("[combat] Missing enemy data; using defaults");

  // Deep copy hero and enemy to avoid shared array references
  const hero = {...defaultHero,...(S.hero||{})};
  const enemy = {...defaultEnemy,...(S.enemy||{})};

  // Deep copy arrays to prevent mutations from affecting original state
  if(hero.str) hero.str = [...hero.str];
  if(hero.weak) hero.weak = [...hero.weak];
  if(enemy.weak) enemy.weak = [...enemy.weak];
  if(enemy.res) enemy.res = [...enemy.res];

  return {hero, enemy};
}

function calc(opts={}){
  const wantBreakdown = !!(opts.breakdown || opts.wantBreakdown);
  const breakdown = wantBreakdown ? { base: [], words: [], multipliers: [], wordCount: 0 } : null;
  const {hero:h,enemy:e}=getCombatants();
  const s = S.sel;
  const hasTalent=(id)=>S.talents.includes(id);
  const hasWeaponMaster=!!(S.tempEffects && S.tempEffects.weaponMaster);

  // Apply CALC_INIT modifiers (e.g., Druid's Rooted passive)
  applyModifiers('CALC_INIT', {hero: h, enemy: e, sel: s, state: S, breakdown});

  const weakTo=(el)=>e.weak.includes(el);
  const resists=(el)=>!(S.tempEffects && S.tempEffects.polymorph) && e.res.includes(el);
  const fmtNum=(v)=>Number.isInteger(v)?v:parseFloat(v.toFixed(2));

  // Collect all selected words from slots in combat order (adj1, adj2, weapon, adj3, adj4, noun1)
  // Chapter boss mechanics may block certain slots (unless Silencer consumable is active)
  const silencerActive = S.tempEffects && S.tempEffects.disableBossAbility;
  const blockedSlot = silencerActive ? null : S.blockedSlot; // Red Aktins blocks a random slot
  const ignoreLastSlot = S.chapterBoss && S.chapterBoss.id === 'dotdotdot' && !silencerActive; // Dotdotdot ignores noun1

  // Build effective selection that respects boss mechanics
  const effectiveSel = {...s};
  if(blockedSlot && effectiveSel[blockedSlot]){
    effectiveSel[blockedSlot] = null; // Red Aktins: blocked slot doesn't count
  }
  if(ignoreLastSlot){
    effectiveSel.noun1 = null; // Dotdotdot: last slot ignored
  }

  const allWords = [effectiveSel.adj1, effectiveSel.adj2, effectiveSel.item, effectiveSel.adj3, effectiveSel.adj4, effectiveSel.noun1].filter(Boolean);

  // Build context object for talent application
  const ctx = {
    hero: h,
    enemy: e,
    allWords: allWords,
    weapon: s.item,
    sel: s,  // Add selection for slot-based talents like Hendiadys
    state: S,
    talentCount: S.talents.length,
    breakdown: breakdown
  };

  // ========================================
  // PHASE 1: FLAT AP BONUSES (+AP Talents)
  // ========================================
  // NOTE: Per-word talents (verbose, eloquent, erudite, fundamental, adjectival_emphasis,
  // nominal_power, elemental_amplification, arsenal_mastery, element-specific talents,
  // weapon damage type talents) are now handled inside getWordAP() to ensure they appear
  // in both damage calculations AND tooltips. Only truly global/structural bonuses remain here.
  let flatAPBonus = 0;

  // Global structural talents that apply to the weapon as a whole
  // Per-word talents (verbose, eloquent, fundamental, family-based element, etc.)
  // are handled in getWordAP() - they apply per matching word
  // Per-word W talents handled in computeWordCountBonuses(): world_sky_focus, body_soul_focus, weakness_exploit
  // No global flat_ap talents remain after consolidation

  // Legacy talents that don't fit the modular system yet
  if(hasTalent("battle_hardened")){
    flatAPBonus += S.battleHardenedBonus;
    if(wantBreakdown && S.battleHardenedBonus){
      breakdown.base.push(`${fmtMod(S.battleHardenedBonus, 'ap', ' AP')} Battle Hardened`);
    }
  }

  const visibleInvCount = S.inv.filter(w => !w.hiddenInBank).length;
  if(hasTalent("word_hoarder") && visibleInvCount > 15){
    const basePerWord = scaleTalentBonus('word_hoarder', 1);
    const bonus = (visibleInvCount - 15) * basePerWord;
    flatAPBonus += bonus;
    if(wantBreakdown){
      breakdown.base.push(`${fmtMod(bonus, 'ap', ' AP')} Word Hoarder`);
    }
  }

  if(hasTalent("descriptive")){
    const adjCount = allWords.filter(w=>w.type==='rarity').length;
    const basePerAdj = scaleTalentBonus('descriptive', 1);
    const bonus = adjCount * basePerAdj;
    flatAPBonus += bonus;
    if(wantBreakdown && bonus){
      breakdown.base.push(`${fmtMod(bonus, 'ap', ' AP')} Descriptive`);
    }
  }

  let wordCount = 0;
  let heroBonus = 1.0;
  let weaponWord = null;

  // [T3] Sharpening Stone: 25% chance to upgrade tier
  const tempTierBoost = {};
  if(hasTalent("sharpening_stone")){
    allWords.forEach((w,idx)=>{
      if(!w.isStick && Math.random() < 0.25){
        tempTierBoost[idx] = 1;
      }
    });
  }

  let wordBaseAPTotal = 0;
  // Reset weaponWord
  weaponWord = null;

  // Create a map to store each word's contribution data for retrigger talents
  const wordDataMap = new Map();

  // === CHAPTER BOSS MECHANICS ===
  // Check if boss ability is disabled by Silencer consumable
  const bossDisabledEarly = S.tempEffects && S.tempEffects.disableBossAbility;

  // Plague Doctor: Immune to hero's primary (first) strength element
  let plagueDoctorImmuneElement = null;
  if(S.chapterBoss && S.chapterBoss.id === 'plague_doctor' && !bossDisabledEarly){
    // Pick hero's first strength element (primary)
    if(h.str && h.str.length > 0){
      plagueDoctorImmuneElement = h.str[0];
    }
  }

  // Track which resistance Irony has flipped (only affects ONE resistance)
  let ironyFlippedElement = null;

  // Check for opposing elements for Oxy (opposing pairs deal 0)
  const bossAbilityDisabled = S.tempEffects && S.tempEffects.disableBossAbility;
  const hasOpposingElements = S.chapterBoss && S.chapterBoss.id === 'oxy' && !bossAbilityDisabled;
  const weaponElements = new Set(allWords.filter(w => w.elem !== undefined).map(w => w.elem));
  const opposingPairsInWeapon = [];
  if(hasOpposingElements){
    weaponElements.forEach(elem => {
      const opposite = OPPOSITE_ELEMENTS[elem];
      if(opposite !== undefined && weaponElements.has(opposite)){
        opposingPairsInWeapon.push([elem, opposite]);
      }
    });
  }

  // Precompute chapter + structures for per-word W talents
  const chapter = Math.floor((S.roundIndex - 1) / 9) + 1;
  const elementCounts = new Map();
  allWords.forEach(w => {
    if (w && w.elem !== undefined) {
      elementCounts.set(w.elem, (elementCounts.get(w.elem) || 0) + 1);
    }
  });
  const duplicateElements = new Set(Array.from(elementCounts.entries()).filter(([_, c]) => c > 1).map(([e]) => e));
  const nonStickWords = allWords.filter(w => w && !w.isStick);
  const isAllSameTier = nonStickWords.length > 0 && nonStickWords.every(w => w.rarity === nonStickWords[0].rarity);
  const adjFilled = ['adj1','adj2','adj3','adj4'].filter(k => S.sel[k]).length;
  const hasTwoAdj = adjFilled >= 2;
  const hasManyElements = allWords.filter(w => w && w.elem !== undefined).length >= 2;
  const firstLetterConsec = new Set();
  for (let i = 1; i < allWords.length; i++) {
    const prev = allWords[i - 1];
    const curr = allWords[i];
    if (!prev || !curr) continue;
    const a = (prev.name || '').charAt(0).toLowerCase();
    const b = (curr.name || '').charAt(0).toLowerCase();
    if (a && a === b) {
      firstLetterConsec.add(prev);
      firstLetterConsec.add(curr);
    }
  }

  // Helper: per-word W talent bonuses (returns array of {amt,label})
  function computeWordCountBonuses(word, slotKey) {
    if (!word) return [];
    const bonuses = [];
    const add = (amt, label, talentId) => {
      const level = talentId ? getTalentLevel(talentId) : 1;
      const scaledAmt = amt * level;
      const levelSuffix = level > 1 ? ` Lv.${level}` : '';
      if (scaledAmt > 0) bonuses.push({ amt: scaledAmt, label: label + levelSuffix });
    };

    // Family-based element talents
    if (word.elem !== undefined) {
      if (S.talents.includes('world_sky_focus') && isWorldSky(word.elem)) add(chapterScaleW(5, chapter), 'World & Sky Focus', 'world_sky_focus');
      if (S.talents.includes('body_soul_focus') && isBodySoul(word.elem)) add(chapterScaleW(5, chapter), 'Body & Soul Focus', 'body_soul_focus');
    }

    // Proficiency Focus (weapon slot only)
    if (slotKey === 'item' && word.category) {
      if (S.talents.includes('proficiency_focus') && S.hero && word.category === S.hero.good) add(chapterScaleW(8, chapter), 'Proficiency Focus', 'proficiency_focus');
    }

    // Structural / composition
    if (hasTwoAdj && slotKey.startsWith('adj') && S.talents.includes('hendiadys')) add(chapterScaleW(6, chapter), 'Hendiadys', 'hendiadys');
    if (isAllSameTier && S.talents.includes('isocolon')) add(chapterScaleW(10, chapter), 'Isocolon', 'isocolon');
    if (word.elem !== undefined && S.enemy && S.enemy.weak && S.enemy.weak.includes(word.elem) && S.talents.includes('weakness_exploit')) {
      add(chapterScaleW(6, chapter), 'Weakness Exploit', 'weakness_exploit');
    }

    return bonuses;
  }

  // We'll iterate over the fixed slot order to properly apply gem bonuses. This ensures
  // that nouns placed in the gem slot contribute extra AP.
  // Use effectiveSel to respect boss mechanics (blocked/ignored slots)
  const slotKeys = ['item','adj1','adj2','adj3','adj4','noun1'];
  slotKeys.forEach((slotKey) => {
    const word = effectiveSel[slotKey];
    if(!word) return;
    if(word.isStick){
      weaponWord = word;
      return;
    }
    // Determine tier value with possible temporary boost (Sharpening Stone) based on
    // position in allWords array. To ensure deterministic boost assignment, map
    // slotKey to an index into the allWords list that matches the previous
    // implementation order. We'll find the index of this word in allWords.
    let idx = allWords.indexOf(word);

    // Use the centralized getWordAP() function to get base AP + chapter bonus + per-word talents
    // This ensures tooltips and damage calculations use the same AP values
    let tierValue = getWordAP(word, ctx, slotKey);

    // Add breakdown entries for per-word talents applied via getWordAP()
    if(wantBreakdown){
      const round = S.roundIndex || 1;
      if(hasTalent('arsenal_mastery') && word.type === 'weapon'){
        const arsenalBonus = 3 * round;
        breakdown.words.push(`${fmtMod(arsenalBonus, 'ap', ' AP')} Arsenal Mastery (${word.name})`);
      }
    }

    // Apply a temporary tier boost (Sharpening Stone) if flagged for this index
    if(idx >= 0 && tempTierBoost[idx]) tierValue = Math.min(3, tierValue + 1);

    // [T2] Pyromancer: fire words count as one tier higher (cap at 3 AP)
    if(hasTalent('pyromancer') && word.elem === E.FIRE){
      tierValue = Math.min(3, tierValue + 1);
      if(wantBreakdown) breakdown.words.push(`${fmtMod(1, 'ap', ' AP')} Pyromancer (${word.name})`);
    }

    // [Joker] Scribe's Sigil: every word gains +1 base AP.  This applies before any
    // elemental or gem multipliers.  The effect stacks with other tier boosts.
    if(hasTalent('scribe_sigil')){
      tierValue += 1;
      if(wantBreakdown) breakdown.words.push(`${fmtMod(1, 'ap', ' AP')} Scribe's Sigil (${word.name})`);
    }

    // Initialize word count contributions before modifiers (gem/proficiency/talents)
    let wCountDelta    = 1;  // Each word contributes exactly 1 to word count
    let wCountBonus    = 0;  // Per-word word-count bonuses (Meticulous, etc.)

    // Signature Style: if this is a proficient weapon, treat it as having BOTH hero strength elements
    // Also grants +1W bonus since it's effectively two elements in one
    let effectiveElem = word.elem;
    let signatureStyleElements = []; // Array for dual elements
    if(hasTalent('signature_style') && slotKey === 'item' && !word.isStick && word.category === h.good && effectiveElem === undefined){
      signatureStyleElements = [...h.str]; // Copy both hero strength elements
      effectiveElem = h.str[0]; // Primary element for backwards compat
      // +1W bonus for dual elements (2W total)
      wCountDelta += 1;
      if(wantBreakdown && signatureStyleElements.length > 0){
        const elemNames = signatureStyleElements.map(e => EN[e]).join(' + ');
        breakdown.words.push(`Signature Style: ${word.name} gains ${elemNames}`);
        breakdown.multipliers.push(`${fmtMod(1, 'word', ' W')} Signature Style (dual elements)`);
      }
    }

    // Weapon proficiency now affects Word Count instead of AP
    if(slotKey === 'item' && !word.isStick && word.category){
      if(hasWeaponMaster){
        const wmMult = S.tempEffects.weaponMaster || 2;
        wCountDelta = parseFloat((wCountDelta * wmMult).toFixed(2));
        if(wantBreakdown) breakdown.multipliers.push(`${fmtMod(wmMult,'scale')} Weapon Master W (${word.name})`);
      } else if(h.good === word.category){
        wCountDelta = parseFloat((wCountDelta * 2.0).toFixed(2));
        if(wantBreakdown) breakdown.multipliers.push(`${fmtMod(2.0,'scale')} Proficiency W (${word.name})`);
      } else if(h.bad === word.category){
        if(hasTalent('overcoming')){
          const overcomingMult = scaleTalentMult('overcoming', 1.5);
          wCountDelta = parseFloat((wCountDelta * overcomingMult).toFixed(2));
          if(wantBreakdown) breakdown.multipliers.push(`${fmtMod(overcomingMult,'scale')} Overcoming W (${word.name})`);
        } else {
          wCountDelta = parseFloat((wCountDelta * 0.5).toFixed(2));
          if(wantBreakdown) breakdown.multipliers.push(`${fmtMod(0.5,'scale', ' W')} Poor Proficiency (${word.name})`);
        }
      }
    }

    // Determine how this word contributes to base AP and the effective word count.
    // Elemental interactions combine both hero and enemy affinities:
    //  - Strong vs weak: 3√ó
    //  - Strong vs neutral: 1.5√ó
    //  - Strong vs strong: 1√ó
    //  - Neutral vs weak: 2√ó
    //  - Neutral vs neutral: 1√ó
    //  - Neutral vs strong: 0.5√ó
    //  - Weak vs weak: 1√ó
    //  - Weak vs neutral/strong: 0√ó
    let elemMult = 1;
    let ironyFlipped = false;
    let oxyNullified = false;
    let plagiarizedResist = false;

    // Alexandria - Trinity Capstone: Fire/Light are interchangeable
    const hasTrinity = hasCapstone('Alexandria Constanza') && h.name === 'Alexandria Constanza';

    // Helper function to calculate element multiplier for a given element
    function calcElemMult(elem, wordName, isSecondary = false){
      let mult = 1;
      let flipped = false;
      let plagiarized = false;
      let trinityUsed = false;

      // Oxy: Opposing elements deal 0 damage
      if(hasOpposingElements && opposingPairsInWeapon.length > 0){
        const isOpposed = opposingPairsInWeapon.some(pair => pair.includes(elem));
        if(isOpposed){
          if(wantBreakdown && !isSecondary) breakdown.words.push(`Oxy: ${EN[elem]} nullified by contradiction! (${wordName})`);
          return { mult: 0, nullified: true, flipped: false, plagiarized: false };
        }
      }

      // Trinity: Fire/Light are interchangeable - use whichever is better
      let effectiveElemForCalc = elem;
      if(hasTrinity && (elem === E.FIRE || elem === E.LIGHT)){
        const otherElem = elem === E.FIRE ? E.LIGHT : E.FIRE;
        // Check which element would give better results against this enemy
        const currentWeakness = e.weak && e.weak.includes(elem);
        const otherWeakness = e.weak && e.weak.includes(otherElem);
        const currentResist = resists(elem);
        const otherResist = resists(otherElem);
        // If other element hits weakness and current doesn't, or current resists and other doesn't, swap
        if((!currentWeakness && otherWeakness) || (currentResist && !otherResist)){
          effectiveElemForCalc = otherElem;
          trinityUsed = true;
        }
      }

      const heroStrong = h.str.includes(effectiveElemForCalc);
      const heroWeak  = h.weak.includes(effectiveElemForCalc);
      const enemyWeak  = e.weak.includes(effectiveElemForCalc);
      let enemyStrong = resists(effectiveElemForCalc);

      // Plague Doctor: immune to hero's primary strength element (√ó0 damage)
      if(plagueDoctorImmuneElement === elem){
        plagiarized = true;
        // Immediate √ó0 - this element does nothing
        return { mult: 0, nullified: true, flipped: false, plagiarized: true, elem };
      }

      const heroAffinity = heroStrong ? 'strong' : heroWeak ? 'weak' : 'neutral';
      let enemyAffinity = enemyWeak ? 'weak' : enemyStrong ? 'strong' : 'neutral';

      // Irony: ONE enemy resistance becomes weakness (first one encountered)
      if(hasTalent('irony') && enemyAffinity === 'strong'){
        // Only flip if this is the element we already flipped, or we haven't flipped any yet
        if(ironyFlippedElement === null || ironyFlippedElement === elem){
          ironyFlippedElement = elem;
          enemyAffinity = 'weak';
          flipped = true;
        }
      }

      const elemMatrix = {
        strong:  { weak: 3.0,   neutral: 1.5, strong: 1.0 },
        neutral: { weak: 2.0,   neutral: 1.0, strong: 0.5 },
        weak:    { weak: 1.5,   neutral: 0.5, strong: 0.0 }
      };
      mult = elemMatrix[heroAffinity][enemyAffinity];

      return { mult, nullified: false, flipped, plagiarized, elem, trinityUsed, effectiveElem: effectiveElemForCalc };
    }

    // Signature Style: process BOTH hero strength elements for this weapon
    if(signatureStyleElements.length > 1){
      let totalMult = 0;
      for(const elem of signatureStyleElements){
        const result = calcElemMult(elem, word.name, false);
        totalMult += result.mult;
        if(result.flipped) ironyFlipped = true;
        if(result.plagiarized) plagiarizedResist = true;
        if(result.nullified) oxyNullified = true;
        if(wantBreakdown && result.mult > 0){
          // Element matrix affects AP only
          breakdown.words.push(`${EN[elem]}: <span class="mod-badge add">√ó${result.mult.toFixed(1)} AP</span> (${word.name})`);
        }
      }
      elemMult = totalMult;
    } else if(effectiveElem !== undefined){
      const result = calcElemMult(effectiveElem, word.name);
      elemMult = result.mult;
      ironyFlipped = result.flipped;
      plagiarizedResist = result.plagiarized;
      oxyNullified = result.nullified;

      if(wantBreakdown && result.trinityUsed){
        breakdown.words.push(`Trinity: ${EN[effectiveElem]} ‚Üí ${EN[result.effectiveElem]} (${word.name})`);
      }
      if(wantBreakdown && ironyFlipped){
        breakdown.words.push(`Irony: ${EN[effectiveElem]} resist ‚Üí weak! (${word.name})`);
      }
      if(wantBreakdown && plagiarizedResist && !ironyFlipped){
        breakdown.words.push(`Plagiarized: ${EN[effectiveElem]} (your Strength) resisted! (${word.name})`);
      }
    }

    // Base AP contribution is the tier value times the element multiplier.
    // Element matrix affects AP only. Word count is structural (1 per word).
    // This prevents "double-dipping" where elemMult would otherwise apply to both
    // AP and word count, causing a 1.5√ó stalemate to feel like ~2.25√ó.
    let apContribution = tierValue * elemMult;

    // Silent Knight: Immune to words with fewer than 6 letters
    let silentKnightImmune = false;
    if (S.enemy && S.enemy.id === 'silent_knight') {
      const wordName = word.name || '';
      if (wordName.length < 6) {
        apContribution = 0;
        silentKnightImmune = true;
      }
    }

    wordBaseAPTotal += apContribution;

    // Apply WORD_COUNT modifiers (e.g., Assassin's Meticulous passive)
    const wordCountCtx = {
      hero: h,
      word,
      slotKey,
      wCountDelta,
      breakdown,
      state: S
    };
    const wordCountResults = applyModifiers('WORD_COUNT', wordCountCtx);
    wordCountResults.forEach(result => {
      if(result && result.wordCountBonus){
        wCountBonus += result.wordCountBonus;
        // Add to breakdown for passive abilities like Meticulous (as +W bonus with badge)
        if(wantBreakdown){
          breakdown.multipliers.push(`${fmtMod(result.wordCountBonus, 'word', ' W')} ${word.name} (Meticulous)`);
        }
      }
    });

    // Apply per-word W talents (these add to base before gem multiplier)
    const perWordBonuses = computeWordCountBonuses(word, slotKey);
    perWordBonuses.forEach(b => {
      wCountBonus += b.amt;
      if(wantBreakdown){
        breakdown.multipliers.push(`${fmtMod(b.amt, 'word', ' W')} ${b.label}`);
      }
    });

    // Calculate total W before gem multiplier: base (with proficiency) + talent bonuses
    let totalWBeforeGem = wCountDelta + wCountBonus;

    // Gem slot multiplies TOTAL Word Count (√ó4 with Crown Jewel talent)
    // Applied AFTER all talent bonuses
    if(slotKey === 'noun1'){
      const hasCrownJewel = S.talents && S.talents.includes('crown_jewel');
      const gemMult = hasCrownJewel ? 4 : 2;
      const wBeforeGem = totalWBeforeGem;
      totalWBeforeGem *= gemMult;
      wCountDelta *= gemMult; // Scale base for tracking
      wCountBonus *= gemMult; // Scale bonuses for tracking
      const gemLabel = hasCrownJewel ? `${word.name} Gem (Kohinoor)` : `${word.name} Gem`;
      if(wantBreakdown) breakdown.multipliers.push(`${fmtMod(gemMult,'scale')} ${gemLabel} (${wBeforeGem}W √ó ${gemMult})`);
    }

    // Add final word count contribution
    wordCount += totalWBeforeGem;

    if(wantBreakdown){
      if(silentKnightImmune){
        // Silent Knight immunity: show 0 AP with immunity message
        breakdown.base.push(`<span style="color:#ef4444">0 AP</span> ${word.name} (Wordless: <6 letters)`);
      } else {
        // Build badge-style labels for element and weapon type
        const badges = [];
        if(word.elem !== undefined) {
          const elemColor = EC[word.elem];
          badges.push(`<span class="tag" style="color:${elemColor};border-color:${elemColor}55;font-size:9px;padding:1px 5px">${EN[word.elem]}</span>`);
        }
        if(slotKey === 'noun1') {
          badges.push(`<span class="tag" style="color:#fbbf24;border-color:#fbbf2455;font-size:9px;padding:1px 5px">Gem</span>`);
        }
        if(word.category) {
          // Weapon type badge (Slash, Pierce, Blunt, Magic) - use proficiency blue
          const catName = word.category.charAt(0).toUpperCase() + word.category.slice(1);
          badges.push(`<span class="tag prof" style="font-size:9px;padding:1px 5px">${catName}</span>`);
        }
        const suffix = badges.length ? ' ' + badges.join(' ') : '';
        breakdown.base.push(`+${fmtNum(apContribution)} ${word.name}${suffix}`);
      }
    }

    // Track weapon for proficiency display
    if(slotKey === 'item'){
      weaponWord = word;
    }

    // Store word data for retrigger talents (including mult for adjectives)
    const wCountTotal = wCountDelta + wCountBonus;

    wordDataMap.set(word, {
      apContribution,
      wCountDelta,
      wCountBonus,
      wCountTotal,
      slotKey,
      elemMult, // Store element effectiveness for Magatsu talent
      mult: (word.mult !== undefined && slotKey !== 'noun1') ? word.mult : null,
      talentMults: [], // Will be populated with per-word talent multipliers
      wTalentBonus: 0  // +W bonuses from talents (attributed to this word, REREADs with it)
    });
  });

  // Check for dual element synergy talents and add per-word multipliers (consolidated to 6)
  const dualElementTalents = [
    { id: 'magma_core', elements: [E.FIRE, E.EARTH], mult: 2, name: 'Magma Core' },
    { id: 'tempest', elements: [E.LIGHTNING, E.WATER], mult: 2, name: 'Tempest' },
    { id: 'eclipse', elements: [E.LIGHT, E.DARK], mult: 2.5, name: 'Umbral Dawn' },
    { id: 'necrotoxin', elements: [E.DARK, E.POISON], mult: 2, name: 'Thanatos' },
    { id: 'blessed_steel', elements: [E.LIGHT, E.PHYS], mult: 2, name: 'Helios' },
    { id: 'static_earth', elements: [E.LIGHTNING, E.EARTH], mult: 2, name: 'Gaia' },
  ];

  dualElementTalents.forEach(talent => {
    if (hasTalent(talent.id) && hasElements(allWords, talent.elements)) {
      // Only add multiplier to FIRST matching word (flat √ó2, not per-word)
      const firstMatch = allWords.find(word => talent.elements.includes(word.elem));
      if (firstMatch) {
        const wordData = wordDataMap.get(firstMatch);
        if (wordData) {
          // Scale multiplier with talent level
          const level = getTalentLevel(talent.id);
          const scaledMult = scaleTalentMult(talent.id, talent.mult);
          const levelSuffix = level > 1 ? ` Lv.${level}` : '';
          wordData.talentMults.push({ name: talent.name + levelSuffix, mult: scaledMult });
        }
      }
    }
  });

  // Reed - One With Nature Capstone: Earth words buff Water +50%, vice versa
  if(hasCapstone('Reed') && h.name === 'Reed'){
    const hasEarth = allWords.some(w => w.elem === E.EARTH);
    const hasWater = allWords.some(w => w.elem === E.WATER);
    if(hasEarth && hasWater){
      // Apply +50% to all Earth and Water words
      allWords.forEach(word => {
        if(word.elem === E.EARTH || word.elem === E.WATER){
          const wordData = wordDataMap.get(word);
          if(wordData){
            wordData.talentMults.push({ name: 'One With Nature', mult: 1.5 });
            if(wantBreakdown) breakdown.multipliers.push(`${fmtMod(1.5,'scale')} ${word.name} (One With Nature)`);
          }
        }
      });
    }
  }

  // Global flat AP bonuses (prolix, terse, battle_hardened, word_hoarder, descriptive)
  // are added directly to the total. Per-word bonuses are already included in getWordAP()
  // so they're already part of wordBaseAPTotal.
  let baseAP = flatAPBonus + wordBaseAPTotal;

  // ========================================
  // PHASE 2: WORD COUNT BONUSES (+W Talents)
  // ========================================
  // +W bonuses are attributed to specific words so they REREAD with those words.
  // This runs BEFORE Phase 4 (REREAD) so bonuses are picked up during REREADs.

  let totalWBonuses = 0; // Track total +W for Residual talent

  // Helper: Add +W bonus to a specific word (attributed, will REREAD with word)
  const addWBonusToWord = (word, bonus, talentName) => {
    const wordData = wordDataMap.get(word);
    if (wordData && bonus > 0) {
      wordData.wTalentBonus += bonus;
      wordCount += bonus;
      totalWBonuses += bonus;
      if (wantBreakdown) {
        breakdown.multipliers.push(`${fmtMod(bonus, 'word', ' W')} ${talentName} ‚Üí ${word.name}`);
      }
    }
  };

  // Helper: Distribute +W bonus equally across all words
  const distributeWBonusToAll = (totalBonus, talentName) => {
    if (totalBonus <= 0 || allWords.length === 0) return;
    const bonusPerWord = totalBonus / allWords.length;
    allWords.forEach(word => {
      const wordData = wordDataMap.get(word);
      if (wordData) {
        wordData.wTalentBonus += bonusPerWord;
      }
    });
    wordCount += totalBonus;
    totalWBonuses += totalBonus;
    if (wantBreakdown) {
      breakdown.multipliers.push(`${fmtMod(totalBonus, 'word', ' W')} ${talentName} (√∑${allWords.length} words)`);
    }
  };

  // Helper: Add +W bonus to words matching a condition
  const addWBonusToMatching = (condition, bonusPerWord, talentName) => {
    allWords.forEach(word => {
      if (condition(word)) {
        addWBonusToWord(word, bonusPerWord, talentName);
      }
    });
  };

  // Helper: Add +W to weapon slot only (no fallback if empty)
  const addWBonusToWeapon = (bonus, talentName) => {
    if (s.item) addWBonusToWord(s.item, bonus, talentName);
  };

  // Helper: Add +W to ALL adjectives - each gets FULL bonus (no fallback if no adjectives)
  // Consolidates breakdown to single entry for performance
  const addWBonusToAllAdjectives = (bonus, talentName) => {
    const adjWords = ['adj1', 'adj2', 'adj3', 'adj4'].map(k => s[k]).filter(Boolean);
    if (adjWords.length === 0) return;

    // Apply bonus to each adjective's wordData (for REREAD tracking)
    adjWords.forEach(word => {
      const wordData = wordDataMap.get(word);
      if (wordData && bonus > 0) {
        wordData.wTalentBonus += bonus;
        wordCount += bonus;
        totalWBonuses += bonus;
      }
    });

    // Single consolidated breakdown entry instead of one per adjective
    if (wantBreakdown && bonus > 0) {
      const totalBonus = bonus * adjWords.length;
      breakdown.multipliers.push(`${fmtMod(totalBonus, 'word', ' W')} ${talentName} (${adjWords.length} Adjs √ó ${bonus})`);
    }
  };

  // Helper: Add +W to last word (gem if present, else weapon; no fallback if both empty)
  const addWBonusToLastWord = (bonus, talentName) => {
    const lastWord = s.noun1 || s.item;
    if (lastWord) addWBonusToWord(lastWord, bonus, talentName);
  };

  // Helper: Add +W split among all adjectives (no fallback if no adjectives)
  const addWBonusToAdjectives = (totalBonus, talentName) => {
    const adjWords = ['adj1', 'adj2', 'adj3', 'adj4'].map(k => s[k]).filter(Boolean);
    if (adjWords.length === 0) return;
    const bonusPerAdj = totalBonus / adjWords.length;
    adjWords.forEach(word => addWBonusToWord(word, bonusPerAdj, talentName));
  };

  // --- PER-WORD +W TALENTS (attributed to qualifying words) ---

  // Momentum: +1 W per Word per round played (max 10) - each word gets the bonus
  if (hasTalent('momentum')) {
    const roundsPlayed = Math.min((S.roundIndex || 1) - 1, 10);
    const basePerWordPerRound = scaleTalentBonus('momentum', 1);
    const bonusPerWord = roundsPlayed * basePerWordPerRound;
    if (bonusPerWord > 0) {
      allWords.forEach(word => addWBonusToWord(word, bonusPerWord, `Momentum (R${roundsPlayed})`));
    }
  }

  // Lexicon Growth: +1 W per Word per Boss defeated - each word gets the bonus
  if (hasTalent('lexicon_growth')) {
    const bossesDefeated = S.bossesDefeated || 0;
    const basePerWordPerBoss = scaleTalentBonus('lexicon_growth', 1);
    const bonusPerWord = bossesDefeated * basePerWordPerBoss;
    if (bonusPerWord > 0) {
      allWords.forEach(word => addWBonusToWord(word, bonusPerWord, `Lexicon (${bossesDefeated}B)`));
    }
  }

  // Stony Brook: Water + Earth ‚Üí +12 W (split between matching elements)
  if (hasTalent('stony_brook') && hasElements(allWords, [E.WATER, E.EARTH])) {
    const bonus = scaleTalentBonus('stony_brook', 12);
    const matchingWords = allWords.filter(w => w.elem === E.WATER || w.elem === E.EARTH);
    const bonusPerWord = bonus / matchingWords.length;
    matchingWords.forEach(word => addWBonusToWord(word, bonusPerWord, 'Stony Brook'));
  }

  // Inferno: Fire + Water ‚Üí +10 W (split between matching elements)
  if (hasTalent('inferno') && hasElements(allWords, [E.FIRE, E.WATER])) {
    const bonus = scaleTalentBonus('inferno', 10);
    const matchingWords = allWords.filter(w => w.elem === E.FIRE || w.elem === E.WATER);
    const bonusPerWord = bonus / matchingWords.length;
    matchingWords.forEach(word => addWBonusToWord(word, bonusPerWord, 'Inferno'));
  }

  // Verdant: Earth + Light ‚Üí +10 W (split between matching elements)
  if (hasTalent('verdant') && hasElements(allWords, [E.EARTH, E.LIGHT])) {
    const bonus = scaleTalentBonus('verdant', 10);
    const matchingWords = allWords.filter(w => w.elem === E.EARTH || w.elem === E.LIGHT);
    const bonusPerWord = bonus / matchingWords.length;
    matchingWords.forEach(word => addWBonusToWord(word, bonusPerWord, 'Verdant'));
  }

  // Venom Strike: Poison + Lightning ‚Üí +10 W (split between matching elements)
  if (hasTalent('venom_strike') && hasElements(allWords, [E.POISON, E.LIGHTNING])) {
    const bonus = scaleTalentBonus('venom_strike', 10);
    const matchingWords = allWords.filter(w => w.elem === E.POISON || w.elem === E.LIGHTNING);
    const bonusPerWord = bonus / matchingWords.length;
    matchingWords.forEach(word => addWBonusToWord(word, bonusPerWord, 'Venom Strike'));
  }

  // Twilight: Dark + Physical ‚Üí +10 W (split between matching elements)
  if (hasTalent('twilight') && hasElements(allWords, [E.DARK, E.PHYS])) {
    const bonus = scaleTalentBonus('twilight', 10);
    const matchingWords = allWords.filter(w => w.elem === E.DARK || w.elem === E.PHYS);
    const bonusPerWord = bonus / matchingWords.length;
    matchingWords.forEach(word => addWBonusToWord(word, bonusPerWord, 'Twilight'));
  }

  // Spectrum: +2 W per unique Element (given to elemental words)
  if (hasTalent('spectrum')) {
    const elementalWords = allWords.filter(w => w.elem !== undefined);
    const uniqueElements = new Set(elementalWords.map(w => w.elem));
    const basePerElement = scaleTalentBonus('spectrum', 2);
    const totalBonus = uniqueElements.size * basePerElement;
    if (totalBonus > 0 && elementalWords.length > 0) {
      const bonusPerWord = totalBonus / elementalWords.length;
      elementalWords.forEach(word => addWBonusToWord(word, bonusPerWord, `Spectrum (${uniqueElements.size}E)`));
    }
  }

  // Comfort Zone: Only 1 Element type ‚Üí +6 W (to elemental words)
  if (hasTalent('comfort_zone')) {
    const elementalWords = allWords.filter(w => w.elem !== undefined);
    const uniqueElements = new Set(elementalWords.map(w => w.elem));
    if (uniqueElements.size === 1 && elementalWords.length > 0) {
      const bonus = scaleTalentBonus('comfort_zone', 6);
      const bonusPerWord = bonus / elementalWords.length;
      elementalWords.forEach(word => addWBonusToWord(word, bonusPerWord, 'Comfort Zone'));
    }
  }

  // Elemental Mastery & Weakness Exploit Amp: Apply accumulated elemental W bonus (to elemental words)
  if ((hasTalent('elemental_mastery') || hasTalent('weakness_exploit_amp')) && S.elementalWBonus > 0) {
    const elementalWords = allWords.filter(w => w.elem !== undefined);
    if (elementalWords.length > 0) {
      const bonusPerWord = S.elementalWBonus / elementalWords.length;
      elementalWords.forEach(word => addWBonusToWord(word, bonusPerWord, 'Elemental W'));
    }
  }

  // --- SLOT-SPECIFIC +W TALENTS (intentional word attachment for REREAD synergy) ---

  // Golden Tongue: 1st Adj: +1 W per 20 Gold held
  if (hasTalent('golden_tongue')) {
    const basePerStack = scaleTalentBonus('golden_tongue', 1);
    const bonus = Math.floor((S.gold || 0) / 20) * basePerStack;
    if (bonus > 0) {
      addWBonusToAllAdjectives(bonus, `Golden Tongue (${S.gold}g)`);
    }
  }

  // Word Hoard: Each Adj: +0.2 W per inventory word
  if (hasTalent('word_hoard')) {
    const invCount = (S.inv || []).filter(w => !w.hiddenInBank).length;
    const basePerWord = scaleTalentBonus('word_hoard', 0.2);
    const bonus = Math.floor(invCount * basePerWord);
    if (bonus > 0) {
      addWBonusToAdjectives(bonus, `Word Hoard (${invCount})`);
    }
  }

  // Slow Burn: Weapon: +2 W per round
  if (hasTalent('slow_burn')) {
    const roundNum = (S.roundIndex || 1);
    const basePerRound = scaleTalentBonus('slow_burn', 2);
    const bonus = roundNum * basePerRound;
    addWBonusToWeapon(bonus, `Slow Burn (R${roundNum})`);
  }

  // Tithe: 1st Adj: +2 W per 20 Gold spent
  if (hasTalent('tithe')) {
    const goldSpent = S.goldSpent || 0;
    const stacks = Math.floor(goldSpent / 20);
    if (stacks > 0) {
      const basePerStack = scaleTalentBonus('tithe', 2);
      const bonus = stacks * basePerStack;
      addWBonusToAllAdjectives(bonus, `Tithe (${goldSpent}g spent)`);
    }
  }

  // Word Historian: Last Word: +0.25 W per word used this run
  if (hasTalent('word_historian')) {
    const wordsUsed = S.wordsUsedThisRun || 0;
    if (wordsUsed > 0) {
      const basePerWord = scaleTalentBonus('word_historian', 0.25);
      const bonus = Math.floor(wordsUsed * basePerWord);
      if (bonus > 0) {
        addWBonusToLastWord(bonus, `Word Historian (${wordsUsed})`);
      }
    }
  }

  // Reverberation: 1st Adj: +2 W per REREAD this run
  if (hasTalent('reverberation')) {
    const rereadsTriggered = S.rereadTriggersThisRun || 0;
    if (rereadsTriggered > 0) {
      const basePerReread = scaleTalentBonus('reverberation', 2);
      const bonus = rereadsTriggered * basePerReread;
      addWBonusToAllAdjectives(bonus, `Reverberation (${rereadsTriggered})`);
    }
  }

  // Verbose Surplus: Each Adj: +10 W √ó word count
  if (hasTalent('verbose_surplus')) {
    const wc = allWords.length;
    const basePerWord = scaleTalentBonus('verbose_surplus', 10);
    const bonus = wc * wc * basePerWord;
    if (bonus > 0) {
      addWBonusToAdjectives(bonus, `Verbose (${wc}√ó${wc})`);
    }
  }

  // Linguistic Density: 4+ words ‚Üí each word gets +5 W √ó word count
  if (hasTalent('linguistic_density')) {
    const wc = allWords.length;
    if (wc >= 4) {
      const basePerWord = scaleTalentBonus('linguistic_density', 5);
      const bonus = wc * wc * basePerWord;
      distributeWBonusToAll(bonus, `Ling Density (${wc}√ó${wc})`);
    }
  }

  // Steady Hand: Weapon: +3 W
  if (hasTalent('steady_hand')) {
    const bonus = scaleTalentBonus('steady_hand', 3);
    addWBonusToWeapon(bonus, 'Steady Hand');
  }

  // First Blood: Ch.1 - Weapon: +10 W
  if (hasTalent('first_blood')) {
    const roundNum = S.roundIndex || 1;
    if (roundNum <= 9) {
      const bonus = scaleTalentBonus('first_blood', 10);
      addWBonusToWeapon(bonus, 'First Blood');
    }
  }

  // Linguist: 3+ Types ‚Üí each word gets +5 W
  if (hasTalent('linguist')) {
    const wordTypes = new Set(allWords.map(w => w.type));
    if (wordTypes.size >= 3) {
      const bonus = scaleTalentBonus('linguist', 5);
      distributeWBonusToAll(bonus, `Linguist (${wordTypes.size})`);
    }
  }

  // Condensed: ‚â§3 Words ‚Üí each word gets +8 W
  if (hasTalent('condensed')) {
    if (allWords.length <= 3) {
      const bonus = scaleTalentBonus('condensed', 8);
      distributeWBonusToAll(bonus, `Condensed (${allWords.length})`);
    }
  }

  // ========================================
  // PHASE 3: MULTIPLICATIVE BONUSES (√óMult Talents)
  // ========================================
  let multiplicativeMult = 1.0;

  // Stick penalty: 0.5√ó total damage as punishment for not having a real weapon
  if (s.item && s.item.isStick) {
    multiplicativeMult *= 0.5;
    if (wantBreakdown) breakdown.multipliers.push(`${fmtMod(0.5,'scale')} Stick (no weapon)`);
  }

  // Apply word multipliers (word.mult property, not in noun slot)
  allWords.forEach(word => {
    if(word.mult !== undefined && word !== S.sel.noun1){
      multiplicativeMult *= word.mult;
      if(wantBreakdown){
        breakdown.multipliers.push(`${fmtMod(word.mult,'scale')} ${word.name}`);
      }
    }
  });

  // Apply all multiplier category talents via modular system
  // Includes 'threshold' talents that return multipliers (Berserker, Fortuna, First Blood, etc.)
  // Sort by multiplier value ascending so biggest multiplier applies last (better precision)
  const multTalents = S.talents
    .map(tid => TALENTS.find(t => t.id === tid))
    .filter(talent => talent && (talent.category === 'multiplier' || talent.category === 'multiplicative_mult' || talent.category === 'threshold'))
    .map(talent => ({ talent, mult: talent.apply(ctx) }))
    .filter(({ mult }) => mult > 1.0)
    .sort((a, b) => a.mult - b.mult); // Smallest first, biggest last

  multTalents.forEach(({ talent, mult }) => {
    multiplicativeMult *= mult;
    if (wantBreakdown) {
      breakdown.multipliers.push(`${fmtMod(mult,'scale')} ${talent.name}`);
    }
  });

  // Legacy talents - all scale with level
  if(hasTalent('dual_spec')){
    const elems = new Set(allWords.filter(w=>w.elem!==undefined).map(w=>w.elem));
    if(elems.size >= 2){
      const dualSpecMult = scaleTalentMult('dual_spec', 2.0);
      multiplicativeMult *= dualSpecMult;
      if(wantBreakdown) breakdown.multipliers.push(`${fmtMod(dualSpecMult,'scale')} Dual Spec`);
    }
  }

  if(hasTalent('min_max')){
    const hasT2 = allWords.some(w=>!w.isStick && w.rarity===2);
    if(!hasT2 && allWords.length > 0){
      const minMaxMult = scaleTalentMult('min_max', 1.75);
      multiplicativeMult *= minMaxMult;
      if(wantBreakdown) breakdown.multipliers.push(`${fmtMod(minMaxMult,'scale')} Min‚ÄëMax`);
    }
  }

  if(hasTalent('wordsmiths_fervor')){
    const basePerWord = scaleTalentBonus('wordsmiths_fervor', 0.1);
    const fervorMult = (1 + basePerWord * wordCount);
    multiplicativeMult *= fervorMult;
    if(wantBreakdown) breakdown.multipliers.push(`${fmtMod(fervorMult,'scale')} Wordsmith's Fervor`);
  }

  // ========================================
  // PHASE 4: RETRIGGER TALENTS
  // ========================================
  // Retriggers add the word's contribution a second time to baseAP and wordCount
  // AND re-apply any multipliers (like Legendary's √ó1.5) for maximum double-dipping!

  let retriggerAP = 0;
  let retriggerWordCount = 0;
  let retriggerMult = 1.0; // Accumulate retriggered multipliers
  let retriggerMultAdditive = 0; // Track additive bonus portion for rarity multipliers
  const retriggeredWords = []; // Track for animation purposes

  const getWordCountForReread = (wd) => wd ? ((wd.wCountTotal ?? wd.wCountDelta ?? 0) + (wd.wTalentBonus || 0)) : 0;

  // Helper to apply reread for a word N times (based on talent level)
  const applyReread = (word, wordData, talentId, talentName, rereadCount = 1) => {
    if (!wordData) return;
    for (let i = 0; i < rereadCount; i++) {
      retriggerAP += wordData.apContribution;
      retriggerWordCount += getWordCountForReread(wordData);
      if (wordData.mult) {
        // Additive: add the bonus portion (mult - 1.0) instead of multiplying
        const bonusPortion = wordData.mult - 1.0;
        retriggerMultAdditive += bonusPortion;
      }
      retriggeredWords.push({ word, talent: talentName });
    }
    if (wantBreakdown) {
      const countLabel = rereadCount > 1 ? ` <span class="mod-badge reread">√ó${rereadCount}</span>` : '';
      const wContrib = getWordCountForReread(wordData) * rereadCount;
      breakdown.base.push(`${fmtMod(wordData.apContribution * rereadCount, 'ap', ' AP')} ${fmtMod(wContrib, 'word', ' W')} ${word.name} (${talentName} REREAD${countLabel})`);
      if (wordData.mult) {
        const totalMult = 1 + (wordData.mult - 1) * rereadCount;
        breakdown.multipliers.push(`${fmtMod(totalMult, 'scale')} ${word.name} (${talentName} REREAD${countLabel})`);
      }
    }
  };

  S.talents.forEach(tid => {
    const talent = TALENTS.find(t => t.id === tid);
    if (talent && talent.category === 'retrigger') {
      // Each retrigger talent identifies which words to retrigger and adds their contribution
      // Reread count scales with talent level
      const rereadCount = getTalentLevel(tid);

      // Anaphora: First word triggers twice
      if(talent.id === 'anaphora' && allWords.length > 0){
        const firstWord = allWords[0];
        const wordData = wordDataMap.get(firstWord);
        applyReread(firstWord, wordData, tid, 'Anaphora', rereadCount);
      }

      // Epistrophe: Last word triggers twice
      // "Last word" is the gem if present, otherwise the weapon (which ends the sentence)
      if(talent.id === 'epistrophe' && allWords.length > 0){
        const lastWord = s.noun1 ? s.noun1 : s.item;
        if(lastWord){
          const wordData = wordDataMap.get(lastWord);
          applyReread(lastWord, wordData, tid, 'Epistrophe', rereadCount);
        }
      }

      // Critical Mass: T3 words REREAD
      if(talent.id === 'critical_mass'){
        const t3Words = allWords.filter(w => w.rarity === 3);
        t3Words.forEach(word => {
          const wordData = wordDataMap.get(word);
          applyReread(word, wordData, tid, 'Critical Mass', rereadCount);
        });
      }

      // Rarity Cascade: Rarity words (Common, Rare, Epic, etc.) REREAD
      if(talent.id === 'rarity_cascade'){
        const rarityWords = allWords.filter(w => w.type === 'rarity');
        rarityWords.forEach(word => {
          const wordData = wordDataMap.get(word);
          applyReread(word, wordData, tid, 'Rarity Cascade', rereadCount);
        });
      }

      // Epizeuxis: Repeated words trigger twice
      if(talent.id === 'epizeuxis'){
        const wordIds = allWords.filter(w => w.id).map(w => w.id);
        const duplicates = wordIds.filter((id, idx) => wordIds.indexOf(id) !== idx);
        const uniqueDuplicates = [...new Set(duplicates)];
        uniqueDuplicates.forEach(id => {
          const word = allWords.find(w => w.id === id);
          const wordData = wordDataMap.get(word);
          applyReread(word, wordData, tid, 'Epizeuxis', rereadCount);
        });
      }

      // Diacope: All 4 elements from one family (World & Sky OR Body & Soul) retrigger
      if(talent.id === 'diacope'){
        // World & Sky: Fire, Water, Earth, Lightning
        const worldSkyElems = [E.FIRE, E.WATER, E.EARTH, E.LIGHTNING];
        // Body & Soul: Physical, Poison, Light, Dark
        const bodySoulElems = [E.PHYS, E.POISON, E.LIGHT, E.DARK];

        const worldSkyWords = allWords.filter(w => w.elem !== undefined && worldSkyElems.includes(w.elem));
        const bodySoulWords = allWords.filter(w => w.elem !== undefined && bodySoulElems.includes(w.elem));

        // Check if all 4 unique elements from a family are present
        const worldSkyUniqueElems = new Set(worldSkyWords.map(w => w.elem));
        const bodySoulUniqueElems = new Set(bodySoulWords.map(w => w.elem));

        // Retrigger all words if all 4 elements from family are present
        if(worldSkyUniqueElems.size === 4){
          worldSkyWords.forEach(w => {
            const wordData = wordDataMap.get(w);
            applyReread(w, wordData, tid, 'Diacope', rereadCount);
          });
        }
        if(bodySoulUniqueElems.size === 4){
          bodySoulWords.forEach(w => {
            const wordData = wordDataMap.get(w);
            applyReread(w, wordData, tid, 'Diacope', rereadCount);
          });
        }
      }

      // Gemination: 2+ words same tier, all retrigger
      if(talent.id === 'gemination'){
        // Group active words by their Tier (Rarity Rank)
        const tierGroups = {};
        allWords.forEach(w => {
          const tier = w.rarity !== undefined ? w.rarity : 0;
          if(!tierGroups[tier]) tierGroups[tier] = [];
          tierGroups[tier].push(w);
        });

        // Check groups with 2 or more words
        Object.keys(tierGroups).forEach(tier => {
          const group = tierGroups[tier];
          if(group.length >= 2){
            group.forEach(w => {
              const wordData = wordDataMap.get(w);
              applyReread(w, wordData, tid, 'Gemination', rereadCount);
            });
          }
        });
      }

      // Resonance: Hero strength element triggers twice
      if(talent.id === 'resonance'){
        allWords.forEach((word, idx) => {
          if(word.elem !== undefined && h.str.includes(word.elem)){
            const wordData = wordDataMap.get(word);
            applyReread(word, wordData, tid, 'Resonance', rereadCount);
          }
        });
      }

      // Cascade: Water element triggers twice
      if(talent.id === 'cascade'){
        allWords.forEach(word => {
          if(word.elem === E.WATER){
            const wordData = wordDataMap.get(word);
            applyReread(word, wordData, tid, 'Cascade', rereadCount);
          }
        });
      }

      // Chain Lightning: Lightning element triggers twice
      if(talent.id === 'chain_lightning'){
        allWords.forEach(word => {
          if(word.elem === E.LIGHTNING){
            const wordData = wordDataMap.get(word);
            applyReread(word, wordData, tid, 'Chain Lightning', rereadCount);
          }
        });
      }

      // Combustion: Fire words retrigger against weak enemies
      if(talent.id === 'combustion'){
        allWords.forEach(word => {
          if(word.elem === E.FIRE && e.weak && e.weak.includes(E.FIRE)){
            const wordData = wordDataMap.get(word);
            applyReread(word, wordData, tid, 'Combustion', rereadCount);
          }
        });
      }

      // Magatsu: Ineffective elements (elemMult < 1, including 0.5x and 0x) REREAD √ó2 (base)
      if(talent.id === 'null_and_void'){
        const baseReread = 2; // Base is REREAD √ó2
        const scaledReread = baseReread + (rereadCount - 1); // Additive: +1 per level
        allWords.forEach(word => {
          const wordData = wordDataMap.get(word);
          if(wordData && wordData.elemMult < 1){
            applyReread(word, wordData, tid, 'Magatsu', scaledReread);
          }
        });
      }

      // Amplify: Weapon slot Rereads
      if(talent.id === 'amplify' && s.item){
        const weaponWord = s.item;
        const wordData = wordDataMap.get(weaponWord);
        applyReread(weaponWord, wordData, tid, 'Khopesh', rereadCount);
      }

      // Gem Resonance: Gem slot (noun1) Rereads
      if(talent.id === 'gem_resonance' && s.noun1){
        const gemWord = s.noun1;
        const wordData = wordDataMap.get(gemWord);
        applyReread(gemWord, wordData, tid, 'Gem Resonance', rereadCount);
      }

      // Polysyndeton: 3+ different elements ‚Üí REREAD highest AP word
      if(talent.id === 'polysyndeton'){
        const uniqueElements = new Set(allWords.map(w => w.elem).filter(e => e !== undefined));
        if(uniqueElements.size >= 3){
          let highestAP = 0;
          let highestWord = null;
          allWords.forEach(w => {
            const wd = wordDataMap.get(w);
            if(wd && wd.apContribution > highestAP){
              highestAP = wd.apContribution;
              highestWord = w;
            }
          });
          if(highestWord){
            const wordData = wordDataMap.get(highestWord);
            applyReread(highestWord, wordData, tid, 'Polysyndeton', rereadCount);
          }
        }
      }

      // Anadiplosis: Adjacent ELEMENTAL words share element ‚Üí REREAD both (ALL pairs)
      if(talent.id === 'anadiplosis'){
        const elemental = allWords.filter(w => w.elem !== undefined);
        const alreadyTriggered = new Set();
        for(let i = 0; i < elemental.length - 1; i++){
          const w1 = elemental[i];
          const w2 = elemental[i + 1];
          if(w1.elem === w2.elem){
            [w1, w2].forEach(w => {
              if(alreadyTriggered.has(w)) return;
              alreadyTriggered.add(w);
              const wordData = wordDataMap.get(w);
              applyReread(w, wordData, tid, 'Anadiplosis', rereadCount);
            });
          }
        }
      }

      // Chiasmus: First and last ELEMENTAL word same element ‚Üí REREAD √ó2 (base)
      if(talent.id === 'chiasmus'){
        const baseReread = 2; // Base is REREAD √ó2
        const scaledReread = baseReread + (rereadCount - 1); // Additive: +1 per level
        const elemental = allWords.filter(w => w.elem !== undefined);
        if(elemental.length >= 2){
          const first = elemental[0];
          const last = elemental[elemental.length - 1];
          if(first.elem === last.elem){
            [first, last].forEach(w => {
              const wordData = wordDataMap.get(w);
              applyReread(w, wordData, tid, 'Chiasmus', scaledReread);
            });
          }
        }
      }
    }
  });

  // ========================================
  // CAPSTONE ABILITIES (Skill Tree)
  // ========================================
  const heroName = h.name;

  // Graham - Cross the T's: Slash weapons REREAD √ó1
  if(hasCapstone('Graham Moor') && heroName === 'Graham Moor' && s.item && s.item.category === 'slash'){
    const weaponWord = s.item;
    const wordData = wordDataMap.get(weaponWord);
    if(wordData){
      retriggerAP += wordData.apContribution;
      retriggerWordCount += getWordCountForReread(wordData);
      if(wordData.mult) retriggerMult *= wordData.mult;
      retriggeredWords.push({word: weaponWord, talent: "Cross the T's"});
      if(wantBreakdown) breakdown.base.push(`${fmtMod(wordData.apContribution, 'ap', ' AP')} ${fmtMod(getWordCountForReread(wordData), 'word', ' W')} ${weaponWord.name} <span class="mod-badge reread">REREAD</span> Cross the T's`);
      if(wantBreakdown && wordData.mult) breakdown.multipliers.push(`${fmtMod(wordData.mult,'scale')} ${weaponWord.name} (Cross the T's)`);
    }
  }

  // Quivera - Count Cadence: Last word in forge triggers twice
  if(hasCapstone('Quivera') && heroName === 'Quivera' && allWords.length > 0){
    // Last word = gem if present, otherwise weapon
    const lastWord = s.noun1 ? s.noun1 : s.item;
    if(lastWord){
      const wordData = wordDataMap.get(lastWord);
      if(wordData){
        retriggerAP += wordData.apContribution;
        retriggerWordCount += getWordCountForReread(wordData);
        if(wordData.mult) retriggerMult *= wordData.mult;
        retriggeredWords.push({word: lastWord, talent: 'Count Cadence'});
        if(wantBreakdown) breakdown.base.push(`${fmtMod(wordData.apContribution, 'ap', ' AP')} ${fmtMod(getWordCountForReread(wordData), 'word', ' W')} ${lastWord.name} <span class="mod-badge reread">REREAD</span> Count Cadence`);
        if(wantBreakdown && wordData.mult) breakdown.multipliers.push(`${fmtMod(wordData.mult,'scale')} ${lastWord.name} (Count Cadence)`);
      }
    }
  }

  // Caesura - Ellipsis: Words after an empty slot get √ó2
  if(hasCapstone('Caesura') && heroName === 'Caesura'){
    // Check slots in order: adj1, adj2, weapon, adj3, adj4, noun1
    // If any slot is empty, subsequent words get √ó2
    const slotOrder = ['adj1', 'adj2', 'item', 'adj3', 'adj4', 'noun1'];
    let foundEmpty = false;
    slotOrder.forEach(slotKey => {
      const word = s[slotKey];
      if(!word){
        foundEmpty = true;
      } else if(foundEmpty){
        // This word comes after an empty slot - retrigger it (√ó2 effect)
        const wordData = wordDataMap.get(word);
        if(wordData){
          retriggerAP += wordData.apContribution;
          retriggerWordCount += getWordCountForReread(wordData);
          if(wordData.mult) {
            // Additive: add the bonus portion (mult - 1.0) instead of multiplying
            const bonusPortion = wordData.mult - 1.0;
            retriggerMultAdditive += bonusPortion;
          }
          retriggeredWords.push({word, talent: 'Ellipsis'});
          if(wantBreakdown) breakdown.base.push(`${fmtMod(wordData.apContribution, 'ap', ' AP')} ${fmtMod(getWordCountForReread(wordData), 'word', ' W')} ${word.name} <span class="mod-badge reread">REREAD</span> Ellipsis`);
          if(wantBreakdown && wordData.mult) breakdown.multipliers.push(`${fmtMod(wordData.mult,'scale')} ${word.name} (Ellipsis)`);
        }
      }
    });
  }

  // Belle Lettres - Knowledge Eternal: All words REREAD √ó1
  if(hasCapstone('Belle Lettres') && heroName === 'Belle Lettres'){
    allWords.forEach(word => {
      const wordData = wordDataMap.get(word);
      if(wordData){
        retriggerAP += wordData.apContribution;
        retriggerWordCount += getWordCountForReread(wordData);
        if(wordData.mult) {
          // Additive: add the bonus portion (mult - 1.0) instead of multiplying
          const bonusPortion = wordData.mult - 1.0;
          retriggerMultAdditive += bonusPortion;
        }
        retriggeredWords.push({word, talent: 'Knowledge Eternal'});
        if(wantBreakdown) breakdown.base.push(`${fmtMod(wordData.apContribution, 'ap', ' AP')} ${fmtMod(getWordCountForReread(wordData), 'word', ' W')} ${word.name} <span class="mod-badge reread">REREAD</span> Knowledge Eternal`);
        if(wantBreakdown && wordData.mult) breakdown.multipliers.push(`${fmtMod(wordData.mult,'scale')} ${word.name} (Knowledge Eternal)`);
      }
    });
  }

  // Add retrigger bonuses to totals
  baseAP += retriggerAP;
  wordCount += retriggerWordCount;
  multiplicativeMult += retriggerMultAdditive; // Apply retriggered word multipliers additively (e.g., Legendary √ó3 REREAD = +2.0)

  // Track total REREADs for converter/threshold phases
  let totalRereadCount = retriggeredWords.length;
  let globalWBonus = 0; // Only used for Echo Chamber (REREAD-dependent +W)

  // ========================================
  // PHASE 4.5: CONVERTERS & THRESHOLDS (DOMINO LOOP)
  // ========================================
  // This is where the magic happens - converters and thresholds can trigger
  // new REREADs, which feed back into converters, creating infinite loops.
  const MAX_LOOP_ITERATIONS = 100;
  const MAX_DAMAGE = 1e15; // 1 quadrillion - Ultimate Weapon threshold
  let loopIteration = 0;
  let ultimateWeaponForged = false;

  // Track which thresholds have already triggered to prevent double-counting
  const triggeredThresholds = new Set();

  // Track Crescendo's own rereads separately - prevents 2-talent infinite loops
  // Crescendo can only re-trigger if OTHER sources add new rereads
  let crescendoRereads = 0;

  // Helper to REREAD all words (used by Critical Mass, Crescendo)
  const rereadAllWords = (talentName) => {
    let newRereads = 0;
    allWords.forEach(word => {
      const wordData = wordDataMap.get(word);
      if(wordData){
        baseAP += wordData.apContribution;
        wordCount += getWordCountForReread(wordData);
        if(wordData.mult) multiplicativeMult *= wordData.mult;
        retriggeredWords.push({word, talent: talentName});
        newRereads++;
        if(wantBreakdown) breakdown.base.push(`${fmtMod(wordData.apContribution, 'ap', ' AP')} ${fmtMod(getWordCountForReread(wordData), 'word', ' W')} ${word.name} <span class="mod-badge reread">REREAD</span> ${talentName}`);
      }
    });
    return newRereads;
  };

  // Main domino loop
  let continueLoop = true;
  while(continueLoop && loopIteration < MAX_LOOP_ITERATIONS){
    continueLoop = false;
    loopIteration++;

    const rereadCountAtLoopStart = totalRereadCount;
    const wCountAtLoopStart = wordCount + globalWBonus;

    // --- CONVERTER PHASE ---

    // Echo Chamber: Each REREAD grants +5 W (shown per-word) - scales with level
    if(hasTalent('echo_chamber') && totalRereadCount > 0){
      const newRereads = totalRereadCount - (loopIteration === 1 ? 0 : rereadCountAtLoopStart);
      if(newRereads > 0 || loopIteration === 1){
        const rereadsToCount = loopIteration === 1 ? totalRereadCount : newRereads;
        const basePerReread = scaleTalentBonus('echo_chamber', 5);
        const bonus = rereadsToCount * basePerReread;
        globalWBonus += bonus;
        totalWBonuses += bonus;

        // Track per-word Echo Chamber bonuses for slot display
        if(loopIteration === 1){
          // Count rereads per word and store in wordDataMap
          const rereadCountByWord = new Map();
          retriggeredWords.forEach(r => {
            const count = rereadCountByWord.get(r.word) || 0;
            rereadCountByWord.set(r.word, count + 1);
          });
          rereadCountByWord.forEach((count, word) => {
            const wordData = wordDataMap.get(word);
            if(wordData){
              wordData.echoChamberW = count * basePerReread;
            }
          });
        }

        // Show per-word breakdown
        if(wantBreakdown && bonus > 0){
          // Group by word for cleaner display
          const rereadCountByWord = new Map();
          retriggeredWords.forEach(r => {
            const count = rereadCountByWord.get(r.word) || 0;
            rereadCountByWord.set(r.word, count + 1);
          });
          rereadCountByWord.forEach((count, word) => {
            const wordBonus = count * basePerReread;
            breakdown.multipliers.push(`${fmtMod(wordBonus, 'word', ' W')} Echo Chamber (${word.name} √ó${count})`);
          });
        }
      }
    }

    // === ELEMENTAL BUILD CONVERTERS ===

    // Prismatic Resonance: √ó1.2 per 5 Elemental W accumulated (exponential)
    if(hasTalent('prismatic_resonance') && loopIteration === 1){
      const elementalW = S.elementalWBonus || 0;
      const tiers = Math.floor(elementalW / 5); // One tier per 5 W accumulated
      if(tiers > 0){
        const scaledMult = scaleTalentMult('prismatic_resonance', 1.2);
        const mult = Math.pow(scaledMult, tiers);
        multiplicativeMult *= mult;
        if(wantBreakdown) breakdown.multipliers.push(`${fmtMod(mult, 'scale')} Prismatic Resonance (${elementalW} Elemental W √∑ 5 = ${tiers} tiers)`);
      }
    }

    // Bibliophile: Per Word in Forge ‚Üí +1 W - scales with level
    if(hasTalent('bibliophile') && loopIteration === 1){
      const basePerWord = scaleTalentBonus('bibliophile', 1);
      const bonus = allWords.length * basePerWord;
      if(bonus > 0){
        distributeWBonusToAll(bonus, `Bibliophile (${allWords.length} Words)`);
      }
    }

    // Residual: Each +W bonus grants +0.2 AP - scales with level
    if(hasTalent('residual') && totalWBonuses > 0 && loopIteration === 1){
      const basePerW = scaleTalentBonus('residual', 0.2);
      const bonus = Math.floor(totalWBonuses * basePerW);
      if(bonus > 0){
        baseAP += bonus;
        if(wantBreakdown) breakdown.base.push(`${fmtMod(bonus, 'ap', ' AP')} Residual (${totalWBonuses} W bonuses)`);
      }
    }

    // === GOLD BUILD TALENTS (IN-COMBAT GOLD GENERATION) ===

    // Midas Touch: Each elemental word in forge ‚Üí +5 Gold IN COMBAT - scales with level
    if(hasTalent('midas_touch') && loopIteration === 1){
      const elementalWords = allWords.filter(w => w.elem !== undefined);
      if(elementalWords.length > 0){
        const basePerWord = scaleTalentBonus('midas_touch', 5);
        const goldGained = elementalWords.length * basePerWord;
        S.gold += goldGained;
        if(wantBreakdown) breakdown.multipliers.push(`<span class="mod-badge gold">+${goldGained}g</span> Midas Touch (${elementalWords.length} elemental words)`);
      }
    }

    // Golden Reread: Each REREAD ‚Üí +10 Gold IN COMBAT - scales with level
    if(hasTalent('golden_reread') && totalRereadCount > 0){
      const newRereads = totalRereadCount - (loopIteration === 1 ? 0 : rereadCountAtLoopStart);
      if(newRereads > 0 || loopIteration === 1){
        const rereadsToCount = loopIteration === 1 ? totalRereadCount : newRereads;
        const basePerReread = scaleTalentBonus('golden_reread', 10);
        const goldGained = rereadsToCount * basePerReread;
        S.gold += goldGained;
        if(wantBreakdown) breakdown.multipliers.push(`<span class="mod-badge gold">+${goldGained}g</span> Golden Reread (${rereadsToCount} REREADs)`);
      }
    }

    // Liquidate is now an economy talent (goldBonus) - handled in post-combat rewards

    // Reread Amplifier: Each REREAD grants √ó1.5 (stacking) - scales with level
    if(hasTalent('reread_amplifier') && totalRereadCount > 0 && loopIteration === 1){
      const scaledMult = scaleTalentMult('reread_amplifier', 1.5);
      const mult = Math.pow(scaledMult, totalRereadCount);
      multiplicativeMult *= mult;
      if(wantBreakdown) breakdown.multipliers.push(`${fmtMod(mult, 'scale')} Reread Amplifier (${totalRereadCount} REREADs)`);
    }

    // Compound Interest: Each 50 Gold held ‚Üí √ó1.15 - scales with level
    if(hasTalent('compound_interest') && loopIteration === 1){
      const stacks = Math.floor((S.gold || 0) / 50);
      if(stacks > 0){
        const scaledMult = scaleTalentMult('compound_interest', 1.15);
        const mult = Math.pow(scaledMult, stacks);
        multiplicativeMult *= mult;
        if(wantBreakdown) breakdown.multipliers.push(`${fmtMod(mult, 'scale')} Compound Interest (${stacks}√ó50 Gold)`);
      }
    }

    // Overflow: Per 10 W above 50 ‚Üí √ó1.5 (stacks multiplicatively) - scales with level
    if(hasTalent('overflow') && loopIteration === 1){
      const currentW = wordCount + globalWBonus;
      if(currentW > 50){
        const excessW = currentW - 50;
        const stacks = Math.floor(excessW / 10);
        if(stacks > 0){
          const scaledMult = scaleTalentMult('overflow', 1.5);
          const mult = Math.pow(scaledMult, stacks);
          multiplicativeMult *= mult;
          if(wantBreakdown) breakdown.multipliers.push(`${fmtMod(mult, 'scale')} Overflow (${stacks}√ó10 W above 50)`);
        }
      }
    }

    // --- THRESHOLD PHASE (REREAD-count based) ---

    // Crescendo: 6+ REREADs ‚Üí REREAD ALL again (ONCE per forge)
    // Only counts NON-Crescendo rereads for threshold - prevents 2-talent infinite loops
    // Fires once like Chain Reaction - reaching Ultimate Weapon requires multiple synergies
    const nonCrescendoRereads = totalRereadCount - crescendoRereads;
    if(hasTalent('crescendo') && nonCrescendoRereads >= 6 && !triggeredThresholds.has('crescendo')){
      triggeredThresholds.add('crescendo');
      const newRereads = rereadAllWords('Crescendo');
      crescendoRereads += newRereads; // Track Crescendo's contribution
      totalRereadCount += newRereads;
      if(newRereads > 0) continueLoop = true;
      if(wantBreakdown) breakdown.multipliers.push(`<span class="mod-badge reread">REREAD √ó${newRereads}</span> Crescendo (${nonCrescendoRereads} non-Crescendo REREADs ‚â• 6)`);
    }


    // Chain Reaction: 4+ REREADs ‚Üí √ó3 - scales with level
    if(hasTalent('chain_reaction') && totalRereadCount >= 4 && !triggeredThresholds.has('chain_reaction')){
      triggeredThresholds.add('chain_reaction');
      const chainMult = scaleTalentMult('chain_reaction', 3);
      multiplicativeMult *= chainMult;
      if(wantBreakdown) breakdown.multipliers.push(`${fmtMod(chainMult, 'scale')} Chain Reaction (${totalRereadCount} REREADs ‚â• 4)`);
    }

    // Fortune's Favor: 200+ gold ‚Üí REREAD ALL (ONCE per forge)
    if(hasTalent('fortunes_favor') && (S.gold || 0) >= 200 && !triggeredThresholds.has('fortunes_favor')){
      triggeredThresholds.add('fortunes_favor');
      const newRereads = rereadAllWords("Fortune's Favor");
      totalRereadCount += newRereads;
      if(newRereads > 0) continueLoop = true;
      if(wantBreakdown) breakdown.multipliers.push(`<span class="mod-badge reread">REREAD √ó${newRereads}</span> Fortune's Favor (${S.gold}g ‚â• 200)`);
    }

    // Check for Ultimate Weapon (infinite loop detected)
    const currentDamage = baseAP * (wordCount + globalWBonus) * multiplicativeMult;
    if(currentDamage >= MAX_DAMAGE || !Number.isFinite(currentDamage)){
      ultimateWeaponForged = true;
      continueLoop = false;
      if(wantBreakdown) breakdown.multipliers.push(`<span class="mod-badge ultimate">THE ULTIMATE WEAPON FORGED</span>`);
    }

    // Safety: If we've looped 100 times, we're in an infinite loop
    if(loopIteration >= MAX_LOOP_ITERATIONS){
      ultimateWeaponForged = true;
      continueLoop = false;
      if(wantBreakdown) breakdown.multipliers.push(`<span class="mod-badge ultimate">INFINITE LOOP DETECTED - ULTIMATE WEAPON!</span>`);
    }
  }

  // Add global W bonus to word count
  wordCount += globalWBonus;

  // ========================================
  // PHASE 5: TALENT COUNT BASELINE
  // ========================================
  // Scale from √ó1.2 (1 talent) to √ó2.0 (9+ talents)
  const talentCountMult = S.talents.length > 0
    ? Math.min(2.0, 1.1 + S.talents.length * 0.1)
    : 1.0;
  if (wantBreakdown && S.talents.length > 0) {
    breakdown.multipliers.push(`${fmtMod(talentCountMult,'scale')} Talent Count (${S.talents.length})`);
  }

  // ========================================
  // PHASE 6: CALCULATE DAMAGE
  // ========================================
  // Formula: baseAP √ó wordCount √ó multiplicativeMult √ó talentCountMult
  // (word_count_bonus talents are already added to wordCount in Phase 2)
  let heroDmg = Math.floor(baseAP * wordCount * multiplicativeMult * talentCountMult);

  // Execute: Check if enemy would survive at ‚â§15% HP, trigger REREAD ALL
  if(hasTalent('execute') && !ultimateWeaponForged){
    const enemyMaxHP = e.hp;
    let preExecuteDmg = heroDmg;
    if(S.carriedOverkill > 0) preExecuteDmg += S.carriedOverkill;
    const remainingHP = enemyMaxHP - preExecuteDmg;
    const remainingPercent = remainingHP / enemyMaxHP;
    // Trigger if enemy would survive with 1-15% HP
    if(remainingHP > 0 && remainingPercent <= 0.15){
      const executeRereadCount = getTalentLevel('execute');
      const countLabel = executeRereadCount > 1 ? ` √ó${executeRereadCount}` : '';
      if(wantBreakdown) breakdown.multipliers.push(`<span class="mod-badge reread">REREAD ALL${countLabel}</span> Execute (enemy at ${Math.round(remainingPercent * 100)}% HP)`);
      // REREAD ALL words
      let executeAP = 0, executeW = 0, executeMult = 1;
      for(let i = 0; i < executeRereadCount; i++){
        allWords.forEach(word => {
          const wordData = wordDataMap.get(word);
          if(wordData){
            executeAP += wordData.apContribution;
            executeW += getWordCountForReread(wordData);
            if(wordData.mult) executeMult *= wordData.mult;
            retriggeredWords.push({word, talent: 'Execute'});
            if(wantBreakdown) breakdown.base.push(`${fmtMod(wordData.apContribution, 'ap', ' AP')} ${fmtMod(getWordCountForReread(wordData), 'word', ' W')} ${word.name} <span class="mod-badge reread">REREAD</span> Execute`);
          }
        });
      }
      // Recalculate damage with Execute bonuses
      baseAP += executeAP;
      wordCount += executeW;
      multiplicativeMult *= executeMult;
      heroDmg = Math.floor(baseAP * wordCount * multiplicativeMult * talentCountMult);
    }
  }

  // Hyperbole: Add carried overkill from previous round
  if (S.carriedOverkill > 0) {
    const overkillBonus = S.carriedOverkill;
    heroDmg += overkillBonus;
    if (wantBreakdown) {
      breakdown.base.push(`${fmtMod(overkillBonus, 'ap', ' AP')} Hyperbole (carried overkill)`);
      // Consume the carried overkill during actual combat (wantBreakdown = true)
      S.carriedOverkill = 0;
    }
  }

  // Boss modifier: Armored - damage reduction
  if (e.damageReduction && e.damageReduction > 0) {
    const reduction = Math.floor(heroDmg * e.damageReduction);
    heroDmg = heroDmg - reduction;
    if (wantBreakdown) breakdown.multipliers.push(`<span class="mod-badge neg">-${reduction}</span> Armored (${Math.round(e.damageReduction * 100)}% reduction)`);
  }

  // Cinna & Antony (Duality): Must be ALL same element OR opposite pairs only
  if(S.chapterBoss && S.chapterBoss.id === 'cinna_antony' && !bossAbilityDisabled){
    const elemsInWeapon = allWords.filter(w => w.elem !== undefined).map(w => w.elem);

    if(elemsInWeapon.length > 0){
      // Check condition 1: ALL same element
      const allSameElement = elemsInWeapon.every(el => el === elemsInWeapon[0]);

      // Check condition 2: ALL opposite pairs
      const uniqueElems = [...new Set(elemsInWeapon)];
      let allOppositePairs = true;
      for(const elem of uniqueElems){
        const opposite = OPPOSITE_ELEMENTS[elem];
        // Each element must have its opposite present
        if(!uniqueElems.includes(opposite)){
          allOppositePairs = false;
          break;
        }
      }

      // If neither condition met, damage is 0
      if(!allSameElement && !allOppositePairs){
        heroDmg = 0;
        if(wantBreakdown) breakdown.multipliers.push(`<span style="color:#ef4444">Cinna & Antony: Mixed elements! (0 damage)</span>`);
      } else if(wantBreakdown){
        const reason = allSameElement ? 'all same element' : 'opposite pairs only';
        breakdown.multipliers.push(`<span style="color:#4ade80">Cinna & Antony: ${reason} ‚úì</span>`);
      }
    }
  }

  // For display: effective word count including all multipliers
  const totalMultiplier = multiplicativeMult * talentCountMult;
  let displayWordCount = Math.round(wordCount * totalMultiplier * 10) / 10;

  // Enemy does no damage in this simplified model
  let enemyDmg = 0;

  // Final HP values: hero HP not tracked; enemy HP decreases by hero damage
  const enemyMax = e.hp;
  const enemyFin = Math.max(0, enemyMax - heroDmg);

  if(wantBreakdown){
    breakdown.wordCount = wordCount;
  }

  return{
    heroDmg: ultimateWeaponForged ? Infinity : heroDmg,
    enemyDmg,
    heroMax: h.hp,
    enemyMax,
    heroFin: h.hp,
    enemyFin: ultimateWeaponForged ? 0 : enemyFin,
    win: ultimateWeaponForged || enemyFin <= 0,
    tie: false,
    baseAP,
    wordCount: displayWordCount,
    heroBonus,
    weaponType: weaponWord?.id || 'stick',
    allWords,
    totalMultiplier,
    breakdown,
    retriggeredWords, // Array of {word, talent} for animation purposes
    wordDataMap, // Per-word AP contributions for slot displays
    ultimateWeaponForged, // TRUE if infinite loop detected - player wins the run!
    loopIterations: loopIteration, // How many domino loop iterations occurred
    totalRereadCount // Total REREADs triggered
  };
}

function updPrev(){
  const v=!!S.sel.item;$("#forge-btn").disabled=!v;
  if(!v){
    // Without a weapon selected, show 0 damage
    const defMult=S.hero.str.includes(S.enemy.atk)?0.7:S.hero.weak.includes(S.enemy.atk)?1.5:1;
    $("#pv-hero").textContent="0";
    $("#pv-enemy").textContent=Math.round(S.enemy.ap*defMult);
    return;
  }
  const c=calc();
  $("#pv-hero").textContent=Math.round(c.heroDmg);
  $("#pv-enemy").textContent=Math.round(c.enemyDmg);

}

function updatePreviewStats(c) {
  // This can be expanded later to show detailed breakdown
  // For now, the main preview numbers are handled in updPrev
}

// Build full weapon name from selection for stats tracking
function buildWeaponName(sel){
  const parts = [];
  // Adjective slots (adj1, adj2)
  if(sel.adj1){
    parts.push(getDisplayForm(sel.adj1, 'adj1', sel));
  }
  if(sel.adj2){
    parts.push(getDisplayForm(sel.adj2, 'adj2', sel));
  }
  // Weapon name
  if(sel.item){
    parts.push(sel.item.name);
  }
  // Adjective slots after weapon (adj3, adj4)
  if(sel.adj3){
    parts.push(getDisplayForm(sel.adj3, 'adj3', sel));
  }
  if(sel.adj4){
    parts.push(getDisplayForm(sel.adj4, 'adj4', sel));
  }
  // Noun (of X)
  if(sel.noun1){
    parts.push(`of ${getDisplayForm(sel.noun1, 'noun1', sel)}`);
  }
  return parts.join(' ') || "Unknown Weapon";
}

// === COMBAT ===
let isForging = false; // Guard against double-clicking forge button

async function forge(){
  // Prevent double-clicking, also block if onboarding dialogue is visible
  const onboardingVisible = document.getElementById('onboarding-overlay')?.classList.contains('visible');
  if (isForging || isTransitioning || onboardingVisible) return;
  isForging = true;

  // Onboarding: check if player would lose and block if needed
  if (ONBOARD.active) {
    const blocked = await onOnboardingForgeAttempt();
    if (blocked) {
      isForging = false;
      return;
    }
  }

  playSample('forge weapon button.ogg', 0.9);

  // Show spotlight tint immediately when forging
  const spotlightTint = document.getElementById('spotlight-tint');
  if(spotlightTint) spotlightTint.classList.add('show');

  // Visual effects on forge - blacksmith anvil strike with persistent embers
  pulseFlame();
  const forgeBtn = document.getElementById("forge-btn");
  if (forgeBtn) {
    const rect = forgeBtn.getBoundingClientRect();
    burstSparks(rect.left + rect.width / 2, rect.top + rect.height / 2, 30);
  }

  // Animate the main weapon display out before combat overlay shows
  const mainWeaponCanvas = document.querySelector('#weapon-display .weapon-canvas');
  if (mainWeaponCanvas) {
    mainWeaponCanvas.classList.add('fly-out');
  }

  // Track weapon types and words used for adaptive talents BEFORE calc()
  // so talents like Anthology can use the current battle's words
  if (S.sel.item) {
    if (S.sel.item.category) S.usedWeaponTypes.add(S.sel.item.category);
    if (S.sel.item.name) S.usedWeapons.add(S.sel.item.name);
  }

  // Track all words used this round (in combat order)
  const allWords = [S.sel.adj1, S.sel.adj2, S.sel.item, S.sel.adj3, S.sel.adj4, S.sel.noun1].filter(Boolean);
  allWords.forEach(w => {
    if (w.id) {
      S.uniqueWordsUsed.add(w.id);
    }
    // Track elemental words used for economy talents
    if (w.elem !== undefined) {
      if (!S.elementWordsUsed) S.elementWordsUsed = {};
      S.elementWordsUsed[w.elem] = (S.elementWordsUsed[w.elem] || 0) + 1;
    }
    // Track tier words played for talents (T1=1, T2=2, T3=3)
    if (w.rarity !== undefined) {
      const tier = w.rarity <= 0 ? 1 : (w.rarity <= 2 ? 2 : 3);
      if (!S.tierWordsPlayed) S.tierWordsPlayed = {1:0, 2:0, 3:0};
      S.tierWordsPlayed[tier] = (S.tierWordsPlayed[tier] || 0) + 1;
    }
    // Track rarity words used (words with type 'rarity' like Common, Legendary, etc.)
    if (w.type === 'rarity') {
      S.rarityWordsUsed = (S.rarityWordsUsed || 0) + 1;
    }
  });

  const c=calc({ breakdown: true });
  // Track cumulative stats for talents (AFTER calc so they count previous forges only)
  S.wordsUsedThisRun = (S.wordsUsedThisRun || 0) + allWords.length;
  if (c.retriggeredWords && c.retriggeredWords.length > 0) {
    S.rereadTriggersThisRun = (S.rereadTriggersThisRun || 0) + c.retriggeredWords.length;
  }
  // Track cumulative Word Count (W) for Prismatic Resonance
  if (S.cumulativeWordCount === undefined) S.cumulativeWordCount = 0;
  S.cumulativeWordCount += Math.floor(c.breakdown ? c.breakdown.wordCount : c.wordCount);
  // Store last combat rereads for Echo Profits gold bonus
  S.lastCombatRereads = c.totalRereadCount || 0;
  // Track elemental W bonus for Elemental Mastery and Weakness Exploit Amp
  const hasTalentForge = (id) => S.talents && S.talents.includes(id);
  let elementalWGainedThisCombat = 0; // Track for display in victory screen
  if (hasTalentForge('elemental_mastery') || hasTalentForge('weakness_exploit_amp')) {
    if (S.elementalWBonus === undefined) S.elementalWBonus = 0;
    allWords.forEach(w => {
      if (w.elem !== undefined) {
        // Elemental Mastery: +2 W per element word
        if (hasTalentForge('elemental_mastery')) {
          elementalWGainedThisCombat += 2;
        }
        // Weakness Exploit Amp: +4 W if hitting weakness
        if (hasTalentForge('weakness_exploit_amp') && S.enemy && S.enemy.weak && S.enemy.weak.includes(w.elem)) {
          elementalWGainedThisCombat += 4;
        }
      }
    });
    S.elementalWBonus += elementalWGainedThisCombat;
  }
  PStats.weaponsForged++;
  const currentDamage = Math.round(c.heroDmg||0);
  if(currentDamage > PStats.bestDamage){
    PStats.bestDamage = currentDamage;
    PStats.bestWeaponName = buildWeaponName(S.sel);
  }

  saveStats();
  // No descriptive combat log: rely on slot calculation details for transparency
  renderWeapon("#combat-weapon-svg");

  // Build retrigger count map from calc results
  const retriggerMap = new Map();
  if(c.retriggeredWords && c.retriggeredWords.length > 0){
    c.retriggeredWords.forEach(({word, talent}) => {
      const currentCount = retriggerMap.get(word) || 1;
      retriggerMap.set(word, currentCount + 1);
    });
  }

  // Build words display for combat animation. Instead of showing the full weapon name,
  // list each part of the phrase on its own line with its contribution. This improves
  // clarity by matching the forging UI order: adjectives before the weapon, the weapon
  // itself, the "of (the)" connector, the gem/suffix element, and adjectives after the
  // gem. Even if a gem is not present, "of (the)" is still displayed to reinforce the
  // expected structure.
  const words = [];
  const e = S.enemy;
  const resists = (el) => !(S.tempEffects && S.tempEffects.polymorph) && e.res.includes(el);

  // Helper to convert words for display based on slot.  All non-weapon words
  // use their adjective form when occupying an adjective slot and noun form when
  // occupying the gem slot.  Weapons retain their own name.  If a slot is
  // empty, return null so nothing is pushed.
  function getDisplayForSlot(word, slotKey){
    if(!word) return null;
    // Stick: display separately with fixed multiplier text
    if(word.isStick){
      return { name: word.name, value: '', tooltip: '√ó0.25', rarity: -1, color: null };
    }
    // Determine the display name based on slot (adjective vs noun form)
    const displayName = getDisplayForm(word, slotKey, S.sel);

    // Check if this is a multiplier word (rarity-based adjectives).  When placed in the
    // In gem slot (noun1), words with mult should behave like nouns and contribute AP
    // rather than acting as multipliers. Only use mult in non-gem slots.
    if(word.mult !== undefined && slotKey !== 'noun1'){
      return {
        name: displayName,
        value: '',
        tooltip: fmtMod(word.mult,'scale'),
        rarity: word.rarity,
        color: null
      };
    }

    // Base AP for this word (respecting explicit 'ap' or derived from rarity)
    let baseValue = getBaseAP(word);
    let displayValue = `+${baseValue}`;
    let color = null;

    // Element interactions: weakness doubles AP, resistance nullifies AP
    if(word.elem !== undefined){
      color = EC[word.elem];
      if(e.weak.includes(word.elem)){
        // Weakness doubles AP
        let weakVal = baseValue * 2;
        // Apply gem bonus (√ó2) if in gem slot (total √ó4)
        if(slotKey === 'noun1'){
          displayValue = `+${weakVal * 2} (GEM+WEAK!)`;
        } else {
          displayValue = `+${weakVal} (WEAK!)`;
        }
      } else if(resists(word.elem)){
        // Resistance negates AP
        displayValue = `√ó0 (RES)`;
      } else {
        // Normal element, check for gem bonus
        if(slotKey === 'noun1'){
          displayValue = `+${baseValue * 2} (GEM)`;
        }
      }
    } else {
      // No element: gem slot still doubles base AP
      if(slotKey === 'noun1'){
        displayValue = `+${baseValue * 2} (GEM)`;
      }
    }
    return {
      name: displayName,
      value: '',
      tooltip: displayValue,
      rarity: word.rarity,
      color
    };
  }

  // Build phrase order: pre-adjectives, weapon, of (the), gem, post-adjectives
  const preAdjs = ['adj1','adj2'];
  const postAdjs = ['adj3','adj4'];
  // Pre-adjectives
  preAdjs.forEach(k=>{
    const wordObj = S.sel[k];
    const entry = getDisplayForSlot(wordObj, k);
    if(entry){
      const retriggerCount = wordObj ? retriggerMap.get(wordObj) : null;
      words.push({ ...entry, intensity: 1.0, retriggerCount, wordRef: wordObj });
    }
  });
  // Weapon
  if(S.sel.item){
    const w = S.sel.item;
    // Determine the weapon's base AP (respect explicit 'ap' if present) and build the display value
    let baseValue = getBaseAP(w);
    let displayValue = `+${baseValue}`;
    let color = null;
    if(w.elem !== undefined){
      color = EC[w.elem];
      if(e.weak.includes(w.elem)){
        displayValue = `+${baseValue * 2} (WEAK!)`;
      } else if(resists(w.elem)){
        displayValue = `√ó0 (RES)`;
      }
    }
    const retriggerCount = retriggerMap.get(w);
    words.push({
      name: w.name,
      value: '',
      tooltip: displayValue,
      rarity: w.rarity,
      intensity: 1.0,
      color,
      retriggerCount,
      wordRef: w
    });
  }
  // Only show "of the" section if there's actually a gem.
  // If there's no gem, there should be no "of the blank blank".
  const hasGem = S.sel.noun1 !== null;

  if(hasGem){
    // Insert the "of the" connector line.  It has no AP value but helps
    // the player visualize the expected placement of the gem.  The rarity is set
    // to 3 for styling purposes.
    words.push({
      name: 'of the',
      value: '',
      rarity: 3,
      intensity: 1.0,
      color: null,
      italic: true
    });

    // Post-adjectives appear immediately after the connector (only if gem exists)
    postAdjs.forEach(k => {
      const wordObj = S.sel[k];
      const entry = getDisplayForSlot(wordObj, k);
      if(entry){
        const retriggerCount = wordObj ? retriggerMap.get(wordObj) : null;
        words.push({ ...entry, intensity: 1.0, retriggerCount, wordRef: wordObj });
      }
    });

    // Gem / suffix element appears after post‚Äëadjectives
    const gemEntry = getDisplayForSlot(S.sel.noun1, 'noun1');
    if(gemEntry) {
      const retriggerCount = S.sel.noun1 ? retriggerMap.get(S.sel.noun1) : null;
      words.push({ ...gemEntry, intensity: 1.0, retriggerCount, wordRef: S.sel.noun1 });
    }
  }

  // Calculate rewards before combat for display purposes
  const rewards = {
    gold: 0,
    items: []
  };

  const {enemy:safeEnemy}=getCombatants();
  const targetHp = safeEnemy.hp || 0;

  // Reset any pre-rolled loot when entering combat; re-roll if a boss victory is predicted
  S.pendingBossLoot = null;

  if(c.heroDmg >= targetHp){
    // Victory - flat gold reward (no streak/overkill bonuses)
    let goldReward = 20;

    rewards.gold = goldReward;
    rewards.talentGoldBonuses = []; // Track individual talent gold bonuses for animated display
    rewards.elementalWGained = elementalWGainedThisCombat; // Track elemental W gained this combat for display

    // Calculate talent gold bonuses (economy talents with goldBonus)
    const forgeWordsForGold = [S.sel.adj1, S.sel.adj2, S.sel.item, S.sel.adj3, S.sel.adj4, S.sel.noun1].filter(Boolean);
    const hasTalentForGold = (id) => S.talents && S.talents.includes(id);
    S.talents?.forEach(tid => {
      const talent = TALENTS.find(t => t.id === tid);
      if(talent && talent.goldBonus){
        const ctx = { state: S, hero: S.hero, enemy: S.enemy, allWords: forgeWordsForGold };
        const bonus = talent.goldBonus(ctx);
        if(bonus > 0){
          rewards.talentGoldBonuses.push({ name: talent.name, amount: bonus });
          rewards.gold += bonus;
        }
      }
    });

    // Boss loot
    const isBoss = (S.roundIndex % 3 === 0);
    if(isBoss){
      // Preview what loot will be granted: 1 weapon + 3 words with a guaranteed Tier-3 drop
      const bossLoot = rollBossLootDrops();
      S.pendingBossLoot = bossLoot;

      const dropOrder = [];
      if(bossLoot && Array.isArray(bossLoot.words)){
        dropOrder.push(...bossLoot.words);
      }
      if(bossLoot && bossLoot.weapon){
        dropOrder.push(bossLoot.weapon);
      }
      rewards.items.push(...dropOrder.map(item => item.name));
    }
  }

  // Consume the used words from inventory (except stick)
  Object.values(S.sel).filter(Boolean).forEach(w=>{
    if(!w.isStick){
      const i = S.inv.indexOf(w);
      if(i >= 0) S.inv.splice(i,1);
    }
  });

  showCombat(c, words, rewards);
}

/**
 * Calculate weight boosts for word drops based on player's talents.
 * Talents that affect specific elements or weapon types increase their drop chance.
 * Returns { elements: {elem_id: multiplier}, weaponTypes: {type: multiplier} }
 */
function getTalentWeightBoosts(){
  const boosts = {
    elements: {},
    weaponTypes: {}
  };

  if(!S.talents || S.talents.length === 0) return boosts;

  const hasTalent = (id) => S.talents.includes(id);
  const BOOST = 2.5; // 150% weight increase for talent-related words

  // Family-based talent boosts
  // World & Sky family: Fire, Water, Earth, Lightning
  if(hasTalent('world_sky_ink') || hasTalent('world_sky_focus')) {
    WORLD_SKY.forEach(elem => boosts.elements[elem] = BOOST);
  }
  // Body & Soul family: Physical, Poison, Light, Dark
  if(hasTalent('body_soul_ink') || hasTalent('body_soul_focus')) {
    BODY_SOUL.forEach(elem => boosts.elements[elem] = BOOST);
  }

  // Dual-element synergy talents boost both elements (kept 6 of 12)
  if(hasTalent('magma_core')){ // Fire + Earth
    boosts.elements[E.FIRE] = (boosts.elements[E.FIRE] || 1) * BOOST;
    boosts.elements[E.EARTH] = (boosts.elements[E.EARTH] || 1) * BOOST;
  }
  if(hasTalent('tempest')){ // Water + Lightning
    boosts.elements[E.WATER] = (boosts.elements[E.WATER] || 1) * BOOST;
    boosts.elements[E.LIGHTNING] = (boosts.elements[E.LIGHTNING] || 1) * BOOST;
  }
  if(hasTalent('eclipse')){ // Light + Dark
    boosts.elements[E.LIGHT] = (boosts.elements[E.LIGHT] || 1) * BOOST;
    boosts.elements[E.DARK] = (boosts.elements[E.DARK] || 1) * BOOST;
  }
  if(hasTalent('necrotoxin')){ // Dark + Poison
    boosts.elements[E.DARK] = (boosts.elements[E.DARK] || 1) * BOOST;
    boosts.elements[E.POISON] = (boosts.elements[E.POISON] || 1) * BOOST;
  }
  if(hasTalent('blessed_steel')){ // Light + Physical
    boosts.elements[E.LIGHT] = (boosts.elements[E.LIGHT] || 1) * BOOST;
    boosts.elements[E.PHYS] = (boosts.elements[E.PHYS] || 1) * BOOST;
  }
  if(hasTalent('static_earth')){ // Earth + Lightning
    boosts.elements[E.EARTH] = (boosts.elements[E.EARTH] || 1) * BOOST;
    boosts.elements[E.LIGHTNING] = (boosts.elements[E.LIGHTNING] || 1) * BOOST;
  }

  // Proficiency Focus boosts preferred weapon type
  if(hasTalent('proficiency_focus') && S.hero && S.hero.good) {
    boosts.weaponTypes[S.hero.good] = 2.0;
  }

  return boosts;
}

function buildWeightedPool(words, heroSkew = true){
  const pool = [];

  // Get talent-based weight bonuses for elements and weapon types
  const talentBoosts = getTalentWeightBoosts();

  // Separate words into hero-favored and other categories
  const heroStrWords = [];
  const otherWords = [];
  const heroWeapons = [];
  const otherWeapons = [];

  words.forEach(w => {
    if(heroSkew && S.hero){
      if(w.type === 'weapon'){
        if(w.category === S.hero.good){
          heroWeapons.push(w);
        } else {
          otherWeapons.push(w);
        }
      } else if(w.elem !== undefined && S.hero.str && S.hero.str.includes(w.elem)){
        heroStrWords.push(w);
      } else {
        otherWords.push(w);
      }
    } else {
      // No hero skew - use base weights
      const rank = w.rarity || 0;
      const weight = rank === 0 ? 11 : rank === 2 ? 7 : 2;
      for(let i = 0; i < weight; i++) pool.push(w);
    }
  });

  // With hero skew: 50% hero strength elements, 35% hero weapons
  if(heroSkew && S.hero){
    // For non-weapons: 50% from hero strength pool, 50% from others
    // Weight hero words 3x to achieve ~50% when pools are unequal
    // Also apply talent-based element boosts
    heroStrWords.forEach(w => {
      const rank = w.rarity || 0;
      let weight = (rank === 0 ? 11 : rank === 2 ? 7 : 2) * 3;
      // Apply talent boost for this element
      if(w.elem !== undefined && talentBoosts.elements[w.elem]){
        weight = Math.floor(weight * talentBoosts.elements[w.elem]);
      }
      for(let i = 0; i < weight; i++) pool.push(w);
    });
    otherWords.forEach(w => {
      const rank = w.rarity || 0;
      let weight = rank === 0 ? 11 : rank === 2 ? 7 : 2;
      // Apply talent boost for this element
      if(w.elem !== undefined && talentBoosts.elements[w.elem]){
        weight = Math.floor(weight * talentBoosts.elements[w.elem]);
      }
      for(let i = 0; i < weight; i++) pool.push(w);
    });

    // For weapons: 35% from hero proficiency pool
    // Weight hero weapons 2x to achieve ~35%
    // Also apply talent-based weapon type boosts
    heroWeapons.forEach(w => {
      const rank = w.rarity || 0;
      let weight = (rank === 0 ? 11 : rank === 2 ? 7 : 2) * 2;
      // Apply talent boost for this weapon type
      if(w.category && talentBoosts.weaponTypes[w.category]){
        weight = Math.floor(weight * talentBoosts.weaponTypes[w.category]);
      }
      for(let i = 0; i < weight; i++) pool.push(w);
    });
    otherWeapons.forEach(w => {
      const rank = w.rarity || 0;
      let weight = rank === 0 ? 11 : rank === 2 ? 7 : 2;
      // Apply talent boost for this weapon type
      if(w.category && talentBoosts.weaponTypes[w.category]){
        weight = Math.floor(weight * talentBoosts.weaponTypes[w.category]);
      }
      for(let i = 0; i < weight; i++) pool.push(w);
    });
  }

  return pool;
}

function rollBossLootDrops(){
  // Boss rewards strongly favor hero's proficiency and elements
  const weapons = WORDS.filter(w => w.type === 'weapon');

  // 80% chance to drop hero's proficient weapon type
  const goodWeapons = weapons.filter(w => w.category === S.hero?.good);
  const weaponDrop = (Math.random() < 0.8 && goodWeapons.length > 0)
    ? goodWeapons[Math.floor(Math.random() * goodWeapons.length)]
    : weapons[Math.floor(Math.random() * weapons.length)];

  const nonWeapons = WORDS.filter(w => w.type !== 'weapon' && !w.hiddenInBank);

  // For T3 pool, prioritize hero's strength elements (70% chance)
  const heroStrElements = S.hero?.str || [];
  const tier3Pool = nonWeapons.filter(w => (w.rarity || 0) >= 3);
  const tier3HeroStr = tier3Pool.filter(w => w.elem !== undefined && heroStrElements.includes(w.elem));

  const guaranteedT3 = (Math.random() < 0.7 && tier3HeroStr.length > 0)
    ? tier3HeroStr[Math.floor(Math.random() * tier3HeroStr.length)]
    : (tier3Pool.length > 0 ? tier3Pool[Math.floor(Math.random() * tier3Pool.length)] : null);

  const wordDrops = [];
  if(guaranteedT3) wordDrops.push(guaranteedT3);

  // For additional word drops, also favor hero's strength elements (70% chance each)
  const heroStrWords = nonWeapons.filter(w => w.elem !== undefined && heroStrElements.includes(w.elem));
  const desiredWordCount = 3;
  for(let i = wordDrops.length; i < desiredWordCount; i++){
    if(nonWeapons.length === 0) break;
    // 70% chance to pick from hero strength elements
    if(Math.random() < 0.7 && heroStrWords.length > 0){
      const randWord = heroStrWords[Math.floor(Math.random() * heroStrWords.length)];
      if(randWord) wordDrops.push(randWord);
    } else {
      const randWord = nonWeapons[Math.floor(Math.random() * nonWeapons.length)];
      if(randWord) wordDrops.push(randWord);
    }
  }

  return { weapon: weaponDrop, words: wordDrops };
}

async function afterCombat(){
  isForging = false;

  const lastResult=window.lastCombatResult;
  const spotlightTint = $("#spotlight-tint");

  if(!lastResult){
    $("#combat-overlay").classList.remove("show", "combat-reveal", "combat-result", "combat-exit");
    if(spotlightTint) spotlightTint.classList.remove("show", "full");
    return;
  }
  if(lastResult.win){
    // === ULTIMATE WEAPON VICTORY - SPECIAL HANDLING ===
    // If Ultimate Weapon was forged, treat it as a complete run victory (like Round 18)
    if(lastResult.ultimateWeaponForged){
      S.wins++;S.streak++;

      // Mark this as a full victory - same stats tracking as Round 18 completion
      PStats.victories++;
      if(S.hero && S.hero.name) PStats.heroClears[S.hero.name]=true;

      // Track difficulty clears per hero for unlocking harder modes
      if(!PStats.heroDifficultyClears) PStats.heroDifficultyClears = {};
      const heroName = S.hero.name;
      if(!PStats.heroDifficultyClears[heroName]) PStats.heroDifficultyClears[heroName] = {};
      const diff = S.difficulty || 0;
      PStats.heroDifficultyClears[heroName][diff] = (PStats.heroDifficultyClears[heroName][diff] || 0) + 1;

      // Track global difficulty clears for achievements
      if(!PStats.difficultyClears) PStats.difficultyClears = {};
      PStats.difficultyClears[diff] = (PStats.difficultyClears[diff] || 0) + 1;

      // Track highest round reached
      const currentRound = S.roundIndex - 1;
      if(!PStats.highestRound || currentRound > PStats.highestRound){
        PStats.highestRound = currentRound;
      }

      saveStats();
      checkAndUnlockAchievements();

      // Award XP to hero for completing the run (with boss bonus for ultimate achievement)
      if(S.hero && S.hero.name){
        const xpGained = calcRunXP(S.roundIndex, true); // true = defeated boss equivalent
        const result = awardHeroXP(S.hero.name, xpGained);
        S.lastRunXP = { xp: xpGained, ...result };
      }

      // Clear run save - the run is complete
      clearRunSave();
      S.heroSelected = false;

      // Show a special Ultimate Weapon celebration
      // Use the chapter celebration overlay with custom text for Ultimate Weapon
      const titleEl = document.getElementById('chapter-title');
      const goldWrapper = document.getElementById('chapter-gold-wrapper');
      const dialogueEl = document.getElementById('chapter-hero-dialogue');
      const continueBtn = document.getElementById('chapter-continue-btn');
      const mainMenuBtn = document.getElementById('chapter-mainmenu-btn');
      const portraitEl = document.getElementById('chapter-hero-portrait');
      const heroNameEl = document.getElementById('chapter-hero-name');
      const godRaysEl = document.getElementById('chapter-god-rays');
      const modalEl = document.querySelector('#chapter-overlay .chapter-modal');

      // Customize for Ultimate Weapon
      if(titleEl) titleEl.innerHTML = '<span class="mod-badge ultimate">ULTIMATE WEAPON FORGED!</span>';
      if(goldWrapper) goldWrapper.style.display = 'none'; // No gold bonus display needed

      // Show hero portrait
      if(portraitEl && S.hero){
        portraitEl.innerHTML = getPortraitSVG(S.hero.portrait || S.hero.name);
        portraitEl.classList.add('show');
      }

      // Show hero name
      if(heroNameEl && S.hero){
        heroNameEl.textContent = S.hero.name;
        heroNameEl.classList.add('show');
      }

      // Epic dialogue for Ultimate Weapon achievement
      if(dialogueEl){
        dialogueEl.textContent = '"The ultimate power... achieved through perfect word mastery. The lexicon itself bends to your will."';
      }

      // Add rainbow effects
      if(godRaysEl) godRaysEl.classList.add('rainbow');
      if(modalEl) modalEl.classList.add('rainbow');

      // Epic celebration sparks!
      pulseFlame();
      burstSparks(window.innerWidth / 2, window.innerHeight / 2, 100, ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#54a0ff', '#5f27cd'], true);
      // Multiple waves of celebration
      setTimeout(() => {
        burstSparks(window.innerWidth / 2 - 150, window.innerHeight / 2, 60, ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#54a0ff', '#5f27cd'], true);
        burstSparks(window.innerWidth / 2 + 150, window.innerHeight / 2, 60, ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#54a0ff', '#5f27cd'], true);
      }, 200);
      setTimeout(() => {
        burstSparks(window.innerWidth / 2, window.innerHeight / 2 - 100, 60, ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#54a0ff', '#5f27cd'], true);
        burstSparks(window.innerWidth / 2, window.innerHeight / 2 + 100, 60, ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#54a0ff', '#5f27cd'], true);
      }, 400);

      // Show main menu button only (no continue to endless)
      if(continueBtn) continueBtn.style.display = 'none';
      if(mainMenuBtn) {
        mainMenuBtn.classList.add('show');
        mainMenuBtn.textContent = 'RETURN TO MAIN MENU';
      }

      // Trigger victory music effect
      if(musicEngine && musicEngine.initialized){
        musicEngine.triggerVictoryEffect();
      }

      // Play celebration sound
      try { playSample('rarity.ogg', 1.0); } catch(e){}

      // Show the overlay
      const overlay = document.getElementById('chapter-overlay');
      if(overlay){
        overlay.classList.remove('show');
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            overlay.classList.add('show');
            overlay.focus?.();
          });
        });
      }

      // Wait for user to return to main menu
      await new Promise((resolve) => {
        if(mainMenuBtn){
          mainMenuBtn.onclick = async () => {
            if(isTransitioning) return;
            playSample('click.ogg', 0.8);
            // Unified transition: hide celebration AND show main menu at peak
            await playSceneTransition(() => {
              overlay.classList.remove('show');
              // Clean up rainbow classes and show states
              if(godRaysEl) godRaysEl.classList.remove('rainbow');
              if(modalEl) modalEl.classList.remove('rainbow');
              if(portraitEl) portraitEl.classList.remove('show');
              if(heroNameEl) heroNameEl.classList.remove('show');
              if(continueBtn) continueBtn.style.display = '';
              mainMenuBtn.classList.remove('show');
              // Go back to main menu
              showMainMenu();
            });
            resolve();
          };
          mainMenuBtn.onmouseenter = sfxHover;
        }
      });

      return; // END - Ultimate Weapon victory handled, don't continue to normal flow
    }
  }

  const pendingBossLoot = S.pendingBossLoot;
  S.pendingBossLoot = null;

  // Fade to full black before transitioning
  const tintAlreadyFull = spotlightTint && spotlightTint.classList.contains("full");
  if(spotlightTint) spotlightTint.classList.add("full");
  if(tintAlreadyFull){
    await dly(RHYTHM.QUARTER); // Let exit animation register
  } else {
    await dly(RHYTHM.HALF); // Wait for fade to complete
    await dly(RHYTHM.BEAT); // Hold at full black
  }

  // Hide combat overlay (invisible behind black)
  $("#combat-overlay").classList.remove("show", "combat-reveal", "combat-result", "combat-exit");

  // Close breakdown tooltip if open
  const breakdownTooltip = $("#combat-breakdown-tooltip");
  const breakdownBtn = $("#combat-breakdown-btn");
  if(breakdownTooltip) breakdownTooltip.classList.remove('show');
  if(breakdownBtn) breakdownBtn.classList.remove('active');

  // Clear temporary effects after combat
  S.tempEffects={};

  const hasTalent=(id)=>S.talents.includes(id);

  if(lastResult.win){
    // Victory: level up, gain gold, proceed
    S.wins++;S.streak++;
    if(S.roundIndex>=18){
      PStats.victories++;
      if(S.hero && S.hero.name) PStats.heroClears[S.hero.name]=true;
      // Track difficulty clears per hero for unlocking harder modes
      if(!PStats.heroDifficultyClears) PStats.heroDifficultyClears = {};
      const heroName = S.hero.name;
      if(!PStats.heroDifficultyClears[heroName]) PStats.heroDifficultyClears[heroName] = {};
      const diff = S.difficulty || 0;
      PStats.heroDifficultyClears[heroName][diff] = (PStats.heroDifficultyClears[heroName][diff] || 0) + 1;
      // Also track global difficulty clears for achievements
      if(!PStats.difficultyClears) PStats.difficultyClears = {};
      PStats.difficultyClears[diff] = (PStats.difficultyClears[diff] || 0) + 1;
      saveStats();
      checkAndUnlockAchievements();
    }

    // Track chapter boss defeats and unlock heroes
    if(S.chapterBoss && S.chapterBoss.id){
      const bossId = S.chapterBoss.id;
      if(!PStats.bossDefeats) PStats.bossDefeats = {};
      if(!PStats.bossDefeats[bossId]){
        PStats.bossDefeats[bossId] = true;
        // Unlock hero based on which boss was defeated
        const bossHeroMap = {
          'cinna_antony': 'Quivera',
          'red_aktins': 'Belle Lettres',
          'plague_doctor': 'Alexandria Constanza',
          'oxy': 'Caesura',
          'dotdotdot': 'Reed'
        };
        const heroToUnlock = bossHeroMap[bossId];
        if(heroToUnlock && !PStats.unlockedHeroes) PStats.unlockedHeroes = ['Graham Moor'];
        if(heroToUnlock && !PStats.unlockedHeroes.includes(heroToUnlock)){
          PStats.unlockedHeroes.push(heroToUnlock);
          S.pendingHeroUnlock = { hero: heroToUnlock, boss: S.chapterBoss.name };
        }
        saveStats();
        checkAndUnlockAchievements();
      }
    }

    // Flat gold reward (interest is now granted on shop exit)
    const isBoss = (S.roundIndex % 3 === 0);
    let reward = 15; // Base flat reward
    if(isBoss) reward += 15; // Extra for boss (total: 30g)

    // Calculate overkill for Hyperbole talent (but no gold bonus)
    const overkill=Math.max(0,Math.round(lastResult.heroDmg-lastResult.enemyMax));

    // Hyperbole: Overkill √ó2 carries to next round (capped at 25% of enemy max HP) - scales with level
    if(hasTalent('hyperbole') && overkill > 0){
      const maxCarry = Math.floor(lastResult.enemyMax * 0.25);
      const overkillMult = scaleTalentMult('hyperbole', 2);
      S.carriedOverkill = Math.min(Math.floor(overkill * overkillMult), maxCarry);
    } else {
      S.carriedOverkill = 0; // Reset if no overkill or no talent
    }

    // Economy talents: Apply goldBonus from dividend talents
    // Include allWords from current forge for gold talents that scale with word properties
    const forgeWords = [S.sel.adj1, S.sel.adj2, S.sel.item, S.sel.adj3, S.sel.adj4, S.sel.noun1].filter(Boolean);
    S.talents.forEach(tid => {
      const talent = TALENTS.find(t => t.id === tid);
      if(talent && talent.goldBonus){
        const ctx = { state: S, hero: S.hero, enemy: S.enemy, allWords: forgeWords };
        const bonus = talent.goldBonus(ctx);
        if(bonus > 0) reward += bonus;
      }
    });

    S.gold += reward;
    checkTreasureHunterAchievement();

    // [T3] Battle Hardened: Each round survived: +3 base AP (permanent) - scales with level
    if(hasTalent("battle_hardened")){
      S.battleHardenedBonus += scaleTalentBonus('battle_hardened', 3);
    }

    // Level up
    S.level++;

    // Delivery of goods: grant the player a free pack of 1 weapon and 3 words ONLY after boss victories.
    // Bosses occur at rounds 3, 6, 9, etc. (every 3rd round). One of the words is always Tier-3,
    // with the remaining drops still using weighted rarity (T1=50%, T2=35%, T3=15%).
    if(isBoss){
      // Track boss defeat for talents
      S.bossesDefeated++;

      // MINIMALIST achievement: Win boss with 3 or fewer words
      if(forgeWords.length <= 3){
        unlockSteamAchievement('MINIMALIST');
      }

      const bossLoot = pendingBossLoot || rollBossLootDrops();
      const dropOrder = [];
      if(bossLoot && Array.isArray(bossLoot.words)){
        dropOrder.push(...bossLoot.words);
      }
      if(bossLoot && bossLoot.weapon){
        dropOrder.push(bossLoot.weapon);
      }

      // Only count visible words (exclude hiddenInBank words)
      const visibleCount = S.inv.filter(w => !w.hiddenInBank).length;
      const availableSlots = Math.max(0, INV_LIMIT - visibleCount);

      // Add items that fit in inventory
      if(availableSlots > 0){
        dropOrder.slice(0, availableSlots).forEach(drop => S.inv.push({ ...drop }));
        checkHoarderAchievement();
      }

      // Convert overflow items to gold (same as sell prices: T1=1g, T2=2g, T3=5g)
      const overflowItems = dropOrder.slice(availableSlots);
      if(overflowItems.length > 0){
        let overflowGold = 0;
        overflowItems.forEach(item => {
          const tier = item.rarity || 0;
          overflowGold += tier === 0 ? 1 : tier === 2 ? 2 : 5;
        });
        S.gold += overflowGold;
        S.lastOverflowGold = overflowGold; // Track for display
        S.lastOverflowCount = overflowItems.length;
      }
    }

    // Proceed to the next round.  If roundIndex equals 10 (i.e. after defeating
    // the round 9 boss), show the victory screen with option to continue to endless mode.
    // For rounds 10+, continue directly to shop (endless mode).

    // Check if this is a Chapter completion (every 9th round)
    const isChapterBoss = (S.roundIndex % 9 === 0);

    S.roundIndex++;

    S.belleRandomWeaknesses = null;
    S.nextEnemyBonusWeaknesses = null;
    S.nextEnemyData = null;

    const currentRound = S.roundIndex - 1;
    if(!PStats.highestRound || currentRound > PStats.highestRound){
      PStats.highestRound = currentRound;
      saveStats();
    }

    // Save run state after combat victory (loot, gold, round progress)
    saveRun();

    // Apply Chapter transition after Chapter bosses (rounds 9, 18, 27, etc.)
    if(isChapterBoss){
      S.currentChapter++;

      // Chapter completion bonus - gold only (AP bonus removed since skill tree provides permanent progression)
      const chapterGoldBonus = 25 + (S.currentChapter * 15); // 40g, 55g, 70g...
      S.gold += chapterGoldBonus;
      checkTreasureHunterAchievement();

      // Hide result screen and combat overlay before showing fullscreen chapter celebration
      const resultOverlay = document.getElementById('combat-result');
      if(resultOverlay) resultOverlay.classList.remove('show');
      const combatOvl = document.getElementById('combat-overlay');
      if(combatOvl) combatOvl.classList.remove('show', 'combat-reveal', 'combat-result', 'combat-exit');
      // Spotlight stays at full black, will be removed after celebration
      await showChapterCelebration(S.currentChapter, chapterGoldBonus);
      // Fade out spotlight after celebration
      if(spotlightTint) {
        spotlightTint.classList.remove('full');
        await dly(RHYTHM.EIGHTH);
        spotlightTint.classList.remove('show');
      }

      return; // Don't proceed to talent select here - celebration handles it
    }

    // Show talent selection after victories
    // Chapter Boss (rounds 9, 18, 27...): Pick 2 of 5 AFTER the boss (handled here)
    // Miniboss (rounds 3, 6, 12, 15...): Pick 1 of 3
    if(isChapterBoss){
      await showTalentSelect(5, 2, true); // Pass isChapterBoss=true
    } else if(isBoss){
      await showTalentSelect(3, 1, false); // Miniboss: 3 choices, pick 1
    } else {
      // Onboarding completion after first victory
      if (ONBOARD.active && S.roundIndex === 2) {
        await showOnboardingComplete();
        // Wait for onboarding overlay fade-out (0.4s) before shop transition
        await new Promise(r => setTimeout(r, RHYTHM.BEAT));
      }
      // Screen is already black (spotlight tint full) - skip showShop's transition
      // and let spotlight tint fade out after shop appears
      await showShop(true);
      // Fade out spotlight tint smoothly
      if (spotlightTint) {
        spotlightTint.classList.remove('full');
        await dly(RHYTHM.EIGHTH);
        spotlightTint.classList.remove('show');
      }
    }
  }else{
    // Defeat: check if hero has lives remaining
    S.lives--;
    if(S.lives > 0){
      // Hero has extra lives (Paladin passive) - continue the run
      // Clear state for fresh encounter
      clrSel();
      S.roundIndex++; // Progress to next round

      // Track highest round reached
      const currentRound = S.roundIndex - 1;
      if(!PStats.highestRound || currentRound > PStats.highestRound){
        PStats.highestRound = currentRound;
        saveStats();
      }

      newEnc(); // Generate new enemy
      // Screen is already black (spotlight tint full) - skip showShop's transition
      await showShop(true);
      // Fade out spotlight tint smoothly
      if (spotlightTint) {
        spotlightTint.classList.remove('full');
        await dly(RHYTHM.EIGHTH);
        spotlightTint.classList.remove('show');
      }
    } else {
      // Run ends - no lives remaining
      S.losses++;S.streak=0;
      S.heroSelected=false;
      clearRunSave();

      // Award XP to hero for this run (on loss)
      let xpGained = 0;
      let leveledUp = false;
      let newLevel = 1;
      const heroName = S.hero?.name || 'Hero';
      if (S.hero && S.hero.name) {
        xpGained = calcRunXP(S.roundIndex, false);
        const result = awardHeroXP(S.hero.name, xpGained);
        leveledUp = result.leveledUp;
        newLevel = result.newLevel;
        // Store for display on main menu if desired
        S.lastRunXP = { xp: xpGained, ...result };
      }

      // Stop arpeggiatos when player dies
      stopAllRarityDrones();

      // Trigger lose music effect (slow down + fade out)
      if (musicEngine && musicEngine.initialized) {
        musicEngine.triggerLoseEffect();
      }

      // Show loss screen with XP gained
      clrSel();
      showLossScreen(heroName, S.roundIndex, xpGained, leveledUp, newLevel);
    }
  }
}

const TALENT_CAP = 6; // Maximum number of talents a player can have

// Get talent level (returns 1 if not upgraded)
function getTalentLevel(talentId) {
  return (S.talentLevels && S.talentLevels[talentId]) || 1;
}

// Set talent level
function setTalentLevel(talentId, level) {
  if (!S.talentLevels) S.talentLevels = {};
  S.talentLevels[talentId] = level;
}

// Upgrade a random talent and return its info
function upgradeRandomTalent() {
  if (!S.talents || S.talents.length === 0) return null;
  const randomIndex = Math.floor(Math.random() * S.talents.length);
  const talentId = S.talents[randomIndex];
  const talent = TALENTS.find(t => t.id === talentId);
  const oldLevel = getTalentLevel(talentId);
  const newLevel = oldLevel + 1;
  setTalentLevel(talentId, newLevel);
  return { talent, oldLevel, newLevel };
}

// Mass upgrade all existing talents by +1 level (used for chapter boss victories)
function massUpgradeAllTalents() {
  if (!S.talents || S.talents.length === 0) return [];

  const upgradedTalents = [];
  S.talents.forEach(talentId => {
    const talent = TALENTS.find(t => t.id === talentId);
    const oldLevel = getTalentLevel(talentId);
    const newLevel = oldLevel + 1;
    setTalentLevel(talentId, newLevel);
    upgradedTalents.push({ talent, oldLevel, newLevel });
  });

  return upgradedTalents;
}

// Scale a talent bonus by its level (linear scaling)
function scaleTalentBonus(talentId, baseValue) {
  const level = getTalentLevel(talentId);
  return baseValue * level;
}

// Scale a talent multiplier by its level (additive stacking: base mult + (level-1) * bonus)
// e.g., √ó2 at Lv.1 becomes √ó2.5 at Lv.2, √ó3 at Lv.3 (adds 0.5 per level)
function scaleTalentMult(talentId, baseMult) {
  const level = getTalentLevel(talentId);
  if (level <= 1) return baseMult;
  // Add 25% of the bonus portion per extra level (more incremental scaling)
  const bonusPortion = baseMult - 1.0;
  return baseMult + (level - 1) * (bonusPortion * 0.25);
}

async function showTalentSelect(numChoices = 5, numPicks = 2, isChapterBoss = false){
  // Talent selection after boss victories
  // Miniboss (R3, R6, R12, R15...): Pick 1 of 3 (can upgrade existing or pick new)
  // Chapter Boss (R9, R18, R27...): ALL existing talents mass upgrade +1, then pick 2 of 5

  // Ensure S.talents is initialized
  if (!S.talents) S.talents = [];

  // Chapter Boss Mass Upgrade System
  // isChapterBoss is passed from caller (checked before roundIndex is incremented)

  // If chapter boss and player has existing talents, mass upgrade them all +1 level
  if (isChapterBoss && S.talents.length > 0) {
    const upgradedTalents = massUpgradeAllTalents();

    // Show visual card animation for mass upgrade
    if (upgradedTalents.length > 0) {
      // Create overlay for the animation
      const upgradeOverlay = document.createElement('div');
      upgradeOverlay.className = 'mass-upgrade-overlay';
      upgradeOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        opacity: 0;
        transition: opacity 0.3s ease;
      `;

      // Header
      const header = document.createElement('div');
      header.style.cssText = `
        color: #fbbf24;
        font-size: 24px;
        font-weight: bold;
        margin-bottom: 8px;
        letter-spacing: 0.15em;
        text-shadow: 0 0 20px rgba(251, 191, 36, 0.5);
      `;
      header.textContent = 'CHAPTER BOSS REWARD';
      upgradeOverlay.appendChild(header);

      // Subheader
      const subheader = document.createElement('div');
      subheader.style.cssText = `
        color: #9ca3af;
        font-size: 14px;
        margin-bottom: 24px;
      `;
      subheader.textContent = 'All talents upgraded +1 level!';
      upgradeOverlay.appendChild(subheader);

      // Cards container
      const cardsContainer = document.createElement('div');
      cardsContainer.style.cssText = `
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 16px;
        max-width: 900px;
        padding: 0 20px;
      `;

      // Create cards for each upgraded talent
      upgradedTalents.forEach(({talent, oldLevel, newLevel}, index) => {
        if (!talent) return;

        const tierClass = talent.rarity === 'rare' ? 'tier-3' : talent.rarity === 'uncommon' ? 'tier-2' : 'tier-1';
        const rarityLabel = talent.rarity === 'rare' ? 'T3' : talent.rarity === 'uncommon' ? 'T2' : 'T1';

        const card = document.createElement('div');
        card.className = `talent-card ${tierClass}`;
        card.style.cssText = `
          width: 130px;
          height: 200px;
          opacity: 0;
          transform: translateY(50px) scale(0.9);
          transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        `;

        card.innerHTML = `
          <div class="talent-card-inner">
            <div class="talent-card-face talent-card-front" style="
              display: flex;
              flex-direction: column;
              align-items: center;
              justify-content: center;
              border-radius: 10px;
              background: linear-gradient(135deg, #1a1f2e, #0f1419);
              border: 2px solid #fbbf24;
            ">
              <div style="font-size:40px;opacity:0.6">‚¨Ü</div>
              <div style="font-size:11px;color:#fbbf24;margin-top:8px;font-weight:600">UPGRADE</div>
            </div>
            <div class="talent-card-face talent-card-back ${tierClass}" style="
              transform: rotateY(180deg);
              padding: 14px 10px;
              display: flex;
              flex-direction: column;
              align-items: center;
              border-radius: 10px;
              overflow: hidden;
            ">
              <div class="talent-card-icon" style="width:48px;height:62px;margin-bottom:10px;flex-shrink:0">${getTalentSVG(talent.id)}</div>
              <div class="talent-card-name" style="font-size:12px;text-align:center;margin-bottom:6px;line-height:1.2;font-weight:600">${talent.name}</div>
              <span class="talent-card-rarity-badge" style="font-size:8px;margin-bottom:10px;padding:2px 6px">${rarityLabel}</span>
              <div style="
                background: linear-gradient(135deg, rgba(251, 191, 36, 0.2), rgba(245, 158, 11, 0.1));
                border: 1px solid rgba(251, 191, 36, 0.4);
                border-radius: 8px;
                padding: 8px 12px;
                text-align: center;
                margin-top: auto;
                width: 100%;
                box-sizing: border-box;
              ">
                <div style="font-size:14px;font-weight:bold;color:#fbbf24;text-shadow:0 0 10px rgba(251,191,36,0.5)">
                  Lv.${oldLevel} ‚Üí Lv.${newLevel}
                </div>
              </div>
            </div>
          </div>
        `;

        cardsContainer.appendChild(card);
      });

      // Instruction text
      const instruction = document.createElement('div');
      instruction.style.cssText = `
        color: #6b7280;
        font-size: 12px;
        margin-bottom: 16px;
      `;
      instruction.textContent = 'Click each card to reveal upgrade';
      upgradeOverlay.appendChild(instruction);

      upgradeOverlay.appendChild(cardsContainer);

      // Continue button (hidden until all cards clicked)
      const continueBtn = document.createElement('button');
      continueBtn.style.cssText = `
        margin-top: 24px;
        padding: 12px 32px;
        font-size: 14px;
        font-weight: 600;
        background: linear-gradient(135deg, #854d0e, #713f12);
        border: 2px solid #ca8a04;
        border-radius: 8px;
        color: #fef08a;
        cursor: pointer;
        opacity: 0;
        transform: translateY(20px);
        transition: all 0.3s ease;
        pointer-events: none;
      `;
      continueBtn.textContent = 'Continue';
      upgradeOverlay.appendChild(continueBtn);

      document.body.appendChild(upgradeOverlay);

      // Fade in overlay
      await dly(50);
      upgradeOverlay.style.opacity = '1';
      await dly(RHYTHM.HALF);

      // Show cards face-down first
      const cards = cardsContainer.querySelectorAll('.talent-card');
      let revealedCount = 0;

      // Make cards visible (but still face-down visually via CSS)
      for (let i = 0; i < cards.length; i++) {
        const card = cards[i];
        card.style.opacity = '1';
        card.style.transform = 'translateY(0) scale(1)';
        card.classList.remove('flipped'); // Start face-down
        card.style.cursor = 'pointer';
        await dly(RHYTHM.QUARTER);
      }
      try { playSample('whoosh.ogg', 0.4); } catch(e){}

      // Wait for all cards to be clicked
      await new Promise(resolve => {
        cards.forEach((card, index) => {
          card.onclick = async () => {
            if (card.classList.contains('flipped')) return; // Already revealed

            // Flip the card
            card.classList.add('flipped');
            card.style.boxShadow = '0 0 30px rgba(251, 191, 36, 0.6), 0 0 60px rgba(251, 191, 36, 0.3)';
            card.style.cursor = 'default';

            // Play skill-up sound (matches hero upgrade feel)
            try { playSfxSkillUp(); } catch(e){}

            // Get talent rarity for burst effect
            const talentData = upgradedTalents[index];
            const rarity = talentData?.talent?.rarity || 'common';

            // Burst sparks with rarity-based colors
            const rect = card.getBoundingClientRect();
            rarityBurst(rect.left + rect.width/2, rect.top + rect.height/2, rarity);

            revealedCount++;

            // All revealed - show continue button
            if (revealedCount === cards.length) {
              await dly(RHYTHM.BEAT);
              instruction.style.opacity = '0';
              continueBtn.style.opacity = '1';
              continueBtn.style.transform = 'translateY(0)';
              continueBtn.style.pointerEvents = 'auto';
              continueBtn.onmouseenter = () => { try { playSfxHover(); } catch(e){} };
              continueBtn.onclick = () => {
                try { playSample('click.ogg', 0.5); } catch(e){}
                resolve();
              };
            }
          };
        });
      });

      // Fade out and remove
      upgradeOverlay.style.opacity = '0';
      await dly(300);
      upgradeOverlay.remove();
    }
  }

  const availableTalents = TALENTS.filter(t => !S.talents.includes(t.id) && !t.disabled);

  if(availableTalents.length === 0){
    // No more talents to choose from, go to shop
    showShop();
    return;
  }

  // Weighted random selection based on rarity
  // Common: 50%, Uncommon: 35%, Rare: 15%
  const RARITY_WEIGHTS = { common: 50, uncommon: 35, rare: 15 };
  function weightedTalentPick(pool, count) {
    const result = [];
    const remaining = [...pool];
    for (let i = 0; i < count && remaining.length > 0; i++) {
      // Calculate total weight of remaining talents
      const totalWeight = remaining.reduce((sum, t) => sum + (RARITY_WEIGHTS[t.rarity] || 15), 0);
      let roll = Math.random() * totalWeight;
      let picked = null;
      for (let j = 0; j < remaining.length; j++) {
        roll -= (RARITY_WEIGHTS[remaining[j].rarity] || 15);
        if (roll <= 0) {
          picked = remaining.splice(j, 1)[0];
          break;
        }
      }
      if (picked) result.push(picked);
    }
    return result;
  }

  // Track state for this selection instance
  let hasRerolled = false;
  const isAtCap = S.talents && S.talents.length >= TALENT_CAP;
  // Offer talents based on boss type (or fewer if not enough available)
  const numToShow = Math.min(numChoices, availableTalents.length);
  // Allow full picks even when at cap (swaps count as picks)
  const maxPicks = Math.min(numPicks, numToShow);
  let currentChoices = weightedTalentPick(availableTalents, numToShow);
  let selectedTalents = []; // Track which talents have been selected
  let pendingSwapTalent = null; // For swap mode: the new talent waiting to replace an existing one

  $("#talent-level").textContent = S.level;

  // Show/hide "Talents" button and update count based on whether player has talents
  const viewTalentsBtn = document.getElementById('talent-select-view-btn');
  const talentSelectCount = document.getElementById('talent-select-count');
  if(viewTalentsBtn){
    const talentCount = S.talents ? S.talents.length : 0;
    viewTalentsBtn.style.display = talentCount > 0 ? 'block' : 'none';
    if(talentSelectCount) talentSelectCount.textContent = talentCount;
  }

  const container = $("#talent-choices");
  if(!container){
    console.error('[showTalentSelect] #talent-choices not found, falling back to shop');
    showShop();
    return;
  }
  const rarityLabelMap = {common: 'T1', uncommon: 'T2', rare: 'T3'};

  // Helper to update pick counter display
  function updatePickCounter(){
    const counterEl = document.getElementById('talent-pick-counter');
    if(counterEl){
      const remaining = maxPicks - selectedTalents.length;
      counterEl.textContent = remaining > 0 ? `Pick ${remaining} more` : 'Done!';
    }
  }

  // Helper function to render talent cards
  async function renderTalentCards(choices, animate = true){
    // Re-query container in case DOM changed
    const renderContainer = $("#talent-choices");
    if(!renderContainer){
      console.error('[renderTalentCards] #talent-choices not found');
      return;
    }
    // Reset any stale styles from previous render cycles
    renderContainer.style.transition = "";
    renderContainer.style.opacity = "";
    renderContainer.innerHTML = "";

    // Add pick counter (shows remaining picks or swap mode)
    const pickCounter = document.createElement("div");
    pickCounter.id = "talent-pick-counter";
    pickCounter.className = "talent-pick-counter";
    const remaining = maxPicks - selectedTalents.length;
    if(isAtCap && !pendingSwapTalent){
      pickCounter.textContent = `Talents Full - Pick one to swap`;
    } else if(pendingSwapTalent){
      pickCounter.textContent = 'Select a talent to replace';
    } else {
      // Show "Pick or Upgrade" to hint at flexibility
      if (remaining > 1) {
        pickCounter.innerHTML = `Pick <span style="color:#fbbf24">${remaining}</span> ‚Äî <span style="color:#9ca3af;font-size:0.9em">New talent or Upgrade</span>`;
      } else if (remaining === 1) {
        pickCounter.innerHTML = `Pick <span style="color:#fbbf24">1</span> more`;
      } else {
        pickCounter.textContent = 'Done!';
      }
    }
    renderContainer.appendChild(pickCounter);

    // Create cards row wrapper to keep cards centered
    const cardsRow = document.createElement("div");
    cardsRow.className = "talent-cards-row";

    // Create card elements
    const cardElements = [];
    choices.forEach((talent, index) => {
      const rarityLabel = rarityLabelMap[talent.rarity] || 'T1';

      // For per-round and per-chapter talents, show the accumulated total with badges
      const sampleCtx = {
        state: S,
        hero: S.hero,
        enemy: S.enemy,
        weapon: S.sel.item,
        allWords: Object.values(S.sel).filter(Boolean),
        sel: S.sel
      };
      let accumulatedTotal = '';
      let overrideDesc = ''; // For talents that need dynamic description based on game state
      if(talent.desc){
        const descLower = talent.desc.toLowerCase();
        const isWordCountTalent = talent.category === 'word_count_bonus';
        // Exclude talents with specific handlers from generic pattern matching
        const hasSpecificHandler = ['momentum', 'word_historian', 'reverberation'].includes(talent.id);
        if(descLower.includes('per round') && !hasSpecificHandler){
          const round = S.roundIndex || 1;
          const match = talent.desc.match(/\+(\d+\.?\d*)/);
          if(match){
            const baseValue = parseFloat(match[1]);
            const total = baseValue * round;
            const totalVal = total % 1 === 0 ? total : parseFloat(total.toFixed(1));
            const badge = isWordCountTalent ? fmtMod(totalVal, 'word', ' W') : fmtMod(totalVal, 'ap', ' AP');
            const perWord = descLower.includes('each') ? '/Word' : '';
            accumulatedTotal = `<div style="font-size:10px;margin-top:6px">Round ${round} this run: ${badge}${perWord}</div>`;
          }
        } else if(descLower.includes('per chapter')){
          const chapter = (S.currentChapter || 0) + 1;
          const match = talent.desc.match(/\+(\d+\.?\d*)/);
          if(match){
            const baseValue = parseFloat(match[1]);
            const total = chapterScale(baseValue, chapter);
            const totalVal = total % 1 === 0 ? total : parseFloat(total.toFixed(1));
            const badge = isWordCountTalent ? fmtMod(totalVal, 'word', ' W') : fmtMod(totalVal, 'ap', ' AP');
            accumulatedTotal = `<div style="font-size:10px;margin-top:6px">Chapter ${chapter} this run: ${badge}</div>`;
          }
        } else if(talent.id === 'anthology'){
          // Special case: Anthology shows unique words used
          const uniqueCount = S.uniqueWordsUsed ? S.uniqueWordsUsed.size : 0;
          const totalW = Math.min(uniqueCount * 0.5, 10);
          const totalVal = totalW % 1 === 0 ? totalW : parseFloat(totalW.toFixed(1));
          const badge = fmtMod(totalVal, 'word', ' W');
          accumulatedTotal = `<div style="font-size:10px;margin-top:6px">${uniqueCount} unique words: ${badge}/Word</div>`;
        } else if(talent.id === 'bibliography'){
          // Bibliography: +2 AP per word per boss defeated
          const bossCount = S.bossesDefeated || 0;
          const perWordAP = 2 * bossCount;
          const badge = fmtMod(perWordAP, 'ap', ' AP');
          accumulatedTotal = `<div style="font-size:10px;margin-top:6px">${bossCount} bosses = ${badge}/Word</div>`;
        } else if(talent.id === 'lexicon_growth'){
          // Lexicon Growth: +1 W per word per boss defeated
          const bossCount = S.bossesDefeated || 0;
          const badge = bossCount === 0
            ? '<span class="mod-badge word">+0 W</span>'
            : fmtMod(bossCount, 'word', ' W');
          accumulatedTotal = `<div style="font-size:10px;margin-top:6px">${bossCount} bosses: ${badge}/Word</div>`;
        } else if(talent.category === 'economy' && talent.goldBonus){
          // Economy talents with goldBonus: show current gold bonus
          try {
            const talentCtx = {
              state: S,
              hero: S.hero,
              enemy: S.enemy,
              allWords: Object.values(S.sel).filter(Boolean)
            };
            const goldAmt = talent.goldBonus(talentCtx);
            if(goldAmt > 0){
              accumulatedTotal = `<div style="font-size:10px;margin-top:6px;color:#fbbf24">This run: <span style="font-weight:bold">+${goldAmt}g</span></div>`;
            } else {
              accumulatedTotal = `<div style="font-size:10px;margin-top:6px;color:#6b7280">No bonus yet</div>`;
            }
          } catch(e) {}
        } else if(talent.category === 'word_count_bonus'){
          const wc = talent.apply(sampleCtx) || 0;
          if(wc > 0){
            const val = wc % 1 === 0 ? wc : parseFloat(wc.toFixed(1));
            const badge = fmtMod(val, 'word', ' W');
            accumulatedTotal = `<div style="font-size:10px;margin-top:6px">Current: ${badge}</div>`;
          }
        } else if(talent.id === 'quality_control'){
          // Quality Control: +0.1 AP per Word per Rarity Word played
          const rarityUsed = S.rarityWordsUsed || 0;
          const totalAP = rarityUsed * 0.1;
          const totalVal = totalAP % 1 === 0 ? totalAP : parseFloat(totalAP.toFixed(1));
          const badge = fmtMod(totalVal, 'ap', ' AP');
          accumulatedTotal = `<div style="font-size:10px;margin-top:6px">${rarityUsed} rarity words: ${badge}/Word</div>`;
        } else if(talent.id === 'grassroots'){
          // Grassroots: +0.05 AP per Word per T1 Word played
          const t1Played = S.tierWordsPlayed?.[1] || 0;
          const totalAP = t1Played * 0.05;
          const totalVal = totalAP % 1 === 0 ? totalAP : parseFloat(totalAP.toFixed(2));
          const badge = fmtMod(totalVal, 'ap', ' AP');
          accumulatedTotal = `<div style="font-size:10px;margin-top:6px">${t1Played} T1 words: ${badge}/Word</div>`;
        } else if(talent.id === 'intermediate'){
          // Intermediate: +0.1 AP per Word per T2 Word played
          const t2Played = S.tierWordsPlayed?.[2] || 0;
          const totalAP = t2Played * 0.1;
          const totalVal = totalAP % 1 === 0 ? totalAP : parseFloat(totalAP.toFixed(1));
          const badge = fmtMod(totalVal, 'ap', ' AP');
          accumulatedTotal = `<div style="font-size:10px;margin-top:6px">${t2Played} T2 words: ${badge}/Word</div>`;
        } else if(talent.id === 'masterwork'){
          // Masterwork: +0.2 AP per Word per T3 Word played - scales with level
          const t3Played = S.tierWordsPlayed?.[3] || 0;
          const basePerT3 = scaleTalentBonus('masterwork', 0.2);
          const totalAP = t3Played * basePerT3;
          const totalVal = totalAP % 1 === 0 ? totalAP : parseFloat(totalAP.toFixed(1));
          const badge = fmtMod(totalVal, 'ap', ' AP');
          const levelText = getTalentLevel('masterwork') > 1 ? ` (Lv.${getTalentLevel('masterwork')})` : '';
          accumulatedTotal = `<div style="font-size:10px;margin-top:6px">${t3Played} T3 words: ${badge}/Word${levelText}</div>`;
        } else if(talent.id === 'adaptive_arsenal'){
          // Adaptive Arsenal: +0.5 W per Word per unique weapon used - scales with level
          const usedWeapons = S.usedWeapons || new Set();
          const weaponCount = usedWeapons.size;
          const basePerWeapon = scaleTalentBonus('adaptive_arsenal', 0.5);
          const totalW = Math.min(weaponCount, 12) * basePerWeapon;
          const totalVal = totalW % 1 === 0 ? totalW : parseFloat(totalW.toFixed(1));
          const badge = fmtMod(totalVal, 'word', ' W');
          const levelText = getTalentLevel('adaptive_arsenal') > 1 ? ` (Lv.${getTalentLevel('adaptive_arsenal')})` : '';
          accumulatedTotal = `<div style="font-size:10px;margin-top:6px">${weaponCount} weapons: ${badge}/Word${levelText}</div>`;
        } else if(talent.id === 'word_hoard'){
          // Word Hoard: +0.2 W per Word in inventory - scales with level
          const invCount = (S.inv || []).filter(w => !w.hiddenInBank).length;
          const basePerWord = scaleTalentBonus('word_hoard', 0.2);
          const bonus = Math.floor(invCount * basePerWord * 10) / 10;
          const badge = fmtMod(bonus, 'word', ' W');
          const levelText = getTalentLevel('word_hoard') > 1 ? ` (Lv.${getTalentLevel('word_hoard')})` : '';
          accumulatedTotal = `<div style="font-size:10px;margin-top:6px">${invCount} words √ó ${basePerWord} = ${badge}${levelText}</div>`;
        } else if(talent.id === 'momentum'){
          // Momentum: +1 W per Word per round played (max 10) - scales with level
          const roundsPlayed = Math.min((S.roundIndex || 1) - 1, 10);
          const basePerRound = scaleTalentBonus('momentum', 1);
          const bonusPerWord = roundsPlayed * basePerRound;
          const levelText = getTalentLevel('momentum') > 1 ? ` (Lv.${getTalentLevel('momentum')})` : '';
          // Override description to show current total W per word
          overrideDesc = `Each Word: <span class="mod-badge word">+${bonusPerWord} W</span>`;
          accumulatedTotal = `<div style="font-size:10px;margin-top:6px">${basePerRound} W √ó ${roundsPlayed} rounds${levelText}</div>`;
        } else if(talent.id === 'word_historian'){
          // Word Historian: +0.25 W per Word used this run - scales with level
          const wordsUsed = S.wordsUsedThisRun || 0;
          const basePerWord = scaleTalentBonus('word_historian', 0.25);
          const bonus = Math.floor(wordsUsed * basePerWord);
          const badge = bonus > 0 ? fmtMod(bonus, 'word', ' W') : '<span class="mod-badge word">+0 W</span>';
          const levelText = getTalentLevel('word_historian') > 1 ? ` (Lv.${getTalentLevel('word_historian')})` : '';
          accumulatedTotal = `<div style="font-size:10px;margin-top:6px">${wordsUsed} words used: ${badge}${levelText}</div>`;
        } else if(talent.id === 'reverberation'){
          // Reverberation: +2 W per REREAD triggered this run - scales with level
          const rereadsTriggered = S.rereadTriggersThisRun || 0;
          const basePerReread = scaleTalentBonus('reverberation', 2);
          const bonus = rereadsTriggered * basePerReread;
          const badge = bonus > 0 ? fmtMod(bonus, 'word', ' W') : '<span class="mod-badge word">+0 W</span>';
          const levelText = getTalentLevel('reverberation') > 1 ? ` (Lv.${getTalentLevel('reverberation')})` : '';
          accumulatedTotal = `<div style="font-size:10px;margin-top:6px">${rereadsTriggered} rereads: ${badge}${levelText}</div>`;
        } else if(talent.id === 'verbose_surplus'){
          // Verbose Surplus: +10 W per word √ó word count (quadratic)
          const basePerWord = scaleTalentBonus('verbose_surplus', 10);
          const badge = fmtMod(basePerWord, 'word', ' W');
          const levelText = getTalentLevel('verbose_surplus') > 1 ? ` (Lv.${getTalentLevel('verbose_surplus')})` : '';
          accumulatedTotal = `<div style="font-size:10px;margin-top:6px">Bonus: ${badge} √ó Words √ó Words${levelText}</div>`;
        } else if(talent.id === 'linguistic_density'){
          // Linguistic Density: +5 W per word per word (4+ words)
          const basePerWord = scaleTalentBonus('linguistic_density', 5);
          const badge = fmtMod(basePerWord, 'word', ' W');
          const levelText = getTalentLevel('linguistic_density') > 1 ? ` (Lv.${getTalentLevel('linguistic_density')})` : '';
          accumulatedTotal = `<div style="font-size:10px;margin-top:6px">4+ Words: ${badge} √ó Word count¬≤${levelText}</div>`;
        } else if(talent.id === 'elemental_mastery'){
          // Elemental Mastery: Track accumulated elemental W
          const elementalW = S.elementalWBonus || 0;
          const badge = fmtMod(elementalW, 'word', ' W');
          accumulatedTotal = `<div style="font-size:10px;margin-top:6px">Accumulated: ${badge}</div>`;
        } else if(talent.id === 'prismatic_resonance'){
          // Prismatic Resonance: √ó1.2 per 5 Elemental W
          const elementalW = S.elementalWBonus || 0;
          const tiers = Math.floor(elementalW / 5);
          const scaledMult = scaleTalentMult('prismatic_resonance', 1.2);
          const mult = tiers > 0 ? Math.pow(scaledMult, tiers) : 1;
          const badge = fmtMod(mult, 'scale');
          const levelText = getTalentLevel('prismatic_resonance') > 1 ? ` (Lv.${getTalentLevel('prismatic_resonance')})` : '';
          accumulatedTotal = `<div style="font-size:10px;margin-top:6px">${elementalW}W √∑ 5 = ${tiers} tiers = ${badge}${levelText}</div>`;
        } else if(talent.id === 'weakness_exploit_amp'){
          // Weakness Exploit Amp: +4 W per weakness hit
          const elementalW = S.elementalWBonus || 0;
          const badge = fmtMod(elementalW, 'word', ' W');
          accumulatedTotal = `<div style="font-size:10px;margin-top:6px">Accumulated: ${badge}</div>`;
        } else if(talent.id === 'overflow'){
          // Overflow: Per 10 W above 50 ‚Üí √ó1.5
          const slots = Object.values(S.sel).filter(Boolean);
          const baseW = slots.reduce((sum, w) => sum + (w.word?.length || w.name?.length || 0), 0);
          if(baseW > 50){
            const excessW = baseW - 50;
            const stacks = Math.floor(excessW / 10);
            const mult = Math.pow(1.5, stacks);
            const multRound = Math.round(mult * 100) / 100;
            accumulatedTotal = `<div style="font-size:10px;margin-top:6px;color:#4ade80">~${baseW} W: ${stacks} stacks = <span class="mod-badge scale">√ó${multRound}</span></div>`;
          } else {
            accumulatedTotal = `<div style="font-size:10px;margin-top:6px;color:#6b7280">~${baseW} W (need 50+)</div>`;
          }
        } else if(talent.category === 'threshold' && talent.apply){
          // Threshold talents: show current multiplier if active
          try {
            const value = talent.apply(sampleCtx);
            if(value > 1){
              const v = Math.round(value * 10) / 10;
              accumulatedTotal = `<div style="font-size:10px;margin-top:6px;color:#4ade80">Active now: <span class="mod-badge scale">√ó${v}</span></div>`;
            } else {
              // Show condition not met
              accumulatedTotal = `<div style="font-size:10px;margin-top:6px;color:#6b7280">Not active yet</div>`;
            }
          } catch(e) {}
        }
      }

      // Create card structure
      const card = document.createElement("div");
      card.className = "talent-card";
      card.dataset.talentId = talent.id;

      card.innerHTML = `
        <div class="talent-card-inner">
          <div class="talent-card-face talent-card-front">
            <div class="talent-card-front-content">
              <div class="talent-card-front-text">Talent</div>
            </div>
          </div>
          <div class="talent-card-face talent-card-back tier-${talent.rarity === 'rare' ? '3' : talent.rarity === 'uncommon' ? '2' : '1'}">
            <div class="talent-card-icon">${getTalentSVG(talent.id)}</div>
            <div class="talent-card-header">
              <div class="talent-card-name">${talent.name}</div>
              <span class="talent-card-rarity-badge">${rarityLabel}</span>
            </div>
            <div class="talent-card-desc">${overrideDesc || formatTalentDesc(talent)}</div>
            ${accumulatedTotal}
            ${talent.flavor ? `<div class="talent-card-flavor"><em>${talent.flavor}</em></div>` : ''}
          </div>
        </div>
      `;

      // Add click handler
      card.onclick = async () => {
        // Prevent clicks before card is flipped
        if(!card.classList.contains('flipped')) return;
        // Prevent clicking already selected cards
        if(card.classList.contains('selecting')) return;
        // Prevent selection if max picks reached (unless at cap doing swap)
        if(selectedTalents.length >= maxPicks && !isAtCap) return;
        // If already in swap mode (pendingSwapTalent set), ignore new card clicks
        if(pendingSwapTalent) return;

        card.classList.add('selecting', 'selected');
        selectedTalents.push(talent.id);

        // Create Fizzy Sparks burst based on rarity
        const rect = card.getBoundingClientRect();
        const x = rect.left + rect.width / 2;
        const y = rect.top + rect.height / 2;
        rarityBurst(x, y, talent.rarity || 'common');

        // Play skill-up arpeggio sound (matches hero upgrade feel)
        try{
          playSfxSkillUp();
        }catch(err){}

        // Check if currently at cap (dynamic check to handle multiple picks in one session)
        const currentlyAtCap = S.talents && S.talents.length >= TALENT_CAP;

        // If at cap, enter swap mode - show existing talents to replace
        if(currentlyAtCap){
          pendingSwapTalent = talent;
          await dly(RHYTHM.BEAT);
          await showSwapSelection(talent);
          return;
        }

        // Add talent to player's talents immediately so they can view it
        if(!S.talents) S.talents = [];
        S.talents.push(talent.id);

        // Update pick counter
        updatePickCounter();

        // Check if all picks are done
        if(selectedTalents.length >= maxPicks){
          // Wait for animation
          await dly(RHYTHM.BEAT);

          // Save run state after talent selection (prevents losing talent picks on crash)
          saveRun();

          // Brief pause to let selection animation settle
          await dly(RHYTHM.QUARTER);

          // Unified transition: hide talent overlay AND show shop at peak
          await playSceneTransition(async () => {
            $("#talent-overlay").classList.remove("show");
            await showShop(true); // Set up shop while screen is black
          });
        }
      };

      cardsRow.appendChild(card);
      cardElements.push(card);
    });

    // Add the cards row to container
    renderContainer.appendChild(cardsRow);

    // Add button container (reroll + skip)
    const rerollContainer = document.createElement("div");
    rerollContainer.className = "talent-reroll-container";

    // Add reroll button (always show, grey out when used)
    const rerollBtn = document.createElement("button");
    rerollBtn.className = "talent-reroll-btn" + (hasRerolled ? " used" : "");
    rerollBtn.textContent = hasRerolled ? "Rerolled" : "Reroll";
    rerollBtn.disabled = hasRerolled;
    rerollBtn.title = "See new talents (disables upgrades)";

    // References to upgrade button and "or" connector (set later) so reroll can disable/hide them
    let upgradeBtnRef = null;
    let orConnectorRef = null;

    rerollBtn.onclick = async () => {
      if(hasRerolled) return;
      hasRerolled = true;

      // Disable and update button immediately
      rerollBtn.disabled = true;
      rerollBtn.classList.add("used");
      rerollBtn.textContent = "Rerolled";

      // Disable upgrade button and hide "or" connector - reroll means no upgrades
      if (orConnectorRef) {
        orConnectorRef.style.display = "none";
      }
      if (upgradeBtnRef) {
        upgradeBtnRef.disabled = true;
        upgradeBtnRef.classList.add("used");
        upgradeBtnRef.textContent = "Upgrades Disabled";
        upgradeBtnRef.title = "You chose to reroll - upgrades are no longer available";
      }

      // Play reroll sound
      try{
        playTone(440, 0.15, 'sine', 0.2);
        setTimeout(() => playTone(523, 0.15, 'sine', 0.15), RHYTHM.QUARTER);
        setTimeout(() => playTone(659, 0.15, 'sine', 0.1), RHYTHM.HALF);
      }catch(err){}

      // Fade out current cards smoothly
      cardElements.forEach((card, i) => {
        card.style.transition = "opacity 0.2s ease, transform 0.2s ease";
        card.style.opacity = "0";
        card.style.transform = "scale(0.95)";
      });

      await dly(RHYTHM.HALF);

      // Keep already selected talents, generate new choices excluding them
      // Do NOT reset selectedTalents - player keeps their picks
      const newAvailable = TALENTS.filter(t => !S.talents.includes(t.id) && !selectedTalents.includes(t.id) && !t.disabled);
      currentChoices = shuf([...newAvailable]).slice(0, Math.min(numToShow, newAvailable.length));

      // Re-render with new choices (animate new cards)
      await renderTalentCards(currentChoices, true);
    };

    rerollContainer.appendChild(rerollBtn);

    // Add upgrade button - only show if player has at least one talent AND hasn't rerolled
    // Hide upgrade button at chapter bosses since mass upgrade already handles +1 to all talents
    const hasTalentsToUpgrade = S.talents && S.talents.length > 0 && !isChapterBoss;
    if (hasTalentsToUpgrade) {
      // Add "or" connector between Reroll and Upgrade buttons
      const orConnector = document.createElement("span");
      orConnector.className = "connector-phrase";
      orConnector.textContent = "or";
      orConnector.style.cssText = "margin: 0 12px; color: #6b7280; font-size: 14px; align-self: center;";
      if (hasRerolled) orConnector.style.display = "none"; // Hide if already rerolled
      orConnectorRef = orConnector; // Store reference so reroll can hide it
      rerollContainer.appendChild(orConnector);

      const upgradeBtn = document.createElement("button");
      upgradeBtnRef = upgradeBtn; // Store reference so reroll can disable it
      upgradeBtn.className = "talent-skip-btn talent-upgrade-btn" + (hasRerolled ? " used" : "");
      upgradeBtn.textContent = hasRerolled ? "Upgrades Disabled" : `‚¨Ü Upgrade`;
      upgradeBtn.disabled = hasRerolled;
      upgradeBtn.title = hasRerolled ? "You chose to reroll - upgrades are no longer available" : `Upgrade one of your existing talents`;

      upgradeBtn.onclick = async () => {
        // Fade out current talent choice cards
        cardElements.forEach((card, i) => {
          card.style.transition = "opacity 0.3s ease, transform 0.3s ease";
          card.style.opacity = "0";
          card.style.transform = "scale(0.9)";
        });

        await dly(RHYTHM.HALF);

        // Clear container and show owned talent cards for player selection
        renderContainer.innerHTML = "";

        // Create header
        const header = document.createElement("div");
        header.className = "talent-pick-counter";
        header.innerHTML = `<span class="upgrade-header-text">Choose a Talent to Upgrade</span>`;
        renderContainer.appendChild(header);

        // Create row for owned talent cards
        const selectRow = document.createElement("div");
        selectRow.className = "talent-cards-row talent-upgrade-select-row";

        // Build clickable cards for all owned talents
        const ownedCards = [];
        S.talents.forEach((tid, idx) => {
          const t = TALENTS.find(x => x.id === tid);
          if (!t) return;

          const level = getTalentLevel(tid);
          const rarityLabel = t.rarity === 'rare' ? 'Rare' : t.rarity === 'uncommon' ? 'Uncommon' : 'Common';

          const card = document.createElement("div");
          card.className = "talent-card talent-upgrade-selectable flipped";
          card.dataset.talentId = t.id;
          card.dataset.index = idx;

          const levelDisplay = `Lv.${level} ‚Üí Lv.${level + 1}`;
          card.innerHTML = `
            <div class="talent-card-inner">
              <div class="talent-card-face talent-card-front">
                <div class="talent-card-front-content">
                  <div class="talent-card-front-text">Talent</div>
                </div>
              </div>
              <div class="talent-card-face talent-card-back tier-${t.rarity === 'rare' ? '3' : t.rarity === 'uncommon' ? '2' : '1'}">
                <div class="talent-card-icon">${getTalentSVG(t.id)}</div>
                <div class="talent-card-header">
                  <div class="talent-card-name">${t.name}</div>
                  <span class="talent-card-rarity-badge">${rarityLabel}</span>
                </div>
                <div class="talent-level-display talent-level-preview">${levelDisplay}</div>
                <div class="talent-card-desc">${formatTalentDescUpgradePreview(t, tid)}</div>
              </div>
            </div>
          `;

          // Make card clickable
          card.style.cursor = "pointer";
          card.onmouseenter = () => {
            sfxHover();
            card.classList.add('upgrade-hover');
          };
          card.onmouseleave = () => {
            card.classList.remove('upgrade-hover');
          };

          card.onclick = async () => {
            // Prevent double-click
            if (card.classList.contains('upgrade-selected')) return;
            card.classList.add('upgrade-selected');

            // Play selection sound
            try {
              playTone(523, 0.15, 'sine', 0.2);
              setTimeout(() => playTone(659, 0.12, 'sine', 0.15), RHYTHM.QUARTER);
            } catch(err) {}

            // Dim other cards
            ownedCards.forEach(({ card: c }) => {
              if (c !== card) {
                c.classList.add('not-selected');
                c.style.pointerEvents = 'none';
              }
            });

            // Upgrade the selected talent
            const oldLevel = getTalentLevel(tid);
            const newLevel = oldLevel + 1;
            setTalentLevel(tid, newLevel);

            // Count this as a "pick" action
            selectedTalents.push('__upgrade__');

            // Highlight and animate the selected card
            card.classList.add('upgrade-winner');

            await dly(RHYTHM.BEAT);

            // Wiggle animation
            card.classList.add('upgrade-wiggle');

            await dly(RHYTHM.BEAT);

            // Pop and update the card with new level
            card.classList.remove('upgrade-wiggle');
            card.classList.add('upgrade-pop');

            // Update the level display
            const levelDisplayEl = card.querySelector('.talent-level-display');
            if (levelDisplayEl) {
              levelDisplayEl.innerHTML = `<span class="level-old">Lv.${oldLevel}</span> ‚Üí <span class="level-new">Lv.${newLevel}</span>`;
              levelDisplayEl.classList.remove('talent-level-preview');
              levelDisplayEl.classList.add('level-upgraded');
            }

            // Update the description to show new scaled values
            const descEl = card.querySelector('.talent-card-desc');
            if (descEl) {
              descEl.innerHTML = formatTalentDesc(t, tid);
              descEl.classList.add('desc-upgraded');
            }

            // Play upgrade fanfare
            try {
              playTone(523, 0.1, 'sine', 0.15);
              setTimeout(() => playTone(659, 0.1, 'sine', 0.15), RHYTHM.QUARTER);
              setTimeout(() => playTone(784, 0.1, 'sine', 0.15), RHYTHM.HALF);
              setTimeout(() => playTone(1047, 0.2, 'sine', 0.25), RHYTHM.HALF);
            } catch(err) {}

            // Burst effect
            const rect = card.getBoundingClientRect();
            burstSparks(rect.left + rect.width / 2, rect.top + rect.height / 2, 30);

            // Update header
            header.innerHTML = `<span class="upgrade-header-text">${t.name} Upgraded!</span>`;

            await dly(RHYTHM.BAR);

            // Check if more picks remaining
            const picksRemaining = maxPicks - selectedTalents.length;
            if (picksRemaining > 0) {
              // STAY on upgrade screen - reset cards for another upgrade
              // Update header to show remaining picks
              header.innerHTML = `<span class="upgrade-header-text">Choose a Talent to Upgrade (${picksRemaining} left)</span>`;

              // Reset all cards to selectable state
              ownedCards.forEach(({ card: c, talent: t, tid }) => {
                c.classList.remove('not-selected', 'upgrade-selected', 'upgrade-winner', 'upgrade-pop', 'upgrade-hover');
                c.style.pointerEvents = '';
                c.style.cursor = 'pointer';

                // Update level preview for next upgrade
                const level = getTalentLevel(tid);
                const levelEl = c.querySelector('.talent-level-display');
                if (levelEl) {
                  levelEl.innerHTML = `Lv.${level} ‚Üí Lv.${level + 1}`;
                  levelEl.classList.remove('level-upgraded');
                  levelEl.classList.add('talent-level-preview');
                }
                // Update description to show new upgrade preview
                const descEl = c.querySelector('.talent-card-desc');
                if (descEl && t) {
                  descEl.innerHTML = formatTalentDescUpgradePreview(t, tid);
                  descEl.classList.remove('desc-upgraded');
                }
              });

              // Note: Back button is already visible (btnRow) - they can go back to pick a new talent
            } else {
              // All picks done, go to shop
              saveRun();

              // Brief pause to let selection animation settle
              await dly(RHYTHM.QUARTER);

              // Unified transition: hide talent overlay AND show shop at peak
              await playSceneTransition(async () => {
                $("#talent-overlay").classList.remove("show");
                await showShop(true); // Set up shop while screen is black
              });
            }
          };

          ownedCards.push({ card, talent: t, tid });
          selectRow.appendChild(card);
        });

        renderContainer.appendChild(selectRow);

        // Add Back button to return to talent selection
        const backBtnContainer = document.createElement("div");
        backBtnContainer.style.cssText = "display:flex;justify-content:center;margin-top:16px";

        const backBtn = document.createElement("button");
        backBtn.className = "talent-upgrade-back-btn";
        backBtn.textContent = "‚Üê Back to Talents";
        backBtn.onclick = async () => {
          // Play click sound
          try { playTone(440, 0.1, 'sine', 0.15); } catch(err) {}

          // Fade out upgrade cards
          ownedCards.forEach(({ card: c }) => {
            c.style.transition = "opacity 0.2s ease, transform 0.2s ease";
            c.style.opacity = "0";
            c.style.transform = "scale(0.95)";
          });
          backBtn.style.opacity = "0";

          await dly(RHYTHM.HALF);

          // Return to talent selection - re-render with same choices
          await renderTalentCards(currentChoices, false);
        };

        backBtnContainer.appendChild(backBtn);
        renderContainer.appendChild(backBtnContainer);

      };

      rerollContainer.appendChild(upgradeBtn);
    }
    renderContainer.appendChild(rerollContainer);

    // Animate card flips
    if(animate){
      await dly(RHYTHM.HALF); // Initial delay
      for(let i = 0; i < cardElements.length; i++){
        await dly(RHYTHM.HALF); // Stagger delay between cards
        cardElements[i].classList.add('flipped');

        // Play pentatonic scale with higher resolution (3 talents total)
        // Use scale indices: 0, 2, 4 for a nice rising melody ending on root
        try{
          playMagicParseTone(i * 2, cardElements.length, false);
        }catch(err){}
      }

      // Play final root note after all cards are revealed
      try{
        await dly(RHYTHM.HALF);
        playMagicParseTone(5, cardElements.length, false); // Play the root/resolution note
      }catch(err){}
    } else {
      // When not animating (e.g. returning from swap selection), immediately show cards flipped
      cardElements.forEach(card => card.classList.add('flipped'));
    }
  }

  // Show swap selection UI when at talent cap
  async function showSwapSelection(newTalent){
    container.innerHTML = "";

    // Header showing which talent they're swapping in
    const header = document.createElement("div");
    header.className = "talent-pick-counter";
    header.innerHTML = `Swap <strong>${newTalent.name}</strong> for:`;
    container.appendChild(header);

    // Create row for existing talents
    const swapRow = document.createElement("div");
    swapRow.className = "talent-cards-row talent-swap-row";

    // Show all current talents as clickable cards
    S.talents.forEach((tid, index) => {
      const existingTalent = TALENTS.find(t => t.id === tid);
      if(!existingTalent) return;

      const rarityLabel = rarityLabelMap[existingTalent.rarity] || 'T1';

      const card = document.createElement("div");
      card.className = "talent-card talent-swap-card flipped";
      card.dataset.talentId = existingTalent.id;

      card.innerHTML = `
        <div class="talent-card-inner">
          <div class="talent-card-face talent-card-front">
            <div class="talent-card-front-content">
              <div class="talent-card-front-text">Talent</div>
            </div>
          </div>
          <div class="talent-card-face talent-card-back tier-${existingTalent.rarity === 'rare' ? '3' : existingTalent.rarity === 'uncommon' ? '2' : '1'}">
            <div class="talent-card-icon">${getTalentSVG(existingTalent.id)}</div>
            <div class="talent-card-header">
              <div class="talent-card-name">${existingTalent.name}</div>
              <span class="talent-card-rarity-badge">${rarityLabel}</span>
            </div>
            <div class="talent-card-desc">${formatTalentDesc(existingTalent)}</div>
            ${existingTalent.flavor ? `<div class="talent-card-flavor"><em>${existingTalent.flavor}</em></div>` : ''}
          </div>
        </div>
      `;

      card.onclick = async () => {
        if(card.classList.contains('selecting')) return;

        card.classList.add('selecting');

        // Play swap sound
        try{
          playTone(392, 0.15, 'sine', 0.15);
          setTimeout(() => playTone(523, 0.15, 'sine', 0.12), RHYTHM.QUARTER);
          setTimeout(() => playTone(659, 0.2, 'sine', 0.15), RHYTHM.HALF);
        }catch(err){}

        // Perform the swap: remove old, add new
        const removeIdx = S.talents.indexOf(existingTalent.id);
        if(removeIdx > -1){
          S.talents.splice(removeIdx, 1);
        }
        S.talents.push(newTalent.id);

        // Burst effect
        const rect = card.getBoundingClientRect();
        rarityBurst(rect.left + rect.width/2, rect.top + rect.height/2, newTalent.rarity || 'common');

        // Clear swap state
        pendingSwapTalent = null;

        await dly(RHYTHM.BEAT);

        // Check if more picks remaining
        const picksRemaining = maxPicks - selectedTalents.length;
        if (picksRemaining > 0) {
          // Return to talent selection for remaining picks
          // Filter out already selected talents from choices
          currentChoices = currentChoices.filter(t => !selectedTalents.includes(t.id));
          await renderTalentCards(currentChoices, false);
        } else {
          // All picks done - go to shop
          saveRun();

          // Brief pause to let selection animation settle
          await dly(RHYTHM.QUARTER);

          // Unified transition: hide talent overlay AND show shop at peak
          await playSceneTransition(async () => {
            $("#talent-overlay").classList.remove("show");
            await showShop(true); // Set up shop while screen is black
          });
        }
      };

      swapRow.appendChild(card);
    });

    container.appendChild(swapRow);

    // Add button container with Back and Skip options
    const btnContainer = document.createElement("div");
    btnContainer.className = "talent-reroll-container";

    // Back button - return to talent card selection
    const backBtn = document.createElement("button");
    backBtn.className = "talent-reroll-btn";
    backBtn.textContent = "Back";
    backBtn.onclick = async () => {
      // Play back sound
      try{
        playTone(392, 0.15, 'sine', 0.12);
        setTimeout(() => playTone(330, 0.2, 'sine', 0.1), RHYTHM.QUARTER);
      }catch(err){}

      // Reset swap state
      pendingSwapTalent = null;
      selectedTalents = [];

      // Re-render original talent cards
      await renderTalentCards(currentChoices, false);
    };

    // Upgrade button - let player choose which talent to upgrade
    // In swap mode, we already see all 6 talents - make them clickable
    const upgradeBtn = document.createElement("button");
    upgradeBtn.className = "talent-skip-btn talent-upgrade-btn";
    upgradeBtn.textContent = `‚¨Ü Upgrade`;
    upgradeBtn.title = `Upgrade one of your existing talents`;
    upgradeBtn.onclick = async () => {
      // Get all swap card elements
      const swapCards = Array.from(swapRow.querySelectorAll('.talent-swap-card'));

      // Update header to prompt selection
      const headerEl = container.querySelector('.talent-pick-counter');
      if (headerEl) headerEl.innerHTML = `<span class="upgrade-header-text">Choose a Talent to Upgrade</span>`;

      // Hide buttons during selection
      btnContainer.style.display = 'none';

      // Make each card clickable for upgrade
      swapCards.forEach(card => {
        card.classList.add('talent-upgrade-selectable');
        card.style.cursor = 'pointer';

        // Show level preview and update description to show upgrade values
        const tid = card.dataset.talentId;
        const t = TALENTS.find(x => x.id === tid);
        const level = getTalentLevel(tid);
        const levelEl = card.querySelector('.talent-level-display');
        if (levelEl) {
          levelEl.innerHTML = `Lv.${level} ‚Üí Lv.${level + 1}`;
          levelEl.classList.add('talent-level-preview');
        }
        // Update description to show upgrade preview (old ‚Üí new values)
        const descEl = card.querySelector('.talent-card-desc');
        if (descEl && t) {
          descEl.innerHTML = formatTalentDescUpgradePreview(t, tid);
        }

        card.onmouseenter = () => {
          if (!card.classList.contains('upgrade-selected')) {
            sfxHover();
            card.classList.add('upgrade-hover');
          }
        };
        card.onmouseleave = () => {
          card.classList.remove('upgrade-hover');
        };

        card.onclick = async () => {
          // Prevent double-click
          if (card.classList.contains('upgrade-selected')) return;
          card.classList.add('upgrade-selected');

          const tid = card.dataset.talentId;
          const talent = TALENTS.find(t => t.id === tid);

          // Play selection sound
          try {
            playTone(523, 0.15, 'sine', 0.2);
            setTimeout(() => playTone(659, 0.12, 'sine', 0.15), RHYTHM.QUARTER);
          } catch(err) {}

          // Dim other cards
          swapCards.forEach(c => {
            if (c !== card) {
              c.classList.add('not-selected');
              c.style.pointerEvents = 'none';
            }
          });

          // Upgrade the selected talent
          const oldLevel = getTalentLevel(tid);
          const newLevel = oldLevel + 1;
          setTalentLevel(tid, newLevel);

          // Highlight winner
          card.classList.add('upgrade-winner');

          await dly(RHYTHM.BEAT);

          // Wiggle animation
          card.classList.add('upgrade-wiggle');
          await dly(RHYTHM.BEAT);
          card.classList.remove('upgrade-wiggle');
          card.classList.add('upgrade-pop');

          // Update level display in card
          const levelDisplayEl = card.querySelector('.talent-level-display');
          if (levelDisplayEl) {
            levelDisplayEl.innerHTML = `<span class="level-old">Lv.${oldLevel}</span> ‚Üí <span class="level-new">Lv.${newLevel}</span>`;
            levelDisplayEl.classList.remove('talent-level-preview');
            levelDisplayEl.classList.add('level-upgraded');
          }

          // Update description
          const descEl = card.querySelector('.talent-card-desc');
          if (descEl) {
            descEl.innerHTML = formatTalentDesc(talent, tid);
            descEl.classList.add('desc-upgraded');
          }

          // Play upgrade fanfare
          try {
            playTone(523, 0.1, 'sine', 0.15);
            setTimeout(() => playTone(659, 0.1, 'sine', 0.15), RHYTHM.QUARTER);
            setTimeout(() => playTone(784, 0.1, 'sine', 0.15), RHYTHM.HALF);
            setTimeout(() => playTone(1047, 0.2, 'sine', 0.25), RHYTHM.HALF);
          } catch(err) {}

          // Burst effect
          const rect = card.getBoundingClientRect();
          burstSparks(rect.left + rect.width / 2, rect.top + rect.height / 2, 30);

          // Update header
          if (headerEl) headerEl.innerHTML = `<span class="upgrade-header-text">${talent.name} Upgraded!</span>`;

          // Count this as a "pick" action
          selectedTalents.push('__upgrade__');
          pendingSwapTalent = null;

          await dly(RHYTHM.BAR);

          // Check if more picks remaining
          const picksRemaining = maxPicks - selectedTalents.length;
          if (picksRemaining > 0) {
            // STAY on upgrade screen - reset cards for another upgrade
            // Update header to show remaining picks
            if (headerEl) headerEl.innerHTML = `<span class="upgrade-header-text">Choose a Talent to Upgrade (${picksRemaining} left)</span>`;

            // Reset all cards to selectable state
            swapCards.forEach(c => {
              c.classList.remove('not-selected', 'upgrade-selected', 'upgrade-winner', 'upgrade-pop', 'upgrade-hover');
              c.style.pointerEvents = '';
              c.style.cursor = 'pointer';

              // Update level preview for next upgrade
              const tid = c.dataset.talentId;
              const t = TALENTS.find(x => x.id === tid);
              const level = getTalentLevel(tid);
              const levelEl = c.querySelector('.talent-level-display');
              if (levelEl) {
                levelEl.innerHTML = `Lv.${level} ‚Üí Lv.${level + 1}`;
                levelEl.classList.remove('level-upgraded');
                levelEl.classList.add('talent-level-preview');
              }
              // Update description to show new upgrade preview
              const descEl = c.querySelector('.talent-card-desc');
              if (descEl && t) {
                descEl.innerHTML = formatTalentDescUpgradePreview(t, tid);
                descEl.classList.remove('desc-upgraded');
              }
            });

            // Show back button again (they can go back to pick a new talent)
            btnContainer.style.display = '';
          } else {
            // Save run state after upgrade
            saveRun();

            // Brief pause to let selection animation settle
            await dly(RHYTHM.QUARTER);

            // Unified transition: hide talent overlay AND show shop at peak
            await playSceneTransition(async () => {
              $("#talent-overlay").classList.remove("show");
              await showShop(true); // Set up shop while screen is black
            });
          }
        };
      });
    };

    // Skip button - skip this talent selection entirely
    const skipBtn = document.createElement("button");
    skipBtn.className = "talent-skip-btn";
    skipBtn.textContent = "Skip";
    skipBtn.title = "Skip this talent selection";
    skipBtn.onclick = async () => {
      // Play skip sound
      try {
        playTone(330, 0.15, 'sine', 0.12);
        setTimeout(() => playTone(294, 0.2, 'sine', 0.1), RHYTHM.QUARTER);
      } catch(err) {}

      // Clear swap state
      pendingSwapTalent = null;

      // Count this as a "pick" action to consume the selection
      selectedTalents.push('__skip__');

      await dly(RHYTHM.BEAT);

      // Check if more picks remaining
      const picksRemaining = maxPicks - selectedTalents.length;
      if (picksRemaining > 0) {
        // Return to talent selection for remaining picks
        currentChoices = currentChoices.filter(t => !selectedTalents.includes(t.id));
        await renderTalentCards(currentChoices, false);
      } else {
        // All picks done - go to shop
        saveRun();
        await dly(RHYTHM.QUARTER);
        await playSceneTransition(async () => {
          document.getElementById("talent-overlay").classList.remove("show");
          await showShop(true);
        });
      }
    };

    btnContainer.appendChild(backBtn);
    btnContainer.appendChild(upgradeBtn);
    btnContainer.appendChild(skipBtn);
    container.appendChild(btnContainer);
  }

  // Show overlay
  $("#talent-overlay").classList.add("show");

  // Initial render
  await renderTalentCards(currentChoices, true);
}

async function showCombat(r,words,rewards){
  const {hero:safeHero,enemy:safeEnemy}=getCombatants();
  const safeResult={
    heroDmg:0,
    enemyDmg:0,
    heroMax:safeHero.hp,
    enemyMax:safeEnemy.hp,
    heroFin:safeHero.hp,
    enemyFin:safeEnemy.hp,
    win:false,
    tie:false,
    ...r
  };
  const safeRewards={
    gold:(rewards&&typeof rewards.gold==='number')?rewards.gold:0,
    items:Array.isArray(rewards?.items)?rewards.items:[]
  };

  window.lastCombatResult=safeResult; // Store for afterCombat
  window.lastCombatRewards=safeRewards; // Store rewards for display

  // Calculate animation speed multiplier based on REREAD count
  // More REREADs = faster tally to avoid long waits
  let animSpeedMult = 1.0;
  if (safeResult.ultimateWeaponForged) {
    animSpeedMult = 8.0; // 8x faster for ultimate weapon
  } else if (safeResult.totalRereadCount > 20) {
    animSpeedMult = 5.0;  // 5x faster for 20+ rereads
  } else if (safeResult.totalRereadCount > 10) {
    animSpeedMult = 3.0;  // 3x faster for 10+ rereads
  } else if (safeResult.totalRereadCount > 5) {
    animSpeedMult = 2.0;  // 2x faster for 5+ rereads
  }
  const minDelay = 50; // Minimum delay floor to prevent jank

  const ov=$("#combat-overlay");
  const cw=$("#combat-words");
  const total=$("#combat-total");
  const flames=$("#combat-flames");
  const weaponHost=$("#combat-weapon-svg");
  const weaponLayers=ensureWeaponLayers(weaponHost);
  const weaponSvg=weaponLayers?.wrapper||weaponHost;
  const cbHero=$("#cb-hero"),cbEnemy=$("#cb-enemy");
  const barHero=$("#bar-hero"),barEnemy=$("#bar-enemy");

  // Add click sparks to combat overlay for blacksmith feel (controlled by Combat Effects setting)
  if(ov && !ov.__clickSparksAttached){
    ov.__clickSparksAttached = true;
    ov.addEventListener('click', (e) => {
      // Skip click sparks in Low FX mode
      if (gfxSettings.lowFx) return;
      // Thin, long line sparks at click position
      createFizzySparks(e.clientX, e.clientY, {
        count: 4,
        colors: ['#ff9933', '#ffcc00'],
        shape: 'line',
        size: 2,
        velocity: 2.2,
        gravity: 0.15,
        duration: 1200,
        initialOpacity: 0.6
      });
    });
  }
  const txtHero=$("#txt-hero"),txtEnemy=$("#txt-enemy");
  const resultBox=$("#combat-result");
  const resultTitle=$("#combat-result-title");
  const resultDetail=$("#combat-result-detail");
  const resultBreakBtn=$("#combat-breakdown-btn");
  const resultBreakTooltip=$("#combat-breakdown-tooltip");

  if(resultBreakBtn){
    resultBreakBtn.style.display='none';
  }

  if(resultBreakBtn && resultBreakTooltip && !resultBreakBtn.__tooltipAttached){
    resultBreakBtn.__tooltipAttached = true;

    // Click to toggle breakdown visibility
    const toggleTip = (e) => {
      e.stopPropagation();
      playSample('click.ogg', 0.5);
      const isVisible = resultBreakTooltip.classList.contains('show');
      if(isVisible){
        resultBreakTooltip.classList.remove('show');
        resultBreakBtn.classList.remove('active');
      } else {
        const content = formatDamageBreakdown(window.lastCombatResult || safeResult);
        resultBreakTooltip.innerHTML = content;
        if(content){ fitCombatBreakdownTooltip(resultBreakTooltip); }
        resultBreakTooltip.classList.add('show');
        resultBreakBtn.classList.add('active');
      }
    };

    // Close when clicking outside
    const closeTip = (e) => {
      if(!resultBreakBtn.contains(e.target) && !resultBreakTooltip.contains(e.target)){
        resultBreakTooltip.classList.remove('show');
        resultBreakBtn.classList.remove('active');
      }
    };

    // Remove old document listener if it exists
    if(resultBreakBtn.__documentClickHandler){
      document.removeEventListener('click', resultBreakBtn.__documentClickHandler);
    }

    // Store new listener on element
    resultBreakBtn.__documentClickHandler = closeTip;

    resultBreakBtn.addEventListener('click', toggleTip);
    resultBreakBtn.addEventListener('mouseenter', sfxHover);
    document.addEventListener('click', closeTip);
  }

  if(!ov||!cw||!total||!flames||!weaponHost||!cbHero||!cbEnemy||!barHero||!barEnemy||!txtHero||!txtEnemy){
    console.warn("[combat] Missing combat DOM; skipping animation");
    return;
  }

  cw.innerHTML="";
  total.classList.remove("show");
  total.textContent="";
  flames.style.opacity="0";
  // Reset to base rotation (15deg) instead of clearing transform entirely
  if(weaponSvg) weaponSvg.style.transform="rotate(15deg)";
  // Hide the new-run button at the start of combat
  const newRunBtnInit=document.getElementById("combat-new-run");
  if(newRunBtnInit) newRunBtnInit.style.display="none";
  // Compute how many parts of the weapon need to be built based on selected words
  var relevantCount=[S.sel.item,S.sel.adj1,S.sel.adj2,S.sel.adj3,S.sel.adj4,S.sel.noun1].filter(Boolean).length;
  // Track progress of displayed parts
  var progressSeen=0;
  // Begin with an empty weapon SVG
  renderWeaponProgress(weaponHost,0);

  cbHero.textContent="0";cbEnemy.textContent="0";
  // Hero HP is not tracked - hide hero health bar
  barHero.style.width="0%";
  barEnemy.style.width="100%";
  txtHero.textContent="";
  txtEnemy.textContent=`${fmtBig(safeResult.enemyMax)}/${fmtBig(safeResult.enemyMax)}`;
  const barOuter = barEnemy.parentElement;
  if(barOuter){
    barOuter.style.opacity="1";
    barOuter.style.transition="";
  }
  if(txtEnemy){
    txtEnemy.style.opacity="1";
    txtEnemy.style.transition="";
  }
  // Reset result box animation state
  resultBox.style.display="none";
  resultBox.classList.remove("show");
  ov.classList.remove("combat-reveal", "combat-result", "combat-exit"); // Reset choreography state
  ov.classList.add("show");
  // Trigger staggered element reveal after modal starts scaling in
  setTimeout(() => {
    ov.classList.add("combat-reveal");
  }, 200);
  const continueBtn=document.getElementById("combat-continue");
  const strayNewRun=document.getElementById("combat-new-run");

  // Ensure only the Continue button is shown on the combat result modal.
  if(strayNewRun) strayNewRun.remove();

  if(continueBtn){
    continueBtn.style.display="none";
    continueBtn.disabled=true;
    continueBtn.classList.remove("show");
  }

  try{
    cw.innerHTML="";
    total.classList.remove("show");
    total.textContent="";
    flames.style.opacity="0";
    // Reset to base rotation (15deg) instead of clearing transform entirely
    if(weaponSvg) weaponSvg.style.transform="rotate(15deg)";
    // Compute how many parts of the weapon need to be built based on selected words
    var relevantCount=[S.sel.item,S.sel.adj1,S.sel.adj2,S.sel.adj3,S.sel.adj4,S.sel.noun1].filter(Boolean).length;
    // Track progress of displayed parts
    var progressSeen=0;
    // Begin with an empty weapon SVG
    renderWeaponProgress(weaponHost,0);

    $("#cb-hero").textContent="0";$("#cb-enemy").textContent="0";
    // Hero HP is not tracked - hide hero health bar
    $("#bar-hero").style.width="0%";
    $("#bar-enemy").style.width="100%";
    $("#txt-hero").textContent="";
    $("#txt-enemy").textContent=`${fmtBig(r.enemyMax)}/${fmtBig(r.enemyMax)}`;
    const barOuterEl = $("#bar-enemy").parentElement;
    if(barOuterEl){
      barOuterEl.style.opacity="1";
      barOuterEl.style.transition="";
    }
    const txtEnemyEl = $("#txt-enemy");
    if(txtEnemyEl){
      txtEnemyEl.style.opacity="1";
      txtEnemyEl.style.transition="";
    }
    if(resultBox) resultBox.style.display="none";
    ov.classList.add("show");

    await dly(RHYTHM.HALF);

    words.forEach(w =>{
      const div=document.createElement("div");
      div.className="combat-word";
      if(w.tooltip){
        div.setAttribute("title", w.tooltip);
      }
      const rc=TC[w.rarity] || "";
      // Add retrigger count display if word is retriggered
      const retriggerText = w.retriggerCount && w.retriggerCount > 1 ? `<div class="combat-word-retrigger"><span class="mod-badge reread">√ó${w.retriggerCount}</span></div>` : '';
      // Apply italic style for "of the" connector
      const italicClass = w.italic ? ' italic' : '';
      div.innerHTML=`<div class="combat-word-name ${rc}${italicClass}" ${w.color?`style=\"color:${w.color}\"`:''}>${w.name}</div>${retriggerText}`;
      cw.appendChild(div);
    });

    const wordEls=[...cw.querySelectorAll(".combat-word")];

    // === Progressive HP Bar Animation (Preview-then-Shatter) ===
    // During tally: keep HP bar FULL, grow a red preview bar to show damage
    // After tally: shatter effect, then reveal actual remaining HP
    const totalTriggers = words.reduce((sum, w) => sum + (w.retriggerCount || 1), 0);
    let triggersCompleted = 0;
    let globalToneIndex = 0; // Rising tone counter that continues across all passes (for Shepard effect)
    const barOuter = barEnemy.parentElement; // Get the .bar-outer container for shake effect
    const barPreview = document.getElementById('bar-enemy-preview');
    // Keep enemy HP bar at 100% during tally
    barEnemy.style.width = '100%';
    if (barPreview) {
      barPreview.style.width = '0%';
      barPreview.classList.add('active');
    }
    // Initialize HP bar state
    updateHPBarDamageState(barEnemy, null, 0);

    // Wait for next beat to start tally in sync with music
    await waitForNextBeat();

    // Build pass schedule - words drop out as their reread counts exhaust
    const passes = buildRereadPasses(words);
    const wordShown = new Array(words.length).fill(false); // Track first appearance

    for(let passIdx = 0; passIdx < passes.length; passIdx++){
      const wordsInPass = passes[passIdx];

      for(let wordIdx of wordsInPass){
        const w = words[wordIdx];
        const el = wordEls[wordIdx];
        const isFirstAppearance = !wordShown[wordIdx];
        const isRetrigger = !isFirstAppearance;

        // Dynamic speed ramp: starts at 1x, accelerates quickly as tally progresses
        const progress = triggersCompleted / totalTriggers;
        let dynamicSpeed = 1.0;
        if (progress > 0.4) dynamicSpeed = 8.0;
        else if (progress > 0.25) dynamicSpeed = 4.0;
        else if (progress > 0.1) dynamicSpeed = 2.0;
        // Cap at the max allowed by REREAD count
        dynamicSpeed = Math.min(dynamicSpeed, animSpeedMult);

        // Use RHYTHM constants for beat-synced timing
        // First appearance: full beat, Retriggers: half beat
        const baseDelay = isRetrigger ? RHYTHM.HALF : RHYTHM.BEAT;
        await dly(Math.max(minDelay, baseDelay / dynamicSpeed));

        if(isFirstAppearance){
          el.classList.add("show");
          wordShown[wordIdx] = true;
        } else {
          // Add retrigger visual effect
          el.classList.add("retrigger");
        }

        // Play rising Shepard tone - continues ascending across all passes
        // Uses globalToneIndex which increments each trigger for infinite rising effect
        try{
          playShepardTone(globalToneIndex, totalTriggers, isRetrigger);
          globalToneIndex++;
          // Add alternating click sound
          const clickSound = useClickAlt ? 'click alt.ogg' : 'click.ogg';
          playSample(clickSound, 0.5);
          useClickAlt = !useClickAlt;

          // Play weapon-specific sound if it's a weapon word
          if (w.wordRef && w.wordRef.type === 'weapon' && !w.wordRef.isStick) {
            if (w.wordRef.category === 'slash') {
              playSample('insert sword bow type.ogg', 0.5);
            } else if (w.wordRef.category === 'pierce') {
              playSample('insert bow type.ogg', 0.5);
            } else if (w.wordRef.category === 'blunt') {
              playSample('insert blunt.ogg', 0.5);
            } else if (w.wordRef.category === 'magic') {
              playSample('insert wand sound.ogg', 0.5);
            }
          }

          // Play element-specific sound if word has an element
          if (w.wordRef && w.wordRef.elem !== undefined) {
            const elemSample = ELEMENT_SAMPLES[w.wordRef.elem];
            if (elemSample) {
              playSample(elemSample, w.wordRef.elem === E.LIGHTNING ? 0.4 : 0.25);
            }
          }

          // Blacksmith sparks at weapon position for each word tallied
          if (weaponHost) {
            const weaponRect = weaponHost.getBoundingClientRect();
            const sparkX = weaponRect.left + weaponRect.width / 2;
            const sparkY = weaponRect.top + weaponRect.height / 2;

            // Get element-specific colors for sparks
            let sparkColors = ['#ff9933', '#ffcc00', '#ffaa44']; // Default blacksmith orange
            if (w.wordRef && w.wordRef.elem !== undefined) {
              const elemSparkColors = {
                [E.FIRE]: ['#ff6633', '#ff9933', '#ffcc00'],
                [E.WATER]: ['#4d99ff', '#66b3ff', '#99ccff'],
                [E.LIGHTNING]: ['#ffff4d', '#ffffff', '#ffffaa'],
                [E.EARTH]: ['#996633', '#cc9966', '#aa7744'],
                [E.POISON]: ['#7ee04d', '#99ff66', '#66cc33'],
                [E.LIGHT]: ['#ffffa0', '#ffffff', '#ffffcc'],
                [E.DARK]: ['#9966cc', '#bb88ee', '#7744aa'],
                [E.PHYS]: ['#a0a0a0', '#cccccc', '#888888']
              };
              if (elemSparkColors[w.wordRef.elem]) {
                sparkColors = elemSparkColors[w.wordRef.elem];
              }
            }

            // Create blacksmith sparks with element colors
            const sparkCount = w.wordRef && w.wordRef.tier === T.T3 ? 12 : (w.wordRef && w.wordRef.tier === T.T2 ? 8 : 5);
            createFizzySparks(sparkX, sparkY, {
              count: sparkCount,
              colors: sparkColors,
              shape: 'line',
              size: 5,
              velocity: 4,
              gravity: 0.2,
              duration: 600,
              initialOpacity: 0.9
            });

            // Play elemental effect animation for words with elements
            if (w.wordRef && w.wordRef.elem !== undefined && el) {
              const elemEffects = {
                [E.PHYS]: () => {
                  const elRect = el.getBoundingClientRect();
                  const x1 = elRect.left + elRect.width / 2;
                  const y1 = elRect.top + elRect.height / 2;
                  if (typeof MetalClash !== 'undefined' && fxAnimations) {
                    addFxAnimation(new MetalClash(x1, y1, sparkX, sparkY, '#a0a0a0'));
                  }
                },
                [E.LIGHTNING]: () => {
                  const elRect = el.getBoundingClientRect();
                  const x1 = elRect.left + elRect.width / 2;
                  const y1 = elRect.top + elRect.height / 2;
                  if (typeof LightningBolt !== 'undefined' && fxAnimations) {
                    addFxAnimation(new LightningBolt(x1, y1, sparkX, sparkY, '#ffffff'));
                    setTimeout(() => addFxAnimation(new LightningBolt(x1, y1, sparkX, sparkY, '#ffff4d')), 50);
                  }
                },
                [E.FIRE]: () => {
                  const elRect = el.getBoundingClientRect();
                  const x1 = elRect.left + elRect.width / 2;
                  const y1 = elRect.top + elRect.height / 2;
                  if (typeof ParticleTrail !== 'undefined' && fxAnimations) {
                    addFxAnimation(new ParticleTrail(x1, y1, sparkX, sparkY, 'fire', '#ff6633'));
                  }
                },
                [E.WATER]: () => {
                  const elRect = el.getBoundingClientRect();
                  const x1 = elRect.left + elRect.width / 2;
                  const y1 = elRect.top + elRect.height / 2;
                  if (typeof WaterStream !== 'undefined' && fxAnimations) {
                    addFxAnimation(new WaterStream(x1, y1, sparkX, sparkY, '#4d99ff'));
                  }
                },
                [E.EARTH]: () => {
                  const elRect = el.getBoundingClientRect();
                  const x1 = elRect.left + elRect.width / 2;
                  const y1 = elRect.top + elRect.height / 2;
                  if (typeof RockThrow !== 'undefined' && fxAnimations) {
                    addFxAnimation(new RockThrow(x1, y1, sparkX, sparkY, '#996633'));
                  }
                },
                [E.POISON]: () => {
                  const elRect = el.getBoundingClientRect();
                  const x1 = elRect.left + elRect.width / 2;
                  const y1 = elRect.top + elRect.height / 2;
                  if (typeof WindGust !== 'undefined' && fxAnimations) {
                    addFxAnimation(new WindGust(x1, y1, sparkX, sparkY, '#7ee04d'));
                  }
                },
                [E.LIGHT]: () => {
                  const elRect = el.getBoundingClientRect();
                  const x1 = elRect.left + elRect.width / 2;
                  const y1 = elRect.top + elRect.height / 2;
                  if (typeof EnergyBeam !== 'undefined' && fxAnimations) {
                    addFxAnimation(new EnergyBeam(x1, y1, sparkX, sparkY, '#ffffa0', false));
                  }
                },
                [E.DARK]: () => {
                  const elRect = el.getBoundingClientRect();
                  const x1 = elRect.left + elRect.width / 2;
                  const y1 = elRect.top + elRect.height / 2;
                  if (typeof EnergyBeam !== 'undefined' && fxAnimations) {
                    addFxAnimation(new EnergyBeam(x1, y1, sparkX, sparkY, '#9966cc', true));
                  }
                }
              };

              if (elemEffects[w.wordRef.elem]) {
                elemEffects[w.wordRef.elem]();
              }

              // Floating +W animation for Elemental Mastery (only on first appearance)
              if (isFirstAppearance && S.talents && S.talents.includes('elemental_mastery')) {
                let wBonus = 2; // Base +2W from Elemental Mastery
                // Check for Weakness Exploit Amp bonus
                if (S.talents.includes('weakness_exploit_amp') && S.enemy && S.enemy.weak && S.enemy.weak.includes(w.wordRef.elem)) {
                  wBonus += 4; // Additional +4W
                }

                // Create floating +W element
                const elRect = el.getBoundingClientRect();
                const floatW = document.createElement('div');
                floatW.className = 'floating-bonus floating-w';
                floatW.textContent = `+${wBonus}W`;
                floatW.style.cssText = `
                  position: fixed;
                  left: ${elRect.left + elRect.width / 2}px;
                  top: ${elRect.top}px;
                  transform: translateX(-50%);
                  color: #60a5fa;
                  font-weight: bold;
                  font-size: 16px;
                  text-shadow: 0 0 8px rgba(96, 165, 250, 0.8);
                  pointer-events: none;
                  z-index: 10000;
                  opacity: 1;
                  transition: all 0.6s ease-out;
                `;
                document.body.appendChild(floatW);

                // Animate upward and fade
                requestAnimationFrame(() => {
                  floatW.style.top = `${elRect.top - 40}px`;
                  floatW.style.opacity = '0';
                });

                // Remove after animation
                setTimeout(() => floatW.remove(), 600);
              }
            }
          }
        }catch(err){
          console.error('Tally effect error:', err);
        }

        if(w.intensity>0.3){
          el.classList.add("impact");
          // Removed sfxImpact to prevent dual sound effects - only keep the ascending tone
          if(weaponSvg){
            weaponSvg.style.animation="weaponShake .3s ease-out";
            setTimeout(()=>weaponSvg.style.animation="",RHYTHM.HALF);
          }

          if(w.intensity>1){
            spawnFlames(3+Math.floor(w.intensity*2));
          }
        }

        await dly(Math.max(minDelay, RHYTHM.HALF / dynamicSpeed));
        el.classList.remove("impact");

        // Only build weapon progress on first appearance of each word
        if(isFirstAppearance && progressSeen < relevantCount){
          progressSeen++;
          const progressRatio = progressSeen / Math.max(relevantCount, 1);
          renderWeaponProgress(weaponHost, progressRatio >= 1 ? 1.0 : progressRatio);
        }

        // === Progressive PREVIEW Bar Update ===
        // Keep HP bar full, grow preview bar to show damage accumulating
        triggersCompleted++;
        const damageProgress = triggersCompleted / totalTriggers;
        const currentDamage = r.heroDmg * damageProgress;
        const remainingHP = Math.max(0, r.enemyMax - currentDamage);
        const damagePercent = Math.min(100, (currentDamage / r.enemyMax) * 100);

        // Update preview bar width (grows from right side)
        if (barPreview) {
          barPreview.style.width = `${damagePercent}%`;
        }
        // Update HP text to show predicted remaining
        txtEnemy.textContent = `${fmtBig(Math.round(remainingHP))}/${fmtBig(r.enemyMax)}`;
        // Shake effect on each hit
        if (barOuter) {
          barOuter.classList.add('shake');
          setTimeout(() => barOuter.classList.remove('shake'), RHYTHM.HALF);
        }
      }
    }

    await dly(Math.max(minDelay, RHYTHM.BEAT / animSpeedMult));

    // Show floating gold bonuses from talent abilities (if victory)
    if (rewards && rewards.talentGoldBonuses && rewards.talentGoldBonuses.length > 0) {
      const weaponRect = weaponHost.getBoundingClientRect();
      const baseX = weaponRect.left + weaponRect.width / 2;
      const baseY = weaponRect.top + weaponRect.height / 2;

      for (let i = 0; i < rewards.talentGoldBonuses.length; i++) {
        const bonus = rewards.talentGoldBonuses[i];

        // Create floating gold element
        const floatGold = document.createElement('div');
        floatGold.className = 'floating-bonus floating-gold';
        floatGold.innerHTML = `+${bonus.amount}g`;
        floatGold.style.cssText = `
          position: fixed;
          left: ${baseX + (i - rewards.talentGoldBonuses.length / 2) * 30}px;
          top: ${baseY}px;
          transform: translateX(-50%);
          color: #fbbf24;
          font-weight: bold;
          font-size: 18px;
          text-shadow: 0 0 10px rgba(251, 191, 36, 0.8);
          pointer-events: none;
          z-index: 10000;
          opacity: 1;
          transition: all 0.8s ease-out;
        `;
        document.body.appendChild(floatGold);

        // Play gold sound
        try { playSample('buy.ogg', 0.5); } catch(e){}

        // Animate upward and fade
        requestAnimationFrame(() => {
          floatGold.style.top = `${baseY - 60 - (i * 25)}px`;
          floatGold.style.opacity = '0';
        });

        // Remove after animation
        setTimeout(() => floatGold.remove(), 800);

        // Stagger each gold bonus
        await dly(RHYTHM.QUARTER);
      }
    }

    flames.style.opacity="0.5";

    total.textContent=`${fmtBig(r.heroDmg)} DAMAGE!`;
    total.classList.add("show");

    // Play a final resolution note + boom to conclude
    try{
      playShepardTone(globalToneIndex + 1, totalTriggers, false);
      playSample('boom.ogg', 0.8);
    }catch(err){}

    // === SHATTER EFFECT happens on DAMAGE! reveal ===
    // Stop preview pulse animation
    if (barPreview) {
      barPreview.classList.remove('active');
    }

    // Wait for boom sound to hit peak impact
    await dly(RHYTHM.BEAT);

    // Shatter effect on enemy health bar - the dramatic moment!
    shatterHealthBar(barOuter, r.heroDmg, r.enemyMax);

    // Quick fade out the entire HP bar area during shatter (sells the destruction)
    if (barOuter) {
      barOuter.style.transition = 'opacity 0.15s ease-out';
      barOuter.style.opacity = '0';
    }
    if (txtEnemy) {
      txtEnemy.style.transition = 'opacity 0.15s ease-out';
      txtEnemy.style.opacity = '0';
    }

    await dly(RHYTHM.HALF);

    // Reset preview bar and set final HP bar state (while hidden)
    if (barPreview) {
      barPreview.style.width = '0%';
    }
    const finalHpPercent = (r.enemyFin / r.enemyMax) * 100;
    barEnemy.style.transition = 'none';
    barEnemy.style.width = `${finalHpPercent}%`;
    updateHPBarState(barEnemy, null, finalHpPercent);
    txtEnemy.textContent = `${fmtBig(r.enemyFin)}/${fmtBig(r.enemyMax)}`;

    await dly(RHYTHM.HALF);

    // Only fade HP bar back in if enemy survived (hide forever after kill)
    if (r.enemyFin > 0) {
      if (barOuter) {
        barOuter.style.transition = 'opacity 0.3s ease-in';
        barOuter.style.opacity = '1';
      }
      if (txtEnemy) {
        txtEnemy.style.transition = 'opacity 0.3s ease-in';
        txtEnemy.style.opacity = '1';
      }

      await dly(RHYTHM.BEAT);
      // Reset transitions
      if (barOuter) barOuter.style.transition = '';
      if (txtEnemy) txtEnemy.style.transition = '';
      barEnemy.style.transition = '';
    }
    // else: bar stays hidden (opacity 0) permanently after shatter - no empty outline
    flames.style.opacity = "0";

    await dly(RHYTHM.HALF);
    await anim($("#cb-hero"), 0, r.heroDmg, 500);
    await dly(RHYTHM.QUARTER);
    await anim($("#cb-enemy"), 0, r.enemyDmg, 350);
    await dly(RHYTHM.HALF);

    // Ensure final state is correct
    $("#bar-hero").style.width = "0%";
    $("#txt-hero").textContent = "";
    await dly(RHYTHM.HALF);

    if(resultBreakBtn && resultBreakTooltip){
      const content = formatDamageBreakdown(window.lastCombatResult || safeResult);
      resultBreakTooltip.innerHTML = content;
      if(content){ fitCombatBreakdownTooltip(resultBreakTooltip); }
      // Reset tooltip state - use class not inline styles
      resultBreakTooltip.classList.remove('show');
      resultBreakTooltip.style.opacity = ''; // Clear any inline opacity
      resultBreakBtn.classList.remove('active');
      resultBreakBtn.style.display = content ? 'inline-flex' : 'none';
    }

    if(resultBox) resultBox.className="";
    if(resultBox) resultBox.style.display="block";
    ov.classList.add("combat-result");
    // Trigger slide-in animation after a short beat to avoid snapping
    setTimeout(() => {
      if(resultBox) resultBox.classList.add("show");
    }, 80);

    if(r.win){
      if(resultBox) resultBox.classList.add("win");
      if(resultTitle){
        resultTitle.textContent="VICTORY!";
        // Color now handled by CSS gradient
      }
      // Play victory sound alongside the musical notes
      try{
        playSample('victory.ogg', 0.9);
      }catch(err){}

      // Show rewards - build DOM elements for styled display
      if(resultDetail){
        resultDetail.innerHTML = '';

        // Enemy defeated line
        const defeatLine = document.createElement('div');
        defeatLine.className = 'result-detail-line';
        defeatLine.textContent = 'Enemy defeated!';
        resultDetail.appendChild(defeatLine);

        // Boss victory dialogue - show hero's unique line for this boss
        if(S.enemy && S.enemy.boss && S.hero){
          const bossId = S.chapterBoss?.id || S.enemy.id;
          const victoryLine = getBossVictoryDialogue(S.hero.id, bossId);
          if(victoryLine){
            const dialogueLine = document.createElement('div');
            dialogueLine.className = 'result-detail-line';
            dialogueLine.style.cssText = 'font-style:italic;color:#d1d5db;margin-top:8px;font-size:13px';
            dialogueLine.textContent = `"${victoryLine}"`;
            resultDetail.appendChild(dialogueLine);
          }
        }

        // Gold reward - base + talent bonuses with animation
        if(rewards && rewards.gold > 0){
          // Base gold (always 20)
          const baseGold = 20;
          const goldLine = document.createElement('div');
          goldLine.className = 'result-detail-line gold-reward';
          goldLine.innerHTML = `<span class="gold">+${baseGold} Gold</span>`;
          resultDetail.appendChild(goldLine);

          // Talent gold bonuses - show each one with animation and sound
          if(rewards.talentGoldBonuses && rewards.talentGoldBonuses.length > 0){
            const talentGoldContainer = document.createElement('div');
            talentGoldContainer.className = 'talent-gold-bonuses';
            resultDetail.appendChild(talentGoldContainer);

            // Animate each talent bonus appearing
            (async () => {
              for(const bonus of rewards.talentGoldBonuses){
                await dly(RHYTHM.QUARTER); // Stagger each bonus
                const bonusLine = document.createElement('div');
                bonusLine.className = 'result-detail-line talent-gold-bonus';
                bonusLine.style.opacity = '0';
                bonusLine.style.transform = 'translateY(-5px)';
                bonusLine.innerHTML = `<span class="gold">+${bonus.amount}g</span> <span class="talent-name">${bonus.name}</span>`;
                talentGoldContainer.appendChild(bonusLine);
                // Play buy sound
                try { playSample('buy.ogg', 0.5); } catch(e){}
                // Animate in
                requestAnimationFrame(() => {
                  bonusLine.style.transition = 'opacity 0.2s ease, transform 0.2s ease';
                  bonusLine.style.opacity = '1';
                  bonusLine.style.transform = 'translateY(0)';
                });
              }
            })();
          }

        }

        // Boss loot as word chips
        if(rewards && rewards.items.length > 0){
          const availableSlots = Math.max(0, INV_LIMIT - (S.inv?.length || 0));
          const lootWords = rewards.items.slice(0, availableSlots);
          if(lootWords.length > 0){
            const lootLabel = document.createElement('div');
            lootLabel.className = 'result-detail-line boss-loot-label';
            lootLabel.textContent = 'Boss Reward:';
            resultDetail.appendChild(lootLabel);

            const chipContainer = document.createElement('div');
            chipContainer.className = 'result-loot-chips';
            lootWords.forEach(wordName => {
              const word = S.inv.find(w => w.name === wordName) || WORDS.find(w => w.name === wordName);
              if(word){
                const chip = mkChip(word, true); // disabled = true
                chip.classList.add('loot-chip');
                chipContainer.appendChild(chip);
              } else {
                const span = document.createElement('span');
                span.className = 'loot-word-name';
                span.textContent = wordName;
                chipContainer.appendChild(span);
              }
            });
            resultDetail.appendChild(chipContainer);

            if(availableSlots < rewards.items.length){
              const limitLine = document.createElement('div');
              limitLine.className = 'result-detail-line dim';
              limitLine.textContent = '(inventory space limited)';
              resultDetail.appendChild(limitLine);
            }
          } else {
            const fullLine = document.createElement('div');
            fullLine.className = 'result-detail-line dim';
            fullLine.textContent = 'Boss Loot: (inventory full)';
            resultDetail.appendChild(fullLine);
          }
        }
      }
      // Play victory sound
      sfxWin();
    }else if(r.tie){
      if(resultBox) resultBox.classList.add("lose");
      if(resultTitle){
        resultTitle.textContent="DRAW";
        // Color handled by CSS
      }
      if(resultDetail) resultDetail.innerHTML='<div class="result-detail-line">Both fell...</div>';
      sfxLose();
      // Only trigger lose music effect if this is the final death (no extra lives)
      if (musicEngine && musicEngine.initialized && S.lives <= 1) {
        musicEngine.triggerLoseEffect();
      }
    }else{
      if(resultBox) resultBox.classList.add("lose");
      if(resultTitle){
        resultTitle.textContent="DEFEAT";
        // Color handled by CSS
      }
      if(resultDetail) resultDetail.innerHTML='<div class="result-detail-line">The enemy won...</div>';
      sfxLose();
      // Only trigger lose music effect if this is the final death (no extra lives)
      if (musicEngine && musicEngine.initialized && S.lives <= 1) {
        musicEngine.triggerLoseEffect();
      }
    }
    // No text log appended; calculation details are available via slot indicators
    render();
  }catch(err){
    console.error(err);
    if(resultBox){
      resultBox.className="lose";
      resultBox.style.display="block";
    }
    if(resultTitle){
      resultTitle.textContent="‚ö†Ô∏è Combat Error";
      resultTitle.style.color="#f59e0b";
    }
    if(resultDetail){
      resultDetail.textContent="Something went wrong resolving combat. You can continue to keep playing.";
      resultDetail.style.whiteSpace="pre-line";
    }
  }finally{
    // Reveal the continue button now that combat has resolved (even on error)
    if(continueBtn){
      continueBtn.style.display="block";
      continueBtn.disabled=false;
      // Trigger fade-in animation after a short delay
      setTimeout(() => {
        continueBtn.classList.add("show");
        continueBtn.focus();
      }, 150);
    }
  }
}

function spawnFlames(count){
  const container=$("#combat-flames");
  for(let i=0;i<count;i++){
    const f=document.createElement("div");
    f.className="flame-particle";
    f.style.left=Math.random()*100+"%";
    f.style.bottom="0";
    f.style.animationDuration=(0.6+Math.random()*0.6)+"s";
    container.appendChild(f);
    setTimeout(()=>f.remove(),RHYTHM.BAR);
  }
}

// === SHOP ===
let shopCrates=[],shopConsumables=[];
async function showShop(skipTransition = false){
  // Hide battle-view immediately to prevent flash during overlay fades
  const battleView = document.getElementById('battle-view');
  if (battleView) battleView.style.display = 'none';

  // Stop any playing rarity drones from forge
  stopAllRarityDrones();

  // Apply SHOP_ENTRY modifiers (e.g., Ranger's Resourceful passive)
  applyModifiers('SHOP_ENTRY', {hero: S.hero, state: S});

  // Mark game phase for save/load restoration
  S.gamePhase = 'shop';

  S.rerollCost=5;
  // Base crate price scaled by difficulty (25 ‚Üí 31 ‚Üí 38 for Adept/Master)
  const baseCratePrice = Math.ceil(25 * DIFF_PRICE_MULT[S.difficulty || 0]);
  S.cratePrices = { world_sky: baseCratePrice, body_soul: baseCratePrice }; // Reset crate prices each shop visit
  rollShop();
  renderShop();
  saveRun();

  // Shop dialogue - 30% chance to show hero commentary
  const shopDialogueEl = document.getElementById('shop-hero-dialogue');
  if(shopDialogueEl && S.hero && S.hero.shopDialogue && Math.random() < 0.3){
    const lines = S.hero.shopDialogue;
    const randomLine = lines[Math.floor(Math.random() * lines.length)];
    shopDialogueEl.textContent = `"${randomLine}"`;
  } else if(shopDialogueEl){
    shopDialogueEl.textContent = '';
  }

  // Disable exit shop button to prevent double-click (result screen Continue is in same location)
  const exitShopBtn = document.getElementById("exit-shop-btn");
  if(exitShopBtn){
    exitShopBtn.disabled = true;
    exitShopBtn.classList.add('btn-disabled');
  }

  // Helper function to set up shop visuals
  const setupShopVisuals = () => {
    const resultBox = document.getElementById('result-box');
    if (resultBox) resultBox.style.display = 'none';
    const forgeEl = document.getElementById("forge");
    if (forgeEl) forgeEl.classList.add("shop-hidden");

    $("#shop-overlay").classList.add("show");

    if (musicEngine && musicEngine.initialized) {
      musicEngine.enterShopMode();
    }
    // Purple flame if upcoming round is a Chapter Boss (round 9, 18, 27, etc.)
    const isPreBossShop = S.roundIndex % 9 === 0 && S.roundIndex > 0;
    setFlameColor(isPreBossShop ? 'boss-shop' : 'shop');

    // Update floating embers color
    if (sparkManager) {
      sparkManager.setColorMode(isPreBossShop ? 'boss' : 'shop');
    }
  };

  // Either do our own transition or just set up visuals (caller handled transition)
  if (skipTransition) {
    setupShopVisuals();
  } else {
    await playSceneTransition(setupShopVisuals);
  }

  // Fade out spotlight tint after shop is visible
  const spotlightTint = $("#spotlight-tint");
  if(spotlightTint) {
    spotlightTint.classList.remove("full");
    await dly(RHYTHM.EIGHTH);
    spotlightTint.classList.remove("show");
  }

  // Re-enable exit shop button after scene fully loads (double-click guard)
  setTimeout(() => {
    const exitBtn = document.getElementById("exit-shop-btn");
    if(exitBtn){
      exitBtn.disabled = false;
      exitBtn.classList.remove('btn-disabled');
    }
  }, 500);
}

function rollShop(){
  // Two themed crates, each containing 5 slots:
  // 1 weapon + 3 elemental words + 1 rarity adjective
  shopCrates = [];

  // Initialize crate prices if not set (increases each purchase)
  if(!S.cratePrices) S.cratePrices = { world_sky: 25, body_soul: 25 };

  // Get pools
  // Refinement talent: Filter out T1 words from crates (including weapons)
  const hasRefinement = S.talents && S.talents.includes('refinement');

  const weaponPool = WORDS.filter(w => {
    if (w.type !== 'weapon') return false;
    if (hasRefinement && (w.rarity === undefined || w.rarity <= T.T1)) return false; // Skip T1 weapons
    return true;
  });
  const rarityAdjPool = WORDS.filter(w => w.type === 'rarity');

  // World & Sky: Fire, Water, Earth, Lightning
  const worldSkyElements = [E.FIRE, E.WATER, E.EARTH, E.LIGHTNING];
  const worldSkyWordPool = WORDS.filter(w => {
    if (w.type === 'weapon') return false;
    if (w.hiddenInBank) return false;
    if (hasRefinement && (w.rarity === undefined || w.rarity <= T.T1)) return false; // Skip T1
    return w.elem !== undefined && worldSkyElements.includes(w.elem);
  });

  // Body & Soul: Physical, Poison, Light, Dark
  const bodySoulElements = [E.PHYS, E.POISON, E.LIGHT, E.DARK];
  const bodySoulWordPool = WORDS.filter(w => {
    if (w.type === 'weapon') return false;
    if (w.hiddenInBank) return false;
    if (hasRefinement && (w.rarity === undefined || w.rarity <= T.T1)) return false; // Skip T1
    return w.elem !== undefined && bodySoulElements.includes(w.elem);
  });

  // Determine quantities (Bulk Discount and Crate Connoisseur add +1 each to elemental word qty)
  let elementalQty = 3;
  if (S.talents && S.talents.includes('bulk_discount')) {
    elementalQty += 1;
  }
  if (S.talents && S.talents.includes('crate_connoisseur')) {
    elementalQty += 1;
  }

  // Rarity words are no longer guaranteed - they have a chance to appear
  // in elemental word slots (tiered: T1 rarity in slot 1, T2 in slot 2, T3 in slot 3)
  // Only one rarity word can drop per crate
  const t1RarityPool = rarityAdjPool.filter(w => w.rarity === T.T1); // Common, Uncommon
  const t2RarityPool = rarityAdjPool.filter(w => w.rarity === T.T2); // Magic, Rare
  const t3RarityPool = rarityAdjPool.filter(w => w.rarity === T.T3); // Epic, Legendary

  shopCrates.push({
    type: 'world_sky',
    name: 'World & Sky',
    elements: worldSkyElements,
    weaponPool: weaponPool,
    wordPool: worldSkyWordPool,
    t1RarityPool: t1RarityPool,
    t2RarityPool: t2RarityPool,
    t3RarityPool: t3RarityPool,
    weaponQty: 1,
    wordQty: elementalQty,
    rarityQty: 0, // No guaranteed rarity slot
    price: S.cratePrices.world_sky,
    qty: 1 + elementalQty, // Removed +1 for rarity
    words: []
  });

  shopCrates.push({
    type: 'body_soul',
    name: 'Body & Soul',
    elements: bodySoulElements,
    weaponPool: weaponPool,
    wordPool: bodySoulWordPool,
    t1RarityPool: t1RarityPool,
    t2RarityPool: t2RarityPool,
    t3RarityPool: t3RarityPool,
    weaponQty: 1,
    wordQty: elementalQty,
    rarityQty: 0, // No guaranteed rarity slot
    price: S.cratePrices.body_soul,
    qty: 1 + elementalQty, // Removed +1 for rarity
    words: []
  });

  // Select consumables at random.
  shopConsumables = shuf([...CONSUMABLES]).slice(0,3);

  // Complimentary talent: One free random Tool every Shop
  if(S.talents && S.talents.includes('complimentary')){
    // Check tool limit before adding free tool
    const toolLimit = S.talents.includes('well_equipped') ? CONSUMABLE_LIMIT + 1 : CONSUMABLE_LIMIT;
    if(S.consumables.length < toolLimit){
      const freeToolPool = CONSUMABLES.filter(c => !S.consumables.includes(c.id));
      if(freeToolPool.length > 0){
        const freeTool = shuf([...freeToolPool])[0];
        S.consumables.push(freeTool.id);
      }
    }
  }
}

function renderShop(){
  // Update gold display and show current inventory count under the shop title
  $("#shop-gold").textContent = `${S.gold}`;

  // Update shop gold pill with new interest system display
  // Shows total interest earned on shop exit: gold interest (max +6) + slot interest (max +24)
  const { goldInterest, slotInterest, totalInterest, emptySlots } = calculateInterest();
  const shopGoldInterestEl = document.getElementById('shop-gold-interest');
  if(shopGoldInterestEl){
    if(totalInterest > 0){
      // Show breakdown: total (+gold from gold, +slots from empty slots)
      shopGoldInterestEl.innerHTML = `| +${totalInterest} <span style="font-size:9px;opacity:0.7">(${goldInterest}g+${slotInterest}s)</span>`;
      shopGoldInterestEl.title = `Interest on Exit: +${totalInterest}\n‚Ä¢ Gold: +${goldInterest} (${S.gold}/60g)\n‚Ä¢ Slots: +${slotInterest} (${emptySlots} empty)`;
    } else {
      shopGoldInterestEl.textContent = '';
      shopGoldInterestEl.title = '';
    }
  }

  // Render Round and Chapter Pills
  const roundEl = document.getElementById("shop-round-num");
  if(roundEl) roundEl.textContent = `${S.roundIndex}`;
  const shopChapter = Math.floor((S.roundIndex - 1) / 9) + 1;
  const chapterEl = document.getElementById("shop-chapter-num");
  if(chapterEl) chapterEl.textContent = `${shopChapter}`;

  const invEl = document.getElementById("shop-inventory");
  if(invEl){
    const visibleCount = S.inv.filter(w => !w.hiddenInBank).length;
    invEl.textContent = `${visibleCount}/${INV_LIMIT}`;
  }
  // Update shop inventory breakdown tooltip
  const shopInvTooltip = document.getElementById("shop-inv-breakdown-tooltip");
  if(shopInvTooltip) shopInvTooltip.innerHTML = generateInvBreakdown();
  const conEl = document.getElementById("shop-consumable-cap");
  if(conEl){
    conEl.textContent = `${S.consumables.length}/${CONSUMABLE_LIMIT}`;
    conEl.classList.toggle("at-limit", S.consumables.length>=CONSUMABLE_LIMIT);
  }

  // Render hero portrait in shop
  const shopHeroPort = document.getElementById('shop-hero-portrait-container');
  if(shopHeroPort) {
    // Get hero ID from multiple sources for robustness
    let heroPortraitId = null;
    if(S.hero && S.hero.id) {
      heroPortraitId = S.hero.id;
    } else if(S.heroId) {
      heroPortraitId = S.heroId;
    } else if(S.hero && S.hero.name) {
      // Final fallback: look up hero by name
      const heroTemplate = HEROES.find(h => h.name === S.hero.name);
      if(heroTemplate) heroPortraitId = heroTemplate.id;
    }
    if(heroPortraitId) {
      // Pass 'shop' suffix to ensure unique IDs vs the battle view
      const heroSvg = getPortraitSVG(heroPortraitId, 'shop');
      shopHeroPort.innerHTML = `<div class="portrait-frame">${heroSvg}</div>`;
    }
  }

  // Populate hero info within the shop.  Display the hero's strengths, weaknesses
  // and weapon proficiencies so players know what to keep or sell.
  const heroInfo = document.getElementById("shop-hero-info");
  if(heroInfo){
    if(!S.hero){
      heroInfo.textContent = '';
  } else {
      const h = S.hero;
      // Build tag elements for strengths and weaknesses
      const strongTags = h.str.map(i => `<span class="tag str">${EN[i]}</span>`).join('');
      // Belle Lettres: show randomized weaknesses from Studious passive
      const displayWeaknesses = (h.name === "Belle Lettres" && S.belleRandomWeaknesses)
        ? S.belleRandomWeaknesses
        : h.weak;
      const weakTags = displayWeaknesses.map(i => `<span class="tag weak">${EN[i]}</span>`).join('');
      // Weapon proficiency tags
      const goodProf = h.good ? (h.good.charAt(0).toUpperCase() + h.good.slice(1)) : 'None';
      const badProf = h.bad ? (h.bad.charAt(0).toUpperCase() + h.bad.slice(1)) : 'None';
      const hasOvercoming = S.talents && S.talents.includes('overcoming');
      const badProfHtml = hasOvercoming
        ? `<span class="tag prof">${badProf} √ó1.5 W</span>`
        : `<span class="tag weak">${badProf} √ó0.5 W</span>`;
      heroInfo.innerHTML =
        `<div style="margin-bottom:2px"><span class="hero-c" style="font-weight:bold;font-size:13px">${h.name}</span></div>`+
        `<div style="margin-bottom:2px"><span class="dim" style="font-size:10px">Strong:</span> ${strongTags || '<span class="dim">None</span>'}</div>`+
        `<div style="margin-bottom:2px"><span class="dim" style="font-size:10px">Weak:</span> ${weakTags || '<span class="dim">None</span>'}</div>`+
        `<div><span class="dim" style="font-size:10px">Proficient:</span> <span class="tag prof">${goodProf} √ó2 W</span> ${badProfHtml}</div>`;
    }
  }
  // Update talent count in topbar button
  const talentCountEl = document.getElementById('shop-talent-count');
  if(talentCountEl) talentCountEl.textContent = S.talents ? S.talents.length : 0;

  // Preview next enemy
  renderNextEnemyPreview();

  renderShopCrates();
  renderShopWordBank(false); // Don't animate by default - only animate on word changes
  renderShopTalents();
  renderShopConsumables();
}

function renderNextEnemyPreview(){
  // Calculate what the next enemy will be
  const nextRound = S.roundIndex;
  const isChapterBoss = nextRound % 9 === 0;
  const isMiniboss = nextRound % 3 === 0 && !isChapterBoss;

  // For boss rounds, pre-select the chapter boss (5% chance for Secret Boss)
  if(isChapterBoss && !S.nextChapterBoss){
    if(Math.random() < SECRET_BOSS_SPAWN_CHANCE){
      // Rare Secret Boss spawn!
      S.nextChapterBoss = SECRET_CHAPTER_BOSS;
    } else {
      let availableBosses = CHAPTER_BOSSES.filter(b => !S.foughtChapterBosses.includes(b.id));
      if(availableBosses.length === 0){
        availableBosses = [...CHAPTER_BOSSES];
      }
      S.nextChapterBoss = availableBosses[Math.floor(Math.random() * availableBosses.length)];
    }
  }

  if(!S.nextEnemyData){
    const roll = ENEMIES[Math.floor(Math.random() * ENEMIES.length)] || ENEMIES[0];
    S.nextEnemyData = {...roll};
    randomizeEnemyElements(S.nextEnemyData);
  }
  const previewEnemy = {...S.nextEnemyData};
  previewEnemy.weak = [...S.nextEnemyData.weak];
  previewEnemy.res = [...S.nextEnemyData.res];

  // Apply HP scaling (use loop-based scaling for endless mode)
  previewEnemy.hp = enemyHp(nextRound);

  // Chapter boss: override with boss data
  if(isChapterBoss && S.nextChapterBoss){
    previewEnemy.name = S.nextChapterBoss.name;
    previewEnemy.id = S.nextChapterBoss.id;
    previewEnemy.ability = S.nextChapterBoss.ability;
    previewEnemy.isChapterBoss = true;
    previewEnemy.isSecretBoss = S.nextChapterBoss.isSecretBoss || false;
    // Chapter bosses: 1 weakness, 2 resistances (unless they have custom arrays)
    if(S.nextChapterBoss.weak){
      previewEnemy.weak = [...S.nextChapterBoss.weak];
    } else {
      // Default: bosses keep only 1 weakness
      previewEnemy.weak = previewEnemy.weak.slice(0, 1);
    }
    if(S.nextChapterBoss.res){
      previewEnemy.res = [...S.nextChapterBoss.res];
    } else {
      // Default: bosses keep 2 resistances (strengths)
      previewEnemy.res = previewEnemy.res.slice(0, 2);
    }
    // Secret boss uses hpMultiplier instead of standard 1.3x boss boost
    if(S.nextChapterBoss.hpMultiplier){
      previewEnemy.hp = Math.round(previewEnemy.hp * S.nextChapterBoss.hpMultiplier);
    } else {
      previewEnemy.hp = Math.round(previewEnemy.hp * 1.3);
    }
  }

  // Miniboss: +30% HP boost
  if(isMiniboss && !isChapterBoss){
    previewEnemy.isMiniboss = true;
    previewEnemy.hp = Math.round(previewEnemy.hp * 1.3);
  }

  // Belle Lettres "Studious" passive preview: +2 enemy weaknesses, random hero weaknesses
  if(S.hero && S.hero.name === "Belle Lettres"){
    const allElements = [E.PHYS, E.POISON, E.FIRE, E.WATER, E.LIGHT, E.DARK, E.EARTH, E.LIGHTNING];

    // Pre-randomize Belle's weaknesses for this round (if not already done)
    if(!S.belleRandomWeaknesses){
      const availableForHero = allElements.filter(el => !S.hero.str.includes(el));
      S.belleRandomWeaknesses = [...availableForHero].sort(() => Math.random() - 0.5).slice(0, 2);
    }

    // Add +2 weaknesses to enemy preview (excluding their resistances and existing weaknesses)
    // Only randomize if not already set to prevent values changing during shop
    if(!S.nextEnemyBonusWeaknesses){
      const availableForEnemy = allElements.filter(el => !previewEnemy.weak.includes(el) && !previewEnemy.res.includes(el));
      S.nextEnemyBonusWeaknesses = [...availableForEnemy].sort(() => Math.random() - 0.5).slice(0, 2);
    }
    previewEnemy.weak = [...previewEnemy.weak, ...S.nextEnemyBonusWeaknesses];
  }

  // Update S.enemy with the preview enemy so tooltips show effectiveness vs. NEXT enemy
  S.enemy = previewEnemy;

  // Render enemy portrait in shop (after S.enemy is set to preview)
  const shopEnemyPort = document.getElementById('shop-enemy-portrait-container');
  if(shopEnemyPort && S.enemy) {
    // Pass 'shop-enemy' suffix to ensure unique IDs vs the battle view
    const enemySvg = getPortraitSVG(S.enemy.id, 'shop-enemy');
    shopEnemyPort.innerHTML = `<div class="portrait-frame">${enemySvg}</div>`;
  }

  // Update UI - format same as HERO INFO with tag structure
  const enemyPreview = $("#next-enemy-preview");
  if(enemyPreview){
    const hasIronyTalent = S.talents && S.talents.includes('irony');

    // Plague Doctor: Immune to hero's primary strength element
    // Shackles consumable disables this ability
    const shacklesActive = S.tempEffects && S.tempEffects.disableBossAbility;
    let plagueDoctorImmune = null;
    if(previewEnemy.id === 'plague_doctor' && S.hero && !shacklesActive){
      if(S.hero.str && S.hero.str.length > 0){
        plagueDoctorImmune = S.hero.str[0]; // Primary strength = immune
      }
    }

    // Display enemy weaknesses
    const displayWeak = previewEnemy.weak && previewEnemy.weak.length > 0 ? previewEnemy.weak : [];
    const weakTags = displayWeak.length > 0
      ? displayWeak.map(e=>`<span class="tag str">${EN[e]}</span>`).join('')
      : '<span class="dim">None</span>';

    // Display resistances + Plague Doctor immunity
    const displayRes = [...(previewEnemy.res || [])];
    let resTags = '';
    if(displayRes.length > 0 || plagueDoctorImmune !== null){
      const resTagsArr = displayRes.map((e, idx)=>{
        if(hasIronyTalent && idx === 0){
          return `<span class="tag irony">${EN[e]} <span class="irony-badge">Irony</span></span>`;
        }
        return `<span class="tag weak">${EN[e]}</span>`;
      });
      // Add Plague Doctor immunity as special tag
      if(plagueDoctorImmune !== null){
        resTagsArr.push(`<span class="tag weak" style="background:#4a0000;border-color:#990000">${EN[plagueDoctorImmune]} <span style="font-size:8px;opacity:0.8">(IMMUNE)</span></span>`);
      }
      resTags = resTagsArr.join('');
    } else {
      resTags = '<span class="dim">None</span>';
    }

    // Boss ability display
    let abilityHtml = '';
    if(previewEnemy.ability){
      abilityHtml = `<div style="margin-top:8px;padding:8px;background:#2a1a2a;border:1px solid #9966cc;border-radius:6px">
        <div style="color:#a78bfa;font-size:11px;font-weight:bold">${previewEnemy.ability.icon || icon('lightning')} ${previewEnemy.ability.name}</div>
        <div style="color:#9ca3af;font-size:10px;margin-top:4px">${previewEnemy.ability.desc}</div>
      </div>`;
    }

    // Boss/Miniboss tag (both use purple ability style)
    let bossTag = '';
    if(previewEnemy.isChapterBoss){
      bossTag = ' <span class="tag ability">Boss</span>';
    } else if(previewEnemy.isMiniboss){
      bossTag = ' <span class="tag ability">Mini-Boss</span>';
    }

    enemyPreview.innerHTML =
      `<div style="margin-bottom:8px"><span class="enemy-c" style="font-weight:bold;font-size:14px">${previewEnemy.name}</span>${bossTag}</div>`+
      `<div style="margin-bottom:4px"><span class="dim" style="font-size:11px">HP:</span> <span class="gold">${previewEnemy.hp}</span></div>`+
      `<div style="margin-bottom:4px"><span class="dim" style="font-size:11px">Weak to:</span> ${weakTags}</div>`+
      `<div style="margin-bottom:4px"><span class="dim" style="font-size:11px">Resists:</span> ${resTags}</div>`+
      abilityHtml;
  }
}

function renderShopCrates(){
  const cont = $("#shop-crates");
  cont.innerHTML = "";

  shopCrates.forEach((crate, i) => {
    const d = document.createElement("div");
    // Add crate-type specific class for iridescent effect
    const crateTypeClass = crate.type === 'world_sky' ? 'crate-earth-sky' : crate.type === 'body_soul' ? 'crate-body-soul' : '';
    d.className = `shop-item card-surface crate-clickable ${crateTypeClass}`;
    d.style.cssText = "min-width:150px;max-width:180px;cursor:pointer";

    // Crate type icons and colors for themed crates
    const crateIcons = {
      world_sky: {icon: icon('earth-sky'), color: '#4ade80', subtitle: 'Fire ‚Ä¢ Water ‚Ä¢ Earth ‚Ä¢ Lightning'},
      body_soul: {icon: icon('body-soul'), color: '#a78bfa', subtitle: 'Physical ‚Ä¢ Poison ‚Ä¢ Light ‚Ä¢ Dark'}
    };

    const crateInfo = crateIcons[crate.type] || {icon: icon('crate'), color: '#9ca3af', subtitle: ''};

    // Determine effective price after any shop discount talents
    const hasTalent = (id) => S.talents.includes(id);
    let effectivePrice = crate.price;
    if(hasTalent('merchant_guild')){
      effectivePrice = Math.ceil(effectivePrice * 0.5);
    }
    if(hasTalent('bargain_hunter')){
      effectivePrice = Math.ceil(effectivePrice * 0.8);
    }

    const canAfford = S.gold >= effectivePrice;
    if(!canAfford) d.classList.add('crate-disabled');

    d.innerHTML = `
      <div style="font-size:14px;font-weight:bold;color:${crateInfo.color};margin-bottom:4px">${crate.name}</div>
      <div style="font-size:9px;color:#6b7280;margin-bottom:6px">${crateInfo.subtitle || ''}</div>
      <div style="font-size:11px;color:#9ca3af;margin-bottom:8px">1 Weapon + ${crate.wordQty} Elemental + 1 Rarity</div>
      <div class="shop-price gold">${icon('coin')}${effectivePrice}</div>
    `;

    // Play hover sound on crate card
    d.onmouseenter = () => { if(canAfford) sfxHover(); };
    d.onclick = async () => {
      // Compute effective price again inside the click handler to avoid closure issues
      let priceToPay = crate.price;
      if(hasTalent('merchant_guild')) priceToPay = Math.ceil(priceToPay * 0.5);
      if(hasTalent('bargain_hunter')) priceToPay = Math.ceil(priceToPay * 0.8);
      // Verify sufficient gold
      if(S.gold >= priceToPay){
        // Check if there's space for the crate's quantity of words
        const needed = crate.qty;
        // Only count visible words (exclude hiddenInBank words)
        const visibleCount = S.inv.filter(w => !w.hiddenInBank).length;
        if(visibleCount + needed > INV_LIMIT){
          showQuickToast(`Not enough inventory space! Need ${needed - (INV_LIMIT - visibleCount)} more slot(s).`);
          return;
        }

        // Play buy sound
        playSample('buy_crate.ogg', 0.9);

        // Create gold burst effect at the crate card
        const cardRect = d.getBoundingClientRect();
        goldBurst(cardRect.left + cardRect.width / 2, cardRect.top + cardRect.height / 2);

        // [T2] Ninja Loot: 20% chance for free crate
        const isFree = hasTalent('ninja_loot') && Math.random() < 0.20;
        if(!isFree){
          S.gold -= priceToPay;
          // Track gold spent for talents
          S.goldSpent = (S.goldSpent || 0) + priceToPay;
        }
        // Track crates opened for talents
        S.cratesOpened = (S.cratesOpened || 0) + 1;

        // Show reel animation that rolls words dynamically (casino-style)
        // Words are determined at reveal time, not pre-rolled
        const wordsToAdd = await showCrateReelAnimation(crate);

        // Play tier sound based on revealed words
        sfxCrateTier(wordsToAdd);

        // Record positions BEFORE adding words for FLIP animation
        if (!gfxSettings.lowFx) {
          recordFlipPositions($("#shop-word-bank"));
        }

        wordsToAdd.forEach(w => {
          S.inv.push({ ...w });
        });
        checkHoarderAchievement();

        // Increase crate price (25 ‚Üí 38 ‚Üí 57 ‚Üí 86 ‚Üí 129..., capped at 150)
        // 1.5x scaling makes multiple crates more accessible
        const currentPrice = S.cratePrices[crate.type] || 25;
        S.cratePrices[crate.type] = Math.min(Math.ceil(currentPrice * 1.5), 150);
        crate.price = S.cratePrices[crate.type];

        renderShop();
        // Play FLIP animation on shop word bank after render (new words pop in) - defer to avoid layout thrashing
        if (!gfxSettings.lowFx) {
          requestAnimationFrame(() => playFlipAnimation($("#shop-word-bank")));
        }
        render();

        // Tutorial hook: notify tutorial system of crate purchase
        if (typeof onTutorialCratePurchased === 'function') {
          onTutorialCratePurchased();
        }
      }
    };

    cont.appendChild(d);
  });

  if(shopCrates.length === 0){
    cont.innerHTML = '<div class="dim" style="padding:10px;font-size:11px">Sold out!</div>';
  }
}


// Track multiple selected words for selling
let selectedSellWords = [];

function renderShopWordBank(animate = true){
  const cont = $("#shop-word-bank");

  // Record positions before DOM changes for FLIP animation
  if (animate && !gfxSettings.lowFx) {
    recordFlipPositions(cont);
  }

  cont.innerHTML = "";
  // Reset selection at the start of rendering
  selectedSellWords = [];
  document.getElementById("sell-word-btn").textContent = "Sell Selected";
  document.getElementById("sell-word-btn").disabled = true;

  // Sort and filter inventory using the same logic as forge bank and apply ascending/descending order
  const sorted = getSortedVisibleBankWords(S.inv, S.shopSortMode, S.shopSortAsc);

  sorted.forEach((word) => {
    const chip = document.createElement("div");
    chip.className = "chip has-tooltip";
    // Add word ID for FLIP animation tracking
    if (word.id) chip.dataset.wordId = word.id;
    if(word.rarity === T.T0) chip.classList.add("rusty");
    if(word.type === 'weapon') chip.classList.add('weapon-tile');

    const rarityClass = TC[word.rarity] || TC[0];
    const tierText = TN[word.rarity] || "T1";

    // Add element display if word has an element (or multiplier for non-elemental words)
    let elemHtml = "";
    if(word.elem !== undefined){
      elemHtml = `<div class="chip-elem" style="color:${EC[word.elem]}">${EN[word.elem]}</div>`;
    } else if(word.mult && word.mult !== 1){
      // Non-elemental words (Common->Legendary adjectives) show multiplier as a badge with mono font
      elemHtml = `<span class="mod-badge scale" style="margin-top:2px;font-size:9px">√ó${word.mult}</span>`;
    }

    // Generate color tab and tier classes based on word type
    let tabHtml = "";
    const elemTabClasses = ['elem-phys','elem-poison','elem-fire','elem-water','elem-light','elem-dark','elem-earth','elem-lightning'];
    const elemWashClasses = ['elem-wash-phys','elem-wash-poison','elem-wash-fire','elem-wash-water','elem-wash-light','elem-wash-dark','elem-wash-earth','elem-wash-lightning'];

    if(word.type === 'elemental' && word.elem !== undefined){
      tabHtml = `<div class="chip-tab ${elemTabClasses[word.elem] || ''}"></div>`;
      if(word.rarity === T.T2){
        chip.classList.add('tier-wash-2', elemWashClasses[word.elem] || '');
      } else if(word.rarity === T.T3){
        chip.classList.add('tier-wash-3', elemWashClasses[word.elem] || '');
      }
    } else if(word.type === 'rarity'){
      const rarityTier = word.rarity === T.T3 ? 'rarity-t3' : word.rarity === T.T2 ? 'rarity-t2' : 'rarity-t1';
      chip.classList.add('rarity-word', rarityTier);
    }

    // Generate tooltip using the same function as forge
    const tooltip = mkTooltip(word);

    // Determine display name using the base (noun) form for non‚Äëweapons to match forge naming.
    let displayName = word.name;
    if(word.type !== 'weapon' && !word.isStick){
      displayName = getDisplayForm(word, 'noun1', null) || word.name;
    }
    // Determine the info label: for weapons, show category only
    let infoLabel = '';
    if(word.type === 'weapon' && word.category){
      const cat = word.category;
      infoLabel = cat.charAt(0).toUpperCase() + cat.slice(1);
    }

    // Word name color: neutral white for elemental (tab shows element), tier color for others
    const nameColorClass = (word.type === 'elemental') ? '' : rarityClass;

    // Tier badge in top-right corner
    const tierBadge = `<div class="chip-tier tier-${word.rarity}">${tierText}</div>`;

    chip.innerHTML = `
      ${tabHtml}
      ${tierBadge}
      <div class="chip-name ${nameColorClass}">${displayName}</div>
      <div class="chip-info">${infoLabel}</div>
      ${elemHtml}
      ${tooltip}
    `;

    chip.onclick = () => {
      // Play highlight sound when selecting/deselecting
      playSample('highlight word.ogg', 0.5);

      // Toggle selection for this chip
      const idx = S.inv.indexOf(word);
      const existingIndex = selectedSellWords.findIndex(x => x.idx === idx);
      if(existingIndex >= 0){
        // Remove from selection
        selectedSellWords.splice(existingIndex, 1);
        chip.classList.remove("selected");
      } else {
        // Add to selection
        selectedSellWords.push({word, idx});
        chip.classList.add("selected");
      }
      // Recalculate total sell price
      let total = 0;
      selectedSellWords.forEach(({word}) => {
        const tier = word.rarity || 0;
        // Sell prices: T1=1g, T2=2g, T3=5g
        let sellPrice = tier === 0 ? 1 : tier === 2 ? 2 : 5;
        // Golden Tongue talent: +50% sell price
        if(S.talents && S.talents.includes('golden_tongue')){
          sellPrice = Math.ceil(sellPrice * 1.5);
        }
        total += sellPrice;
      });
      const sellBtn = document.getElementById("sell-word-btn");
      if(total > 0){
        sellBtn.innerHTML = `Sell Selected (${total}${icon('coin')})`;
        sellBtn.disabled = false;
      } else {
        sellBtn.textContent = "Sell Selected";
        sellBtn.disabled = true;
      }
    };
    // Hover sfx for chips
    chip.onmouseenter = sfxHover;

    // Drag-and-drop disabled - use click-to-select instead
    chip.draggable = false;

    cont.appendChild(chip);
  });

  if(sorted.length === 0){
    cont.innerHTML = '<div class="dim" style="padding:10px;font-size:11px">No words in inventory</div>';
  }

  // Play FLIP animation after DOM is rebuilt - defer to avoid layout thrashing
  if (animate && !gfxSettings.lowFx) {
    requestAnimationFrame(() => playFlipAnimation(cont));
  }
}

function renderShopConsumables(){
  const shopCont=$("#shop-consumables");
  const ownedCont=$("#shop-owned-consumables");
  if(!shopCont||!ownedCont) return;
  shopCont.innerHTML="";
  ownedCont.innerHTML="";

  const buildTooltip=(c)=>{
    const name=c?.name||"Consumable";
    const desc=c?.desc||"Consumable";
    return `<div class="tooltip"><div class="tooltip-title">${name}</div><div class="tooltip-line">${desc}</div></div>`;
  };

  const makeChip=(c,mode,index)=>{
    const chip=document.createElement("div");
    chip.className="consumable-item has-tooltip";
    chip.onmouseenter=sfxHover;

    const name=c?.name||"Consumable";
    let cost=c?.cost||0;
    // Apply difficulty price multiplier (Adept +25%, Master +50%)
    cost = Math.ceil(cost * DIFF_PRICE_MULT[S.difficulty || 0]);
    // Tinkerer talent: Tools cost 25% less
    if(S.talents && S.talents.includes('tinkerer')){
      cost = Math.ceil(cost * 0.75);
    }
    const tooltip=buildTooltip(c);

    if(mode==="shop"){
      // Well Equipped talent: +1 Tool limit (2 -> 3)
      const toolLimit = (S.talents && S.talents.includes('well_equipped')) ? CONSUMABLE_LIMIT + 1 : CONSUMABLE_LIMIT;
      const atLimit=S.consumables.length>=toolLimit;
      const canAfford=S.gold>=cost;
      const infoLabel=`${atLimit?"At capacity":"Buy"} ¬∑ ${icon('coin')}${cost}`;
      if(atLimit||!canAfford){
        chip.classList.add("disabled");
      }
      chip.innerHTML=`<div class="chip-name" style="color:#fbbf24">${name}</div><div class="chip-info">${infoLabel}</div>${tooltip}`;
      chip.onclick=()=>{
        if(atLimit){
          showQuickToast(`You can only carry ${toolLimit} Tools.`);
          return;
        }
        if(!canAfford){
          showQuickToast(`Not enough gold! Need ${icon('coin')}${cost}, have ${icon('coin')}${S.gold}`);
          return;
        }
        if(S.gold>=cost){
          playSample('buy_crate.ogg', 0.9);

          // Play buy animation - pop and fly away effect
          chip.animate([
            { transform: 'scale(1)', opacity: 1 },
            { transform: 'scale(1.2)', opacity: 1, offset: 0.2 },
            { transform: 'scale(0.8) translateY(-20px)', opacity: 0.7, offset: 0.5 },
            { transform: 'scale(0.5) translateY(-40px)', opacity: 0, offset: 1 }
          ], { duration: 300, easing: 'ease-out', fill: 'forwards' });

          // Create spark effect at the consumable chip
          const chipRect = chip.getBoundingClientRect();
          burstSparks(chipRect.left + chipRect.width / 2, chipRect.top + chipRect.height / 2, 20, ['#4ade80', '#22c55e', '#16a34a']);

          S.gold-=cost;
          S.goldSpent = (S.goldSpent || 0) + cost; // Track gold spent
          S.consumables.push(c.id);
          shopConsumables.splice(index,1);

          // Delay render slightly to let animation play
          setTimeout(() => {
            renderShop();
            render();
          }, 150);
        }
      };
    } else {
      const sellPrice=Math.max(1,Math.floor(cost/2));
      chip.onclick=()=>{
        const idx=S.consumables.indexOf(c?.id||index);
        if(idx>=0){
          playSample('highlight word.ogg', 0.5);
          S.consumables.splice(idx,1);
          S.gold+=sellPrice;
          renderShop();
          render();
        }
      };
      chip.innerHTML=`<div class="chip-name" style="color:#fbbf24">${name}</div><div class="chip-info">Sell ¬∑ ${icon('coin')}${sellPrice}</div>${tooltip}`;
    }

    return chip;
  };

  const shopItems=shopConsumables.map((c,i)=>({item:c,mode:"shop",index:i}));
  const ownedItems=S.consumables.map((cid,i)=>({
    item:CONSUMABLES.find(x=>x.id===cid)||{id:cid,name:cid,desc:"Consumable",cost:0},
    mode:"owned",
    index:i
  }));

  if(shopItems.length===0){
    const empty=document.createElement("div");
    empty.className="dim";
    empty.style.fontSize="11px";
    empty.style.padding="6px";
    empty.textContent="Sold out!";
    shopCont.appendChild(empty);
  } else {
    shopItems.forEach(({item,mode,index})=>shopCont.appendChild(makeChip(item,mode,index)));
  }

  if(ownedItems.length===0){
    const empty=document.createElement("div");
    empty.className="dim";
    empty.style.fontSize="11px";
    empty.style.padding="6px";
    empty.textContent="No consumables owned";
    ownedCont.appendChild(empty);
  } else {
    ownedItems.forEach(({item,mode,index})=>ownedCont.appendChild(makeChip(item,mode,index)));
  }
}

// Render active talents within the shop overlay.  Each talent is displayed as a chip with its
// name and rarity colour.  Clicking a talent will sell it for gold based on its tier or rarity.
function renderShopTalents(){
  const bar = document.getElementById('shop-talent-bar');
  if(!bar) return;
  bar.innerHTML = '';

  if(!S.talents || S.talents.length === 0){
    bar.innerHTML = '<div class="dim" style="font-size:10px;padding:4px">No active Talents</div>';
    return;
  }

  // Container for header row (Count + Button)
  const headerDiv = document.createElement('div');
  headerDiv.style.cssText = "display:flex;justify-content:space-between;align-items:center;width:100%;margin-bottom:8px";

  // Count display
  const countDiv = document.createElement('div');
  countDiv.className = 'dim';
  countDiv.style.fontSize = '10px';
  countDiv.textContent = `${S.talents.length} Active Talents`;
  headerDiv.appendChild(countDiv);

  // View Button
  const viewBtn = document.createElement('button');
  viewBtn.textContent = "üëÅÔ∏è View All";
  viewBtn.style.cssText = "padding:2px 8px;font-size:10px;background:transparent;border:1px solid #4b5563;";
  viewBtn.onmouseenter = sfxHover;
  viewBtn.onclick = () => {
    openTalentViewer();
  };
  headerDiv.appendChild(viewBtn);

  bar.appendChild(headerDiv);

  // Render chips
  S.talents.forEach((tid) => {
    const t = TALENTS.find(x => x.id === tid);
    if(!t) return;
    const chip = document.createElement('div');
    chip.className = 'chip';
    const tierClassMap = {common: 'tier-1', uncommon: 'tier-2', rare: 'tier-3'};
    const tierClass = tierClassMap[t.rarity] || 'tier-1';
    const level = getTalentLevel(tid);
    const levelDisplay = level > 1 ? ` <span class="talent-level">Lv.${level}</span>` : '';
    const tooltip = mkTooltip(t);
    chip.innerHTML = `<div class="chip-name ${tierClass}">${t.name}${levelDisplay}</div><div class="chip-info">Talent</div>${tooltip}`;
    chip.style.cursor = 'default';
    chip.style.opacity = '0.9';
    bar.appendChild(chip);
  });
}

function rerollShop(){
  if(S.gold>=S.rerollCost){
    const cost = S.rerollCost;
    S.gold-=cost;
    S.goldSpent = (S.goldSpent || 0) + cost; // Track gold spent
    S.rerollCost=Math.min(Math.ceil(S.rerollCost*1.5),50);
    rollShop();playSample('buy_crate.ogg', 0.9);renderShop();render();
  }
}

function wPrice(w){
  let b=8;
  if(w.type==="weapon")b=12;
  else if(w.type==="adjective")b=Math.round((w.mult||1)*8);
  else if(w.type==="noun")b=Math.round((w.ap||4)*2.5);
  else if(w.type==="elemental")b=Math.round((w.mult||1.5)*6);
  return Math.max(5,Math.round(b*(w.rarity>=0?1+w.rarity*0.5:1)));
}

// === INVENTORY ===
function showInv(){
  const cont=$("#inv-list");cont.innerHTML="";
  // Only count visible words (exclude hiddenInBank words)
  const visibleCount = S.inv.filter(w => !w.hiddenInBank).length;
  $("#inv-count").textContent=`(${visibleCount} words)`;
  const sorted=sortInventory(S.inv);
  sorted.forEach(w=>{
    const c=document.createElement("div");c.className="chip";c.style.cursor="default";
    // Use base (noun) form for non‚Äëweapons
    let displayName = w.name;
    if(w.type !== 'weapon' && !w.isStick){
      displayName = getDisplayForm(w, 'noun1', null) || w.name;
    }
    // Determine info label: category for weapons only (tier is in badge)
    const tierLabel = TN[w.rarity] || 'T1';
    let infoLabel = '';
    if(w.type === 'weapon' && w.category){
      const cat = w.category;
      infoLabel = cat.charAt(0).toUpperCase() + cat.slice(1);
    }
    let elemHtml = w.elem !== undefined
      ? `<div class="chip-elem" style="color:${EC[w.elem]}">${EN[w.elem]}</div>`
      : (w.mult && w.mult !== 1 ? `<span class="mult-pill">√ó${w.mult}</span>` : "");

    // Generate color tab and tier classes based on word type
    let tabHtml = "";
    const elemTabClasses = ['elem-phys','elem-poison','elem-fire','elem-water','elem-light','elem-dark','elem-earth','elem-lightning'];
    const elemWashClasses = ['elem-wash-phys','elem-wash-poison','elem-wash-fire','elem-wash-water','elem-wash-light','elem-wash-dark','elem-wash-earth','elem-wash-lightning'];

    if(w.type === 'elemental' && w.elem !== undefined){
      tabHtml = `<div class="chip-tab ${elemTabClasses[w.elem] || ''}"></div>`;
      if(w.rarity === T.T2){
        c.classList.add('tier-wash-2', elemWashClasses[w.elem] || '');
      } else if(w.rarity === T.T3){
        c.classList.add('tier-wash-3', elemWashClasses[w.elem] || '');
      }
    } else if(w.type === 'rarity'){
      const rarityTier = w.rarity === T.T3 ? 'rarity-t3' : w.rarity === T.T2 ? 'rarity-t2' : 'rarity-t1';
      c.classList.add('rarity-word', rarityTier);
    }

    // Word name color: neutral white for elemental (tab shows element), tier color for others
    const nameColorClass = (w.type === 'elemental') ? '' : TC[w.rarity];

    // Tier badge in top-right corner
    const tierBadge = `<div class="chip-tier tier-${w.rarity}">${tierLabel}</div>`;

    c.innerHTML=`${tabHtml}${tierBadge}<div class="chip-name ${nameColorClass}">${displayName}</div><div class="chip-info">${infoLabel}</div>${elemHtml}`;
    cont.appendChild(c);
  });
  $("#inv-overlay").classList.add("show");
}

// === UTILS ===
function clrSel(){stopAllRarityDrones();S.sel={item:null,adj1:null,adj2:null,adj3:null,adj4:null,noun1:null}}
function shuf(a){for(let i=a.length-1;i>0;i--){const j=Math.random()*(i+1)|0;[a[i],a[j]]=[a[j],a[i]]}return a}
function dly(ms){return new Promise(r=>setTimeout(r,ms))}
function anim(el,f,t,d,fmt=v=>Math.round(v)){return new Promise(res=>{const st=performance.now(),tick=n=>{const p=Math.min((n-st)/d,1);el.textContent=fmt(f+(t-f)*p);p<1?requestAnimationFrame(tick):res()};requestAnimationFrame(tick)})}

// Build REREAD pass schedule: loops through weapon phrase, exhausting words as their reread counts deplete
// Returns array of arrays, each containing word indices for that pass
function buildRereadPasses(words) {
  const remaining = words.map(w => w.retriggerCount || 1);
  const passes = [];
  while (remaining.some(r => r > 0)) {
    const pass = [];
    for (let i = 0; i < remaining.length; i++) {
      if (remaining[i] > 0) {
        pass.push(i);
        remaining[i]--;
      }
    }
    if (pass.length > 0) passes.push(pass);
  }
  return passes;
}

// Update enemy HP bar color based on remaining HP percentage
function updateHPBarState(barEl, barOuter, hpPercent){
  if(!barEl) return;
  // Remove all HP state classes
  barEl.classList.remove('hp-high','hp-mid','hp-low','hp-critical');
  // Add appropriate class based on HP percentage
  if(hpPercent > 60){
    barEl.classList.add('hp-high');
  } else if(hpPercent > 30){
    barEl.classList.add('hp-mid');
  } else if(hpPercent > 10){
    barEl.classList.add('hp-low');
  } else {
    barEl.classList.add('hp-critical');
  }
  // Add shake effect when taking significant damage (below 50%)
  if(barOuter && hpPercent < 50){
    barOuter.classList.add('shake');
    setTimeout(() => barOuter.classList.remove('shake'), RHYTHM.HALF);
  }
}

// Update enemy HP bar color for result screen - damage-based coloring (starts red, gets darker)
function updateHPBarDamageState(barEl, barOuter, damagePercent){
  if(!barEl) return;
  // Remove all HP state classes
  barEl.classList.remove('hp-high','hp-mid','hp-low','hp-critical');
  // Add appropriate class based on damage dealt (inverted logic - more damage = darker red)
  if(damagePercent < 25){
    barEl.classList.add('hp-low'); // Light red at start
  } else if(damagePercent < 50){
    barEl.classList.add('hp-low'); // Still light red
  } else if(damagePercent < 75){
    barEl.classList.add('hp-critical'); // Darker red
  } else {
    barEl.classList.add('hp-critical'); // Darkest red
  }
  // Add shake effect when significant damage dealt (above 40%)
  if(barOuter && damagePercent > 40){
    barOuter.classList.add('shake');
    setTimeout(() => barOuter.classList.remove('shake'), RHYTHM.HALF);
  }
}

// Round intro animation (Hearthstone-style hero/enemy entrance)
let introDismissPromise = null;

function showRoundIntro() {
  // Skip intro if no hero or enemy selected
  if (!S.hero || !S.enemy) {
    introDismissPromise = Promise.resolve();
    return;
  }
  // Start a fresh dialogue session for this intro
  const session = startDialogueSession();

  // Create intro overlay if it doesn't exist
  let overlay = document.getElementById('round-intro-overlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'round-intro-overlay';
    document.body.appendChild(overlay);
  }

  // Get random dialogue from hero and enemy
  // Round 1: Use runStartDialogue if available
  // Otherwise: Try enemy-specific hero dialogue first, fall back to generic
  let heroDialogue;
  if (S.roundIndex === 1 && S.hero.runStartDialogue) {
    heroDialogue = S.hero.runStartDialogue;
  } else {
    const enemySpecificDialogue = getHeroEnemyDialogue(S.hero.id, S.enemy.id);
    heroDialogue = enemySpecificDialogue || S.hero.dialogue?.[Math.floor(Math.random() * S.hero.dialogue.length)] || "...";
  }
  const enemyDialogue = S.enemy.dialogue?.[Math.floor(Math.random() * S.enemy.dialogue.length)] || "...";

  // Get round info
  const isBoss = S.enemy.boss || false;
  const isChapterBoss = S.enemy.isChapterBoss || false;
  const isMiniboss = isBoss && !isChapterBoss;
  let roundLabel = `Round ${S.roundIndex}`;
  if (isChapterBoss) {
    roundLabel = `CHAPTER BOSS - Round ${S.roundIndex}`;
  } else if (isMiniboss) {
    roundLabel = `MINIBOSS - Round ${S.roundIndex}`;
  }

  // Build modifier badges for bosses
  let modifierHtml = '';
  // Chapter bosses show their unique ability (plain text, no icon)
  if (isChapterBoss && S.enemy.ability) {
    const ability = S.enemy.ability;
    // For Red Aktins, show which slot is blocked
    let abilityDesc = ability.desc;
    if (S.chapterBoss && S.chapterBoss.id === 'red_aktins' && S.blockedSlot) {
      const slotNames = {adj1: 'Prefix 1', adj2: 'Prefix 2', adj3: 'Suffix 1', adj4: 'Suffix 2', noun1: 'Gem'};
      abilityDesc = `${slotNames[S.blockedSlot]} slot is [REDACTED]`;
    }
    modifierHtml = `
      <div class="intro-ability">
        <span class="ability-name">${ability.name}:</span>
        <span class="ability-desc">"${abilityDesc}"</span>
      </div>
    `;
  } else if (isBoss && S.enemy.modifiers && S.enemy.modifiers.length > 0) {
    const modBadges = S.enemy.modifiers.map(m =>
      `<span class="intro-modifier" title="${m.desc}">${m.icon} ${m.name}</span>`
    ).join('');
    modifierHtml = `<div class="intro-modifiers">${modBadges}</div>`;
  }

  // Build the intro HTML - dialogues start empty and animate in
  overlay.innerHTML = `
    <div class="intro-content">
      <div class="intro-round-label ${isBoss ? 'boss' : ''}">${roundLabel}</div>
      <div class="intro-versus">
        <div class="intro-combatant intro-hero">
          <div class="intro-portrait hero-side">
            <div class="intro-portrait-frame"></div>
          </div>
          <div class="intro-name">${S.hero.name}</div>
          <div class="intro-dialogue" id="intro-hero-dialogue"></div>
        </div>
        <div class="intro-vs">VS</div>
        <div class="intro-combatant intro-enemy">
          <div class="intro-portrait enemy-side">
            <div class="intro-portrait-frame"></div>
          </div>
          <div class="intro-name">${S.enemy.name}</div>
          ${modifierHtml}
          <div class="intro-dialogue" id="intro-enemy-dialogue"></div>
        </div>
      </div>
      <div class="intro-hint">Click to continue</div>
    </div>
  `;

  // Word-by-word dialogue animation helper
  const animateDialogue = (elementId, text, speakerType) => {
    const el = document.getElementById(elementId);
    if (!el || !text) return;
    const words = text.split(' ');
    let i = 0;
    el.textContent = '"';
    const portraitEl = el.closest('.intro-combatant')?.querySelector('.intro-portrait-frame');

    const showNextWord = () => {
      if (!session || session.canceled) return;
      if (i < words.length) {
        if (i > 0) el.textContent += ' ';
        el.textContent += words[i];
        i++;

        // Play talk sound and wiggle portrait
        playTalkSound(speakerType);
        if (portraitEl) {
          portraitEl.classList.add('speaking');
          scheduleDialogueTimeout(session, () => portraitEl.classList.remove('speaking'), 120);
        }

        scheduleDialogueTimeout(session, showNextWord, 150);
      } else {
        el.textContent += '"';
      }
    };
    showNextWord();
  };

  // Render portraits into the intro frames
  const heroFrame = overlay.querySelector('.hero-side .intro-portrait-frame');
  const enemyFrame = overlay.querySelector('.enemy-side .intro-portrait-frame');
  if (heroFrame) renderPortrait(heroFrame, S.hero.id, '#4ade80');
  if (enemyFrame) renderPortrait(enemyFrame, S.enemy.id || S.enemy.baseId, '#f87171');

  // Show overlay first
  overlay.classList.add('show');

  // Purple pulsing flame for Chapter Boss dialogue
  if (isChapterBoss) {
    setFlameColor('boss-dialogue');
  }

  // Calculate beat timing (BPM 136 = ~441ms per beat)
  const bpm = (musicEngine && musicEngine.bpm) || 136;
  const beatMs = Math.round(60000 / bpm);

  // Beat 1: Enemy enters (E3 - root note)
  scheduleDialogueTimeout(session, () => {
    overlay.querySelector('.intro-enemy')?.classList.add('entered');
    try { playBrassTone(164.81, 0.15, 0.08); } catch(e) {} // E3 entrance
  }, beatMs);

  // Beat 2: Enemy "talks" - animate dialogue word by word
  scheduleDialogueTimeout(session, () => {
    animateDialogue('intro-enemy-dialogue', enemyDialogue, 'enemy');
  }, beatMs * 2);

  // Beat 3: VS appears (B3 - fifth)
  scheduleDialogueTimeout(session, () => {
    overlay.querySelector('.intro-vs')?.classList.add('entered');
    try { playBrassTone(246.94, 0.1, 0.06); } catch(e) {} // B3 pop
  }, beatMs * 3);

  // Beat 4: Hero enters (E4 - octave up)
  scheduleDialogueTimeout(session, () => {
    overlay.querySelector('.intro-hero')?.classList.add('entered');
    try { playBrassTone(329.63, 0.15, 0.10); } catch(e) {} // E4 entrance
  }, beatMs * 4);

  // Beat 5: Hero "talks" - animate dialogue word by word
  scheduleDialogueTimeout(session, () => {
    animateDialogue('intro-hero-dialogue', heroDialogue, 'hero');
  }, beatMs * 5);

  // Store promise for waiting
  introDismissPromise = new Promise(resolve => {
    const dismiss = () => {
      overlay.classList.remove('show');
      overlay.removeEventListener('click', dismiss);
      cancelDialogueSession();
      // Keep purple flame for chapter boss battles
      if (isChapterBoss) {
        setFlameColor('boss-battle');
      }
      resolve();
    };

    overlay.addEventListener('click', dismiss);

    // Auto-dismiss 5 seconds after hero talks (beat 5)
    // Hero talks at beat 5, then wait 5000ms more
    scheduleDialogueTimeout(session, dismiss, beatMs * 5 + 5000);
  });
}

// Wait for intro to be dismissed
function waitForIntroDismiss() {
  return introDismissPromise || Promise.resolve();
}

// Scene transition - just runs callback with lock to prevent rapid clicks
let isTransitioning = false;

async function playSceneTransition(onPeak = null) {
  if (isTransitioning) return;
  isTransitioning = true;

  // Play transition sound
  try { playSample('transition.ogg', 0.5); } catch(e) {}

  // Execute callback
  if (onPeak) await onPeak();

  // Brief delay before unlocking to prevent rapid clicks
  await dly(RHYTHM.QUARTER);
  isTransitioning = false;
}

// Smart Drag Helper: DISABLED - use click-to-select instead
function setupSmartDrag(element, dragStartCallback, dragEndCallback) {
  // No-op: drag-and-drop disabled
  return;
}

const isShopOpen=()=>document.getElementById('shop-overlay')?.classList.contains('show');
function openPauseMenu(context='run'){
  const pauseMenu=document.getElementById('pause-menu');
  const pauseContinue=$("#pause-continue");
  if(pauseContinue){
    pauseContinue.textContent=context==='shop'?"Return to Shop":"Return to Run";
  }
  if(pauseMenu){
    pauseMenu.dataset.context=context;
    showOverlay(pauseMenu);
    playSfxOpen(); // "Open" sound for menu
  }
}
function closePauseMenu(silent = false){
  const pauseMenu=document.getElementById('pause-menu');
  if(pauseMenu){
    pauseMenu.classList.remove('show');
    pauseMenu.removeAttribute('data-context');
    if (!silent) playSfxBack(); // "Back" sound for closing menu (skip if opening another overlay)
  }
  const pauseContinue=$("#pause-continue");
  if(pauseContinue){
    pauseContinue.textContent="Return to Run";
  }
}

// === FIZZY SPARKS PARTICLE SYSTEM ===
/**
 * Creates a burst of animated particles at the specified position
 * @param {number} x - X position (pixels or percentage)
 * @param {number} y - Y position (pixels or percentage)
 * @param {Object} options - Configuration options
 * @param {number} options.count - Number of particles (default: 20)
 * @param {Array} options.colors - Array of color strings (default: gold colors)
 * @param {string} options.shape - 'circle', 'star', 'sparkle', 'mixed' (default: 'mixed')
 * @param {number} options.size - Base particle size in pixels (default: 8)
 * @param {number} options.velocity - Initial velocity multiplier (default: 1)
 * @param {number} options.gravity - Gravity strength (default: 0.3)
 * @param {number} options.duration - Particle lifetime in ms (default: 1500)
 * @param {HTMLElement} options.container - Container element (default: document.body)
 */
function createFizzySparks(x, y, options = {}) {
  const {
    count = 20,
    colors = ['#f4d03f', '#fbbf24', '#ff6633', '#9966cc', '#4d99ff'],
    shape = 'mixed',
    size = 8,
    velocity = 1,
    gravity = 0.3,
    duration = 1500,
    container = document.body,
    blur = 0,
    initialOpacity = 1
  } = options;

  const particles = [];
  const shapes = {
    circle: '‚óè',
    star: '‚òÖ',
    sparkle: '‚ú¶',
    diamond: '‚óÜ',
    square: '‚ñ†',
    line: '‚îÇ'
  };

  // Create particle container
  const particleContainer = document.createElement('div');
  particleContainer.style.cssText = `
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 99999;
  `;
  container.appendChild(particleContainer);

  // Create particles
  for (let i = 0; i < count; i++) {
    const particle = document.createElement('div');

    // Select shape
    let particleShape;
    let isLineShape = false;
    if (shape === 'mixed') {
      const shapeKeys = Object.keys(shapes);
      const selectedKey = shapeKeys[Math.floor(Math.random() * shapeKeys.length)];
      particleShape = shapes[selectedKey];
      isLineShape = selectedKey === 'line';
    } else {
      particleShape = shapes[shape] || shapes.circle;
      isLineShape = shape === 'line';
    }

    // Random color from palette
    const color = colors[Math.floor(Math.random() * colors.length)];

    // Random size variation
    const particleSize = size * (0.5 + Math.random() * 1.5);

    particle.textContent = particleShape;
    const filterEffects = blur > 0
      ? `drop-shadow(0 0 3px ${color}) blur(${blur}px)`
      : `drop-shadow(0 0 3px ${color})`;
    particle.style.cssText = `
      position: absolute;
      left: ${x}px;
      top: ${y}px;
      font-size: ${particleSize}px;
      color: ${color};
      pointer-events: none;
      user-select: none;
      filter: ${filterEffects};
      will-change: transform, opacity;
      opacity: ${initialOpacity};
    `;

    particleContainer.appendChild(particle);

    // Physics properties
    const angle = (Math.random() * Math.PI * 2);
    const speed = (2 + Math.random() * 4) * velocity;
    const particleData = {
      element: particle,
      x: x,
      y: y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - (2 + Math.random() * 2), // Initial upward bias
      rotation: Math.random() * 360,
      rotationSpeed: (Math.random() - 0.5) * 10,
      life: 1,
      decay: 1 / (duration / 16), // Decay per frame (assuming 60fps)
      gravity: gravity,
      friction: 0.98,
      initialOpacity: initialOpacity,
      isLine: isLineShape
    };

    particles.push(particleData);
  }

  // Animation loop
  const startTime = performance.now();
  const animate = (currentTime) => {
    const elapsed = currentTime - startTime;

    if (elapsed > duration) {
      particleContainer.remove();
      return;
    }

    particles.forEach(p => {
      // Apply physics
      p.vy += p.gravity; // Gravity
      p.vx *= p.friction; // Air resistance
      p.vy *= p.friction;

      p.x += p.vx;
      p.y += p.vy;
      p.life -= p.decay;

      // Calculate rotation based on velocity direction for line shapes
      if (p.isLine) {
        p.rotation = Math.atan2(p.vy, p.vx) * (180 / Math.PI) + 90; // +90 to align vertical line with direction
      } else {
        p.rotation += p.rotationSpeed;
      }

      // Update DOM
      const scale = p.life;
      const scaleX = p.isLine ? 0.3 : scale; // Lines are very thin
      const scaleY = p.isLine ? scale * 3 : scale; // Lines are much longer
      const opacity = Math.max(0, p.life * p.initialOpacity);
      p.element.style.transform = `translate(${p.x - x}px, ${p.y - y}px) rotate(${p.rotation}deg) scale(${scaleX}, ${scaleY})`;
      p.element.style.opacity = opacity;
    });

    requestAnimationFrame(animate);
  };

  requestAnimationFrame(animate);
}

/**
 * Create sparks at an element's position
 * @param {HTMLElement} element - Target element
 * @param {Object} options - Spark options (same as createFizzySparks)
 */
function createFizzySparksAtElement(element, options = {}) {
  const rect = element.getBoundingClientRect();
  const x = rect.left + rect.width / 2;
  const y = rect.top + rect.height / 2;
  createFizzySparks(x, y, options);
}

/**
 * Create gravity vortex effect (particles orbit around a center point)
 * @param {HTMLElement} element - Target element to orbit around
 * @param {Object} options - Vortex options
 */
function createGravityVortex(element, options = {}) {
  const {
    count = 20,
    colors = ['#ff6600', '#ff9933', '#ffcc00'],
    shape = 'sparkle',
    size = 4,
    duration = 2000,
    orbitRadius = 80,
    orbitSpeed = 0.05,
    spiralIn = true,
    intensity = 1 // 0 = no vortex, 1 = light, 2 = full
  } = options;

  if (intensity === 0 || !element) return null;

  const rect = element.getBoundingClientRect();
  const centerX = rect.left + rect.width / 2;
  const centerY = rect.top + rect.height / 2;

  const particles = [];
  const shapes = {
    circle: '‚óè',
    star: '‚òÖ',
    sparkle: '‚ú¶',
    diamond: '‚óÜ',
    square: '‚ñ†'
  };

  // Create particle container
  const particleContainer = document.createElement('div');
  particleContainer.style.cssText = `
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 99998;
  `;
  document.body.appendChild(particleContainer);

  // Create particles at random positions around the orbit
  for (let i = 0; i < count; i++) {
    const particle = document.createElement('div');

    // Select shape
    const particleShape = shapes[shape] || shapes.sparkle;

    // Random color from palette
    const color = colors[Math.floor(Math.random() * colors.length)];

    // Random size variation
    const particleSize = size * (0.7 + Math.random() * 0.6);

    particle.textContent = particleShape;
    particle.style.cssText = `
      position: absolute;
      font-size: ${particleSize}px;
      color: ${color};
      pointer-events: none;
      user-select: none;
      filter: drop-shadow(0 0 3px ${color}) blur(0.5px);
      will-change: transform, opacity;
      opacity: ${intensity === 1 ? 0.6 : 0.9};
    `;

    particleContainer.appendChild(particle);

    // Orbital physics properties
    const angle = (Math.PI * 2 * i) / count; // Evenly distribute around circle
    const distance = orbitRadius * (0.8 + Math.random() * 0.4); // Vary distance slightly
    const particleData = {
      element: particle,
      angle: angle,
      distance: distance,
      initialDistance: distance,
      orbitSpeed: orbitSpeed * (0.8 + Math.random() * 0.4), // Vary speed
      life: 1,
      decay: 1 / (duration / 16), // Decay per frame (assuming 60fps)
      rotation: Math.random() * 360,
      rotationSpeed: (Math.random() - 0.5) * 5
    };

    particles.push(particleData);
  }

  // Animation loop
  const startTime = performance.now();
  const animate = (currentTime) => {
    const elapsed = currentTime - startTime;

    if (elapsed > duration) {
      particleContainer.remove();
      return null;
    }

    // Update center position in case element moved
    const currentRect = element.getBoundingClientRect();
    const currentCenterX = currentRect.left + currentRect.width / 2;
    const currentCenterY = currentRect.top + currentRect.height / 2;

    particles.forEach(p => {
      // Update orbital angle
      p.angle += p.orbitSpeed;

      // Spiral inward over time if enabled
      if (spiralIn) {
        p.distance = p.initialDistance * p.life;
      }

      // Calculate position based on orbital motion
      const x = currentCenterX + Math.cos(p.angle) * p.distance;
      const y = currentCenterY + Math.sin(p.angle) * p.distance;

      // Update rotation
      p.rotation += p.rotationSpeed;

      // Decay life
      p.life -= p.decay;

      // Update DOM - use transform for GPU-accelerated positioning
      const opacity = Math.max(0, p.life * (intensity === 1 ? 0.6 : 0.9));
      p.element.style.transform = `translate3d(${x}px, ${y}px, 0) rotate(${p.rotation}deg)`;
      p.element.style.opacity = opacity;
    });

    requestAnimationFrame(animate);
  };

  requestAnimationFrame(animate);
  return particleContainer; // Return container so it can be stopped if needed
}

/**
 * Create particle swarm effect (particles cluster and swarm around a center)
 * @param {HTMLElement} element - Target element to swarm around
 * @param {Object} options - Swarm options
 */
function createParticleSwarm(element, options = {}) {
  const {
    count = 25,
    colors = ['#ff4500', '#ff6600', '#ff8800'],
    size = 3,
    duration = 3000,
    swarmRadius = 60,
    cohesion = 0.01,    // How much particles attract to center
    separation = 0.05,  // How much particles avoid each other
    alignment = 0.02    // How much particles match velocity
  } = options;

  if (!element) return null;

  const rect = element.getBoundingClientRect();
  const centerX = rect.left + rect.width / 2;
  const centerY = rect.top + rect.height / 2;

  const particles = [];

  // Create particle container
  const particleContainer = document.createElement('div');
  particleContainer.style.cssText = `
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 99997;
  `;
  document.body.appendChild(particleContainer);

  // Create particles with random initial positions and velocities
  for (let i = 0; i < count; i++) {
    const particle = document.createElement('div');

    // Random color from palette
    const color = colors[Math.floor(Math.random() * colors.length)];

    // Random size variation
    const particleSize = size * (0.8 + Math.random() * 0.4);

    particle.textContent = '‚óè';
    particle.style.cssText = `
      position: absolute;
      font-size: ${particleSize}px;
      color: ${color};
      pointer-events: none;
      user-select: none;
      filter: drop-shadow(0 0 2px ${color}) blur(0.3px);
      will-change: transform, opacity;
      opacity: 0.8;
    `;

    particleContainer.appendChild(particle);

    // Random initial position around center
    const angle = Math.random() * Math.PI * 2;
    const distance = Math.random() * swarmRadius;
    const particleData = {
      element: particle,
      x: centerX + Math.cos(angle) * distance,
      y: centerY + Math.sin(angle) * distance,
      vx: (Math.random() - 0.5) * 2,
      vy: (Math.random() - 0.5) * 2,
      life: 1,
      decay: 1 / (duration / 16) // Decay per frame
    };

    particles.push(particleData);
  }

  // Animation loop with swarm behavior
  const startTime = performance.now();
  const animate = (currentTime) => {
    const elapsed = currentTime - startTime;

    if (elapsed > duration) {
      particleContainer.remove();
      return null;
    }

    // Update center position in case element moved
    const currentRect = element.getBoundingClientRect();
    const currentCenterX = currentRect.left + currentRect.width / 2;
    const currentCenterY = currentRect.top + currentRect.height / 2;

    particles.forEach((p, index) => {
      // Swarm behavior forces
      let cohesionX = 0, cohesionY = 0;
      let separationX = 0, separationY = 0;
      let alignmentX = 0, alignmentY = 0;
      let neighbors = 0;

      // Calculate forces from other particles
      particles.forEach((other, otherIndex) => {
        if (index === otherIndex) return;

        const dx = other.x - p.x;
        const dy = other.y - p.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < swarmRadius && distance > 0) {
          neighbors++;

          // Cohesion - steer towards average position
          cohesionX += other.x;
          cohesionY += other.y;

          // Separation - steer away from nearby particles
          if (distance < 20) {
            separationX -= dx / distance;
            separationY -= dy / distance;
          }

          // Alignment - match velocity of nearby particles
          alignmentX += other.vx;
          alignmentY += other.vy;
        }
      });

      if (neighbors > 0) {
        // Average cohesion position
        cohesionX = (cohesionX / neighbors - p.x) * cohesion;
        cohesionY = (cohesionY / neighbors - p.y) * cohesion;

        // Average separation
        separationX *= separation;
        separationY *= separation;

        // Average alignment
        alignmentX = (alignmentX / neighbors - p.vx) * alignment;
        alignmentY = (alignmentY / neighbors - p.vy) * alignment;
      }

      // Attract to center point
      const toCenterX = (currentCenterX - p.x) * cohesion * 2;
      const toCenterY = (currentCenterY - p.y) * cohesion * 2;

      // Apply all forces
      p.vx += cohesionX + separationX + alignmentX + toCenterX;
      p.vy += cohesionY + separationY + alignmentY + toCenterY;

      // Limit velocity
      const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
      const maxSpeed = 3;
      if (speed > maxSpeed) {
        p.vx = (p.vx / speed) * maxSpeed;
        p.vy = (p.vy / speed) * maxSpeed;
      }

      // Update position
      p.x += p.vx;
      p.y += p.vy;

      // Decay life
      p.life -= p.decay;

      // Update DOM - use transform for GPU-accelerated positioning
      const opacity = Math.max(0, p.life * 0.8);
      p.element.style.transform = `translate3d(${p.x}px, ${p.y}px, 0)`;
      p.element.style.opacity = opacity;
    });

    requestAnimationFrame(animate);
  };

  requestAnimationFrame(animate);
  return particleContainer;
}

/**
 * Preset: Gold coin burst (for rewards, purchases)
 */
function goldBurst(x, y) {
  createFizzySparks(x, y, {
    count: 30,
    colors: ['#f4d03f', '#fbbf24', '#ff9933'],
    shape: 'circle',
    size: 6,
    velocity: 1.5,
    gravity: 0.5,
    duration: 2000
  });
}

/**
 * Preset: Rarity burst (for talent/item reveals)
 */
function rarityBurst(x, y, rarity = 0) {
  // Rarity can be a number (0=T1, 2=T2, 3=T3) or string
  let tier = rarity;
  if (typeof rarity === 'string') {
    tier = rarity === 'rare' ? 3 : rarity === 'uncommon' ? 2 : 0;
  }

  // Rarity-based colors matching tier colors (reduced counts for performance)
  const rarityConfigs = {
    0: { colors: ['#9ca3af', '#b0b0b0', '#cccccc'], count: 8 },       // T1 Gray
    2: { colors: ['#60a5fa', '#3b82f6', '#93c5fd'], count: 12 },      // T2 Blue
    3: { colors: ['#f4d03f', '#fbbf24', '#fcd34d'], count: 16 }       // T3 Gold
  };

  const config = rarityConfigs[tier] || rarityConfigs[0];
  // Use anvil sparks with explosive mode for higher tiers
  burstSparks(x, y, config.count, config.colors, tier >= 2);
}

/**
 * Preset: Victory celebration
 */
function victorySparks(x, y) {
  createFizzySparks(x, y, {
    count: 50,
    colors: ['#f4d03f', '#fbbf24', '#4ade80', '#4d99ff', '#ff6633'],
    shape: 'mixed',
    size: 12,
    velocity: 2,
    gravity: 0.3,
    duration: 2500
  });
}

// === FLOATING SPARK OVERLAY SYSTEM ===
/**
 * Floating spark overlay with mouse repulsion and game state intensity
 * Supports color modes: 'normal' (red/orange), 'shop' (blue), 'boss' (purple), 'victory' (rainbow)
 */
class FloatingSparkManager {
  constructor() {
    this.sparks = [];
    this.mouseX = -999;
    this.mouseY = -999;
    this.maxSparks = 60;
    this.baseAmbientCount = 8; // Subtle ambient count
    this.container = null;
    this.animationId = null;
    this.isRunning = false;
    this.colorMode = 'normal'; // 'normal', 'shop', 'boss', 'victory'

    this.init();
  }

  setColorMode(mode) {
    this.colorMode = mode;
  }

  init() {
    // Create overlay container
    this.container = document.createElement('div');
    this.container.id = 'spark-overlay';
    this.container.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 9999;
      overflow: hidden;
    `;
    document.body.appendChild(this.container);

    // Track mouse position
    document.addEventListener('mousemove', (e) => {
      this.mouseX = e.clientX;
      this.mouseY = e.clientY;
    });

    // Start animation loop
    this.start();
  }

  getIntensity() {
    // 1. Safety Check: If no enemy/hero (e.g., Main Menu), return low intensity
    if (!S.hero || !S.enemy) return 0;

    // 2. Throttle expensive calculations - only recalculate every 500ms
    const now = performance.now();
    if (this._lastIntensityTime && now - this._lastIntensityTime < 500) {
      return this._cachedIntensity || 0;
    }
    this._lastIntensityTime = now;

    // 3. Fix Slots: You only have item, adj1-4, and noun1. (noun2/3 do not exist)
    const slots = [S.sel.item, S.sel.adj1, S.sel.adj2, S.sel.adj3, S.sel.adj4, S.sel.noun1];
    const wordFill = slots.filter(w => w && !w.isStick).length / 6;

    // 4. Fix HP Variables: S.eMaxHp does not exist. Use S.enemy.hp (or calculation).
    // Note: Since max HP isn't strictly tracked in your simplified model, we estimate
    // intensity based on how much HP the enemy has left vs current round scaling.
    const currentMax = enemyHp(S.roundIndex);
    const enemyHealthFactor = currentMax > 0 ? (1 - (S.enemy.hp / currentMax)) : 0;

    // 5. Use cached damage if available from last render(), avoid calling calc() every frame
    // S.lastCalcDmg is set by render() when damage preview updates
    const dmg = S.lastCalcDmg || 0;

    // Calculate overkill based on current enemy HP
    const overkill = Math.max(0, dmg - S.enemy.hp);
    const overkillFactor = currentMax > 0 ? Math.min(1, overkill / currentMax) : 0;

    // Weighted combination
    this._cachedIntensity = (wordFill * 0.3) + (enemyHealthFactor * 0.3) + (overkillFactor * 0.4);
    return this._cachedIntensity;
  }

  createSpark(x, y, isBurst = false) {
    if (this.sparks.length >= this.maxSparks) return null;

    // Color based on mode
    let hue, saturation = 90;
    switch(this.colorMode) {
      case 'shop':
        hue = 200 + Math.random() * 40; // Blue range (200-240)
        break;
      case 'boss':
        hue = 270 + Math.random() * 40; // Purple range (270-310)
        break;
      case 'victory':
        hue = Math.random() * 360; // Full rainbow
        break;
      default: // 'normal'
        hue = Math.random() * 50; // Red to orange (0-50)
    }

    const brightness = isBurst ? (50 + Math.random() * 50) : (40 + Math.random() * 30); // Slightly brighter ambient
    const size = isBurst ? (4 + Math.random() * 6) : (2 + Math.random() * 2.5); // Bigger sparks

    const spark = {
      x: x !== undefined ? x : Math.random() * window.innerWidth,
      y: y !== undefined ? y : window.innerHeight + Math.random() * 50, // Start from bottom
      vx: (Math.random() - 0.5) * (isBurst ? 3 : 0.5),
      vy: isBurst ? ((Math.random() - 0.5) * 3 - 2) : -(0.5 + Math.random() * 0.6), // Float upward faster
      life: 1,
      maxLife: isBurst ? (1200 + Math.random() * 600) : (8000 + Math.random() * 4000), // Long life for full screen travel
      size: size,
      brightness: brightness,
      hue: hue,
      isBurst: isBurst,
      element: null
    };

    // Create DOM element - use transform for GPU-accelerated positioning
    const el = document.createElement('div');
    el.style.cssText = `
      position: absolute;
      left: 0;
      top: 0;
      width: ${size}px;
      height: ${size}px;
      background: hsl(${hue}, ${saturation}%, ${brightness}%);
      border-radius: 50%;
      box-shadow: 0 0 ${size * 2}px hsl(${hue}, ${saturation}%, ${brightness}%);
      pointer-events: none;
      will-change: transform, opacity;
      transform: translate3d(${spark.x}px, ${spark.y}px, 0);
      opacity: 0.5;
    `;
    this.container.appendChild(el);
    spark.element = el;

    this.sparks.push(spark);
    return spark;
  }

  applyMouseRepulsion(spark) {
    const dx = spark.x - this.mouseX;
    const dy = spark.y - this.mouseY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const repulseRadius = 150;

    if (dist < repulseRadius && dist > 0) {
      const force = (1 - dist / repulseRadius) * 2;
      spark.vx += (dx / dist) * force;
      spark.vy += (dy / dist) * force;
    }
  }

  repulse(x, y, radius = 200, force = 3) {
    this.sparks.forEach(spark => {
      const dx = spark.x - x;
      const dy = spark.y - y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < radius && dist > 0) {
        const repulseForce = (1 - dist / radius) * force;
        spark.vx += (dx / dist) * repulseForce;
        spark.vy += (dy / dist) * repulseForce;
      }
    });
  }

  update(deltaTime) {
    const intensity = this.getIntensity();
    const targetAmbientCount = Math.floor(this.baseAmbientCount * (1 + intensity * 2));

    // Maintain ambient spark count
    const ambientSparks = this.sparks.filter(s => !s.isBurst).length;
    if (ambientSparks < targetAmbientCount) {
      this.createSpark();
    }

    // Update each spark
    for (let i = this.sparks.length - 1; i >= 0; i--) {
      const spark = this.sparks[i];

      // Apply mouse repulsion
      this.applyMouseRepulsion(spark);

      // Apply physics - gentle upward float for ambient sparks
      if (!spark.isBurst) {
        spark.vy -= 0.05; // More visible upward float (negative Y is up)
      }
      spark.vx *= 0.98; // Air resistance
      spark.vy *= 0.98;

      // Update position
      spark.x += spark.vx;
      spark.y += spark.vy;

      // Update life
      const lifeDecrement = deltaTime / spark.maxLife;
      spark.life -= lifeDecrement;

      // Remove dead or off-screen sparks
      if (spark.life <= 0 || spark.y < -50 || spark.y > window.innerHeight + 50 ||
          spark.x < -50 || spark.x > window.innerWidth + 50) {
        spark.element.remove();
        this.sparks.splice(i, 1);
        continue;
      }

      // Update DOM - use transform for GPU-accelerated positioning
      const opacity = Math.max(0, spark.life * 0.7);
      const scale = 0.5 + spark.life * 0.5; // Shrink as it dies
      spark.element.style.opacity = opacity;
      spark.element.style.transform = `translate3d(${spark.x}px, ${spark.y}px, 0) scale(${scale})`;
    }
  }

  burst(x, y, count = 10) {
    for (let i = 0; i < count; i++) {
      // Random position around target
      const angle = Math.random() * Math.PI * 2;
      const radius = Math.random() * 20;
      const sparkX = x + Math.cos(angle) * radius;
      const sparkY = y + Math.sin(angle) * radius;
      this.createSpark(sparkX, sparkY, true);
    }
  }

  start() {
    if (this.isRunning) return;
    this.isRunning = true;

    let lastTime = performance.now();
    const targetFPS = 30; // Limit to 30fps for performance
    const frameInterval = 1000 / targetFPS;
    let accumulator = 0;

    const loop = (currentTime) => {
      const deltaTime = currentTime - lastTime;
      lastTime = currentTime;
      accumulator += deltaTime;

      // Only update when enough time has passed
      if (accumulator >= frameInterval) {
        this.update(accumulator);
        accumulator = 0;
      }

      this.animationId = requestAnimationFrame(loop);
    };

    this.animationId = requestAnimationFrame(loop);
  }

  stop() {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
    this.isRunning = false;
    // Clear all existing sparks from the screen
    this.sparks.forEach(spark => {
      if (spark.element) spark.element.remove();
    });
    this.sparks = [];
  }

  destroy() {
    this.stop();
    if (this.container) {
      this.container.remove();
    }
    this.sparks = [];
  }
}

// Global spark manager instance (disabled - replaced by BlacksmithEmberManager)
let sparkManager = null;

/**
 * Blacksmith Ember Manager - Creates persistent line sparks with mouse repulsion
 * Used when clicking Forge Weapon button
 */
class BlacksmithEmberManager {
  constructor() {
    this.embers = [];
    this.mouseX = -999;
    this.mouseY = -999;
    this.container = null;
    this.animationId = null;
    this.isRunning = false;
    this.lastTime = 0;
    this.maxEmbers = 80; // Cap total active embers to prevent lag
    this.lastBurstTime = 0;
    this.burstCooldown = 50; // Minimum ms between bursts
  }

  init() {
    if (this.container) return;

    // Create overlay container
    this.container = document.createElement('div');
    this.container.id = 'blacksmith-ember-overlay';
    this.container.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 9998;
      overflow: hidden;
    `;
    document.body.appendChild(this.container);

    // Track mouse position for repulsion
    document.addEventListener('mousemove', (e) => {
      this.mouseX = e.clientX;
      this.mouseY = e.clientY;
    });
  }

  createEmber(x, y, colors = ['#ff9933', '#ffcc00', '#ffaa44'], explosive = false) {
    const color = colors[Math.floor(Math.random() * colors.length)];
    const size = explosive ? (8 + Math.random() * 8) : (6 + Math.random() * 6);

    // Random angle for radial burst
    const angle = Math.random() * Math.PI * 2;
    // Explosive mode has much higher initial velocity
    const speed = explosive ? (6 + Math.random() * 8) : (2 + Math.random() * 3);

    const ember = {
      x: x,
      y: y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - (explosive ? 3 : 1.5), // Stronger upward bias for explosive
      life: 1,
      maxLife: explosive ? (800 + Math.random() * 600) : (2000 + Math.random() * 1500),
      size: size,
      color: color,
      rotation: Math.random() * 360,
      element: null,
      explosive: explosive
    };

    // Create DOM element - line shape like blacksmith sparks
    const el = document.createElement('div');
    el.textContent = '‚îÇ';
    el.style.cssText = `
      position: absolute;
      left: 0;
      top: 0;
      font-size: ${size}px;
      color: ${color};
      pointer-events: none;
      user-select: none;
      filter: drop-shadow(0 0 ${explosive ? 6 : 4}px ${color});
      will-change: transform, opacity;
      opacity: 0.9;
      transform-origin: center center;
      transform: translate3d(${x}px, ${y}px, 0);
    `;
    this.container.appendChild(el);
    ember.element = el;

    this.embers.push(ember);
    return ember;
  }

  burst(x, y, count = 20, colors = ['#ff9933', '#ffcc00', '#ffaa44'], explosive = false) {
    this.init();

    // Debounce rapid bursts to prevent lag from spam clicking
    const now = performance.now();
    if (now - this.lastBurstTime < this.burstCooldown) {
      count = Math.ceil(count * 0.5); // Reduce count for rapid bursts
    }
    this.lastBurstTime = now;

    // Cap how many new embers we can add based on current count
    const available = this.maxEmbers - this.embers.length;
    const actualCount = Math.min(count, Math.max(available, 5)); // Always allow at least 5

    for (let i = 0; i < actualCount; i++) {
      this.createEmber(x, y, colors, explosive);
    }
    if (!this.isRunning) {
      this.start();
    }
  }

  applyMouseRepulsion(ember) {
    const dx = ember.x - this.mouseX;
    const dy = ember.y - this.mouseY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const repulseRadius = 120;

    if (dist < repulseRadius && dist > 0) {
      const force = (1 - dist / repulseRadius) * 0.8;
      ember.vx += (dx / dist) * force;
      ember.vy += (dy / dist) * force;
      // Quickly fade embers when repulsed
      ember.life -= 0.15 * (1 - dist / repulseRadius);
    }
  }

  update(deltaTime) {
    for (let i = this.embers.length - 1; i >= 0; i--) {
      const ember = this.embers[i];

      // Apply mouse repulsion
      this.applyMouseRepulsion(ember);

      // Strong air resistance - sparks ramp down naturally like real sparks
      ember.vx *= 0.94;
      ember.vy *= 0.94;

      // Gravity pulls sparks down naturally (no floating up)
      ember.vy += 0.04;

      // Update position
      ember.x += ember.vx;
      ember.y += ember.vy;

      // Update life - fade out faster as they slow down
      const speed = Math.sqrt(ember.vx * ember.vx + ember.vy * ember.vy);
      const lifeDecay = deltaTime / ember.maxLife;
      // Accelerate fade when nearly stationary
      const fadeMultiplier = speed < 0.5 ? 3 : 1;
      ember.life -= lifeDecay * fadeMultiplier;

      // Calculate rotation based on velocity direction
      ember.rotation = Math.atan2(ember.vy, ember.vx) * (180 / Math.PI) + 90;

      // Update DOM - use transform for GPU-accelerated positioning
      const scale = ember.life;
      const scaleX = 0.5; // Thicker
      const scaleY = scale * 1.8; // Long but proportional
      const opacity = Math.max(0, ember.life * 0.9);
      ember.element.style.opacity = opacity;
      ember.element.style.transform = `translate3d(${ember.x}px, ${ember.y}px, 0) rotate(${ember.rotation}deg) scale(${scaleX}, ${scaleY})`;

      // Remove dead embers
      if (ember.life <= 0) {
        ember.element.remove();
        this.embers.splice(i, 1);
      }
    }

    // Stop animation if no embers left
    if (this.embers.length === 0) {
      this.stop();
    }
  }

  start() {
    if (this.isRunning) return;
    this.isRunning = true;
    this.lastTime = performance.now();

    const animate = (currentTime) => {
      if (!this.isRunning) return;

      const deltaTime = currentTime - this.lastTime;
      this.lastTime = currentTime;

      this.update(deltaTime);

      this.animationId = requestAnimationFrame(animate);
    };

    this.animationId = requestAnimationFrame(animate);
  }

  stop() {
    this.isRunning = false;
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
  }

  clear() {
    this.embers.forEach(ember => {
      if (ember.element) ember.element.remove();
    });
    this.embers = [];
    this.stop();
  }
}

// Global blacksmith ember manager instance
let blacksmithEmberManager = null;

/**
 * Helper: Trigger blacksmith ember burst at coordinates
 */
function burstSparks(x, y, count = 20, colors = ['#ff9933', '#ffcc00', '#ffaa44'], explosive = false) {
  if (!blacksmithEmberManager) {
    blacksmithEmberManager = new BlacksmithEmberManager();
  }
  blacksmithEmberManager.burst(x, y, count, colors, explosive);
}

// === FLAME GRADIENT BACKGROUND CONTROL ===

// Track current flame color mode
let currentFlameMode = 'battle';

/**
 * Set flame background color (battle = red/orange, shop = blue, boss-shop = purple, boss-dialogue = purple pulse, boss-battle = purple)
 */
function setFlameColor(mode = 'battle') {
  const flameBg = document.getElementById('flame-bg');
  if (!flameBg) return;

  currentFlameMode = mode;

  // Remove all flame mode classes first
  flameBg.classList.remove('shop-mode', 'boss-shop-mode', 'boss-dialogue-mode', 'boss-battle-mode');

  if (mode === 'shop') {
    // Blue flame for shop
    flameBg.classList.add('shop-mode');
    flameBg.style.setProperty('--flame-opacity', '0.4');
    flameBg.style.setProperty('--flame-scale', '1.1');
  } else if (mode === 'boss-shop') {
    // Purple flame for pre-boss shop
    flameBg.classList.add('boss-shop-mode');
    flameBg.style.setProperty('--flame-opacity', '0.5');
    flameBg.style.setProperty('--flame-scale', '1.2');
  } else if (mode === 'boss-dialogue') {
    // Purple pulsing flame for boss dialogue
    flameBg.classList.add('boss-dialogue-mode');
    flameBg.style.setProperty('--flame-opacity', '0.5');
    flameBg.style.setProperty('--flame-scale', '1.2');
  } else if (mode === 'boss-battle') {
    // Purple flame for chapter boss battle (no pulse)
    flameBg.classList.add('boss-battle-mode');
    flameBg.style.setProperty('--flame-opacity', '0.5');
    flameBg.style.setProperty('--flame-scale', '1.2');
  } else {
    // Red/orange flame for battle
    // Reset to damage-based intensity
    updateFlameBaseline();
  }
}

// Mouse position for flame following effect
let flameMouseX = 0.5;
let flameMouseY = 0.5;
let flameTargetX = 0.5;
let flameTargetY = 0.5;

// Initialize mouse tracking for flame background
function initFlameMouseTracking() {
  document.addEventListener('mousemove', (e) => {
    // Normalize mouse position to 0-1 range
    flameTargetX = e.clientX / window.innerWidth;
    flameTargetY = e.clientY / window.innerHeight;
  });

  // Smooth animation loop for flame following (only when parallax enabled)
  let cachedFlameBg = null;
  let lastFlameUpdateTime = 0;
  function updateFlamePosition() {
    // Skip if parallax disabled in settings or Low FX mode (flame is centered via CSS)
    if (!S.settings?.parallax || gfxSettings.lowFx) {
      requestAnimationFrame(updateFlamePosition);
      return;
    }

    // Throttle to ~30fps to reduce CPU usage
    const now = performance.now();
    if (now - lastFlameUpdateTime < 33) {
      requestAnimationFrame(updateFlamePosition);
      return;
    }
    lastFlameUpdateTime = now;

    // Lerp towards target (smooth following)
    flameMouseX += (flameTargetX - flameMouseX) * 0.05;
    flameMouseY += (flameTargetY - flameMouseY) * 0.05;

    // Cache flameBg element
    if (!cachedFlameBg) {
      cachedFlameBg = document.getElementById('flame-bg');
    }
    if (cachedFlameBg) {
      const offsetX = (flameMouseX - 0.5) * -20;
      const offsetY = (flameMouseY - 0.5) * -15;
      cachedFlameBg.style.setProperty('--mouse-x', `${offsetX}%`);
      cachedFlameBg.style.setProperty('--mouse-y', `${offsetY}%`);
    }

    requestAnimationFrame(updateFlamePosition);
  }

  updateFlamePosition();
}

/**
 * Update flame background baseline brightness based on damage potential
 */
function updateFlameBaseline() {
  const flameBg = document.getElementById('flame-bg');
  if (!flameBg) return;

  // If no enemy data yet, use default low intensity
  if (!S.eMaxHp || !S.enemy) {
    flameBg.style.setProperty('--flame-opacity', '0.3');
    flameBg.style.setProperty('--flame-scale', '1.0');
    return;
  }

  // Calculate damage to enemy HP ratio for intensity
  const c = calc();
  const dmg = c.heroDmg || 0;
  const damageRatio = dmg / S.eMaxHp;

  // Calculate overkill percentage (damage beyond 100% of enemy HP)
  const overkillRatio = Math.max(0, damageRatio - 1);

  // Baseline opacity: starts at 0.5, increases with damage
  // At 100% overkill (2x enemy HP damage), reaches 0.95 for vibrant orange
  const baseOpacity = Math.min(0.95, 0.5 + (damageRatio * 0.25) + (overkillRatio * 0.4));

  // Scale: starts at 1.0, at 100% overkill reaches ~3.2 (covers 80% of screen)
  // Base ovals are ~500-600px, scaling to ~1600-1900px at 100% overkill
  const baseScale = 1.0 + (overkillRatio * 2.2);

  flameBg.style.setProperty('--flame-opacity', baseOpacity);
  flameBg.style.setProperty('--flame-scale', baseScale);
}

/**
 * Pulse flame background for 1 second with increased blur and opacity
 */
function pulseFlame() {
  const flameBg = document.getElementById('flame-bg');
  if (!flameBg) return;

  // Store current values
  const currentOpacity = parseFloat(getComputedStyle(flameBg).getPropertyValue('--flame-opacity')) || 0.3;
  const currentBlur = parseFloat(getComputedStyle(flameBg).getPropertyValue('--flame-blur')) || 100;

  // Pulse: increase opacity and blur
  flameBg.style.setProperty('--flame-opacity', Math.min(0.8, currentOpacity + 0.3));
  flameBg.style.setProperty('--flame-blur', (currentBlur + 50) + 'px');

  // Reset after 1 second
  setTimeout(() => {
    flameBg.style.setProperty('--flame-opacity', currentOpacity);
    flameBg.style.setProperty('--flame-blur', currentBlur + 'px');
  }, 1000);
}

// === GRAPHICS SETTINGS ===
const GFX_SETTINGS_KEY = 'wordyweapon_gfx';

// Default graphics settings
let gfxSettings = {
  lowFx: false,  // Master toggle: disables sparks, parallax, transitions, combat effects, expensive GPU animations
  zoom: 95,  // UI zoom percentage (50-200)
  brightness: 100  // Brightness percentage (80-150) for HDR monitors
};

// Load graphics settings from localStorage
function loadGfxSettings() {
  try {
    const saved = localStorage.getItem(GFX_SETTINGS_KEY);
    if (saved) {
      gfxSettings = { ...gfxSettings, ...JSON.parse(saved) };
    }
  } catch (e) {
    console.warn('Failed to load graphics settings', e);
  }
  applyGfxSettings();
}

// Save graphics settings to localStorage
function saveGfxSettings() {
  try {
    localStorage.setItem(GFX_SETTINGS_KEY, JSON.stringify(gfxSettings));
  } catch (e) {
    console.warn('Failed to save graphics settings', e);
  }
}

// Apply graphics settings to the game
function applyGfxSettings() {
  // Low FX mode - disables floating sparks & toggles CSS class for GPU optimizations
  if (sparkManager) {
    if (gfxSettings.lowFx) {
      sparkManager.stop();
    } else {
      sparkManager.start();
    }
  }

  // Low FX mode CSS class - disables expensive animations (flame bg, god rays, iridescent effects)
  if (gfxSettings.lowFx) {
    document.body.classList.add('low-fx');
  } else {
    document.body.classList.remove('low-fx');
  }

  // Apply brightness filter for HDR monitors
  const brightnessVal = gfxSettings.brightness / 100;
  document.body.style.filter = brightnessVal !== 1 ? `brightness(${brightnessVal})` : '';
}

// Open graphics settings overlay
function openGraphicsSettings() {
  const overlay = document.getElementById('graphics-settings');
  if (!overlay) return;

  // Sync Low FX checkbox with current setting
  const lowFxCheckbox = document.getElementById('gfx-lowfx');
  if (lowFxCheckbox) lowFxCheckbox.checked = gfxSettings.lowFx;

  showOverlay(overlay);
  playSfxOpen();
}

// Close graphics settings overlay
function closeGraphicsSettings() {
  const overlay = document.getElementById('graphics-settings');
  if (overlay) {
    overlay.classList.remove('show');
    playSfxBack(); // "Back" sound
  }
}

// Initialize graphics settings event listeners
function initGfxSettingsListeners() {
  const closeBtn = document.getElementById('gfx-close');
  if (closeBtn) {
    closeBtn.onclick = closeGraphicsSettings;
    closeBtn.onmouseenter = sfxHover;
  }

  // Low FX mode checkbox
  const lowFxCheckbox = document.getElementById('gfx-lowfx');
  if (lowFxCheckbox) {
    lowFxCheckbox.onchange = () => {
      gfxSettings.lowFx = lowFxCheckbox.checked;
      applyGfxSettings();
      saveGfxSettings();
    };
  }

  // Bug report button
  const bugReportBtn = document.getElementById('gfx-bug-report');
  if (bugReportBtn) {
    bugReportBtn.onclick = () => {
      closeGraphicsSettings();
      openBugReport();
    };
    bugReportBtn.onmouseenter = sfxHover;
  }
}

// === TEXT SELECTION PREVENTION ===
document.addEventListener('selectstart', (e) => {
  // Allow selection only in input/textarea
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
    return;
  }
  e.preventDefault();
});

// === CRATE OPENING REEL ANIMATION ===

/**
 * Formats a word for display in the crate reel slot
 * Shows: Name (rarity colored) + Tier - Element (or √ómult for non-elemental)
 */
function formatReelItem(word) {
  const rc = TC[word.rarity];
  const tierLabel = TN[word.rarity] || 'T1';

  // Generate color tab based on word type
  let tabHtml = "";
  let extraClasses = "";
  const elemTabClasses = ['elem-phys','elem-poison','elem-fire','elem-water','elem-light','elem-dark','elem-earth','elem-lightning'];
  const elemWashClasses = ['elem-wash-phys','elem-wash-poison','elem-wash-fire','elem-wash-water','elem-wash-light','elem-wash-dark','elem-wash-earth','elem-wash-lightning'];

  if(word.type === 'elemental' && word.elem !== undefined){
    tabHtml = `<div class="chip-tab ${elemTabClasses[word.elem] || ''}"></div>`;
    if(word.rarity === T.T2){
      extraClasses = `tier-wash-2 ${elemWashClasses[word.elem] || ''}`;
    } else if(word.rarity === T.T3){
      extraClasses = `tier-wash-3 ${elemWashClasses[word.elem] || ''}`;
    }
  } else if(word.type === 'rarity'){
    const rarityTier = word.rarity === T.T3 ? 'rarity-t3' : word.rarity === T.T2 ? 'rarity-t2' : 'rarity-t1';
    extraClasses = `rarity-word ${rarityTier}`;
  }

  // Word name color: neutral for elemental (tab shows element), tier color for others
  const nameColorClass = (word.type === 'elemental') ? '' : rc;

  // Tier badge
  const tierBadge = `<span class="chip-tier tier-${word.rarity}">${tierLabel}</span>`;

  let detailHtml = '';
  if (word.elem !== undefined) {
    // Has element - show element name
    const elemColor = EC[word.elem] || '#9ca3af';
    detailHtml = `<span style="color:${elemColor}">${EN[word.elem]}</span>`;
  } else if (word.mult && word.mult > 1) {
    // Non-elemental with multiplier
    detailHtml = `<span class="reel-mult">√ó${word.mult}</span>`;
  }

  // Wrap content with classes
  const wrapperClass = extraClasses ? `reel-content ${extraClasses}` : 'reel-content';
  return `<div class="${wrapperClass}">${tabHtml}${tierBadge}<div class="reel-name ${nameColorClass}">${word.name}</div><div class="reel-detail">${detailHtml}</div></div>`;
}

/**
 * Shows a slot machine style reel animation for crate opening
 * Words are rolled dynamically at reveal time for casino-style tension
 * @param {Object} crate - Crate object with weaponPool, wordPool, and quantities
 * @returns {Promise<Array>} Resolves with array of revealed words
 */
async function showCrateReelAnimation(crate) {
  const overlay = document.getElementById('crate-reel-overlay');
  const container = document.getElementById('crate-reel-container');
  const title = document.getElementById('crate-reel-title');
  const status = document.getElementById('crate-reel-status');
  const spotlightTint = document.getElementById('spotlight-tint');

  if(!overlay || !container) return [];

  // Show spotlight tint behind the crate reel
  if(spotlightTint) spotlightTint.classList.add('show', 'crate');

  // Set title based on crate name (ALL CAPS Garamond)
  title.textContent = crate.name.toUpperCase();

  container.innerHTML = '';
  status.textContent = 'Spinning...';

  // Build weighted pool helper for rarity: T1=55%, T2=35%, T3=10%
  // Lucky Find talent adds +20% to T3 chance (base 10% -> 12% effective)
  const hasLuckyFind = S.talents && S.talents.includes('lucky_find');
  // Rarity adjective specific weights (scaled down to reduce legendary drops)
  // Lower weights = rarer drops (weight is divisor, not multiplier)
  // Legendary is 3x harder to find than common, Epic 2x, Rare 1.5x
  const rarityAdjWeights = {
    'adj_common': 1.0,
    'adj_uncommon': 1.0,
    'adj_magic': 1.0,
    'adj_rare': 1.5,      // 1.5x rarer
    'adj_epic': 2.0,      // 2x rarer
    'adj_legendary': 3.0  // 3x rarer
  };
  const buildWeightedPool = (pool) => {
    const weighted = [];
    pool.forEach(w => {
      const rank = w.rarity || 0;
      // Drop rates: T1=55%, T2=35%, T3=10%
      let weight = rank === 0 ? 11 : rank === 2 ? 7 : 2;
      // Lucky Find: T3 words get +20% more weight (2 -> 2.4, effectively ~12% chance)
      if (hasLuckyFind && rank >= 3) {
        weight = Math.ceil(weight * 1.2);
      }
      // Rarity adjectives have specific weights to reduce legendary drops
      // Higher rarityAdjWeight = rarer (we divide weight by this value)
      if (w.type === 'rarity' && rarityAdjWeights[w.id]) {
        weight = Math.max(1, Math.round(weight / rarityAdjWeights[w.id]));
      }
      // Skew drops slightly in favor of hero's proficiency
      // Note: Element weighting is ONLY affected by talent selections (getTalentWeightBoosts)
      if(S.hero){
        // Weapons matching hero's good proficiency get +3 weight
        if(w.type === 'weapon' && w.category === S.hero.good) weight += 3;
      }
      for (let i = 0; i < Math.round(weight); i++) weighted.push(w);
    });
    return weighted;
  };

  const weightedWeaponPool = buildWeightedPool(crate.weaponPool);
  const weightedWordPool = buildWeightedPool(crate.wordPool);

  // Build tiered rarity pools for chance-based drops in word slots
  const weightedT1RarityPool = crate.t1RarityPool ? buildWeightedPool(crate.t1RarityPool) : [];
  const weightedT2RarityPool = crate.t2RarityPool ? buildWeightedPool(crate.t2RarityPool) : [];
  const weightedT3RarityPool = crate.t3RarityPool ? buildWeightedPool(crate.t3RarityPool) : [];

  // Track if rarity has dropped this crate (only one allowed per crate)
  let rarityDroppedThisCrate = false;
  const RARITY_DROP_CHANCE = 0.15; // 15% chance per eligible slot

  // Determine what each reel will roll for (weapon or word - rarity is now chance-based within word slots)
  const reelTypes = [];
  for (let i = 0; i < crate.weaponQty; i++) reelTypes.push('weapon');
  for (let i = 0; i < crate.wordQty; i++) reelTypes.push({ type: 'word', slotTier: i }); // Track slot position for tiered rarity

  // Create reels (one for each item to reveal)
  const reels = [];
  const revealedWords = [];

  reelTypes.forEach((reelTypeData, index) => {
    // Handle both string ('weapon') and object ({ type: 'word', slotTier: 0 }) formats
    const reelType = typeof reelTypeData === 'string' ? reelTypeData : reelTypeData.type;
    const slotTier = typeof reelTypeData === 'object' ? reelTypeData.slotTier : -1;

    const reel = document.createElement('div');
    reel.className = `crate-reel spinning`;

    // Create window highlight
    const windowEl = document.createElement('div');
    windowEl.className = 'crate-reel-window';
    reel.appendChild(windowEl);

    // Create strip with random words for visual spinning effect
    const strip = document.createElement('div');
    strip.className = 'crate-reel-strip';

    // Generate visual pool based on reel type
    let visualPool;
    if (reelType === 'weapon') {
      visualPool = crate.weaponPool;
    } else {
      visualPool = crate.wordPool;
    }

    // Create 20 items for smooth looping (all visual placeholders initially)
    const items = [];
    for(let i = 0; i < 20; i++){
      const randomWord = visualPool[Math.floor(Math.random() * visualPool.length)];
      items.push(randomWord);
    }

    // Render items
    items.forEach(word => {
      const item = document.createElement('div');
      item.className = 'crate-reel-item';
      item.innerHTML = formatReelItem(word);
      strip.appendChild(item);
    });

    reel.appendChild(strip);
    container.appendChild(reel);

    // Determine weighted pool for this reel type
    let weightedPool;
    if (reelType === 'weapon') {
      weightedPool = weightedWeaponPool;
    } else {
      weightedPool = weightedWordPool;
    }

    // Determine tiered rarity pool for this slot (if word slot)
    let tieredRarityPool = null;
    if (reelType === 'word') {
      // Slot 0 = T1 rarity, Slot 1 = T2 rarity, Slot 2+ = T3 rarity
      if (slotTier === 0) tieredRarityPool = weightedT1RarityPool;
      else if (slotTier === 1) tieredRarityPool = weightedT2RarityPool;
      else tieredRarityPool = weightedT3RarityPool;
    }

    reels.push({
      element: reel,
      strip,
      reelType,
      slotTier,
      weightedPool,
      tieredRarityPool,
      visualPool,
      targetPosition: 17
    });
  });

  // Show overlay
  overlay.classList.add('show');

  // Track which reels have been stopped
  const stoppedReels = new Set();
  let hasHighTierWord = false;
  const wordReelIndices = reels.map((r, i) => r.reelType === 'word' ? i : -1).filter(i => i >= 0);

  // Helper to reveal a single reel with effects
  const revealReel = (reelIndex) => {
    if (stoppedReels.has(reelIndex)) return; // Already stopped
    stoppedReels.add(reelIndex);

    const reelData = reels[reelIndex];
    const { element, strip, weightedPool, tieredRarityPool, visualPool, targetPosition } = reelData;

    // Roll the word NOW
    let rolledWord = shuf([...weightedPool])[0];

    // For word slots: chance to drop a tiered rarity word instead of elemental
    // Only if no rarity has dropped this crate yet
    if (reelData.reelType === 'word' && !rarityDroppedThisCrate && tieredRarityPool && tieredRarityPool.length > 0) {
      if (Math.random() < RARITY_DROP_CHANCE) {
        rolledWord = shuf([...tieredRarityPool])[0];
        rarityDroppedThisCrate = true; // Prevent further rarity drops this crate
      }
    }

    // Pity system: If this is the last word reel and no high tier yet, force one
    const isLastWordReel = reelIndex === wordReelIndices[wordReelIndices.length - 1];
    const unrevealed = wordReelIndices.filter(i => !stoppedReels.has(i));
    if (reelData.reelType === 'word') {
      const wordRank = rolledWord.rarity || 0;
      if (wordRank >= 2) hasHighTierWord = true;

      // If this is the last unrevealed word reel and no high tier yet
      if (unrevealed.length === 0 && !hasHighTierWord) {
        const highTierPool = visualPool.filter(w => (w.rarity || 0) >= 2);
        if (highTierPool.length > 0) {
          rolledWord = shuf([...highTierPool])[0];
          hasHighTierWord = true;
        }
      }
    }

    // Store the revealed word
    revealedWords[reelIndex] = rolledWord;

    // Update the strip to show the rolled word
    const stripItems = strip.querySelectorAll('.crate-reel-item');
    if (stripItems[targetPosition]) {
      stripItems[targetPosition].innerHTML = formatReelItem(rolledWord);
    }

    // Stop spinning and position at target
    element.classList.remove('spinning');
    element.classList.add('stopping', 'revealed');
    const targetOffset = -(targetPosition * 60 - 60);
    strip.style.transform = `translateY(${targetOffset}px)`;

    // Create particles
    const rect = element.getBoundingClientRect();
    rarityBurst(rect.left + rect.width / 2, rect.top + rect.height / 2, rolledWord.rarity || 'common');

    // Play tier-based reveal sound
    const wordRank = rolledWord.rarity || 0;
    try {
      if (wordRank >= 3) {
        playBrassTone(330, 0.25, 0.10);
        setTimeout(() => playBrassTone(392, 0.25, 0.10), 80);
        setTimeout(() => playBrassTone(494, 0.35, 0.14), 160);
      } else if (wordRank >= 2) {
        playBrassTone(330, 0.25, 0.09);
        setTimeout(() => playBrassTone(494, 0.30, 0.11), 100);
      } else {
        playBrassTone(330, 0.25, 0.08);
      }
    } catch(err) {}

    // Check if all reels are done
    if (stoppedReels.size === reels.length) {
      status.textContent = 'Words revealed!';
    }
  };

  // Add click handler to each reel (beat-synced)
  reels.forEach((reelData, index) => {
    reelData.element.style.cursor = 'pointer';
    reelData.clickHandler = async () => {
      // Wait for next quarter beat before revealing (responsive but rhythmic)
      await waitForNextQuarterBeat();
      revealReel(index);
    };
    reelData.element.addEventListener('click', reelData.clickHandler);
  });

  // Play hover sounds during spin for casino effect
  const spinSoundInterval = setInterval(() => {
    if (stoppedReels.size < reels.length) playPageFlipSound();
  }, 150);

  // Wait for initial spin phase (sync to beat)
  await waitForNextBeat();
  await dly(RHYTHM.BEAT * 2);

  // Auto-reveal reels one by one if not clicked (beat-synced)
  for (let i = 0; i < reels.length; i++) {
    // Wait between auto-reveals (about 3 beats, checking for player clicks)
    const autoRevealBeats = 3;
    for (let beat = 0; beat < autoRevealBeats; beat++) {
      if (stoppedReels.has(i)) break; // Player clicked this reel
      if (stoppedReels.size === reels.length) break; // All done
      await waitForNextBeat();
      await dly(RHYTHM.BEAT);
    }

    // Auto-reveal on the beat if not already stopped
    if (!stoppedReels.has(i)) {
      await waitForNextBeat();
      revealReel(i);
    }
  }

  // Stop the spinning sound effect
  clearInterval(spinSoundInterval);
  status.textContent = 'Words revealed!';

  // Wait before closing
  await dly(stoppedReels.size === reels.length ? 800 : 1200);

  // Clean up click handlers
  reels.forEach(reelData => {
    reelData.element.removeEventListener('click', reelData.clickHandler);
    reelData.element.style.cursor = '';
  });

  // Smooth exit animation
  overlay.classList.add('closing');
  await dly(RHYTHM.BEAT);
  overlay.classList.remove('show', 'closing');
  // Hide spotlight tint
  if(spotlightTint) spotlightTint.classList.remove('show', 'crate');

  return revealedWords;
}

function closeRunOverlays(){
  // Close pause menu first to reset its state, then hide other run overlays
  closePauseMenu();
  ['shop-overlay','combat-overlay'].forEach(id=>{
    const el=document.getElementById(id);
    if(el){
      el.classList.remove('show');
    }
  });
  // Remove shop-hidden class from forge (restores pointer-events if shop was open)
  const forgeEl = document.getElementById('forge');
  if(forgeEl) forgeEl.classList.remove('shop-hidden');
}

// Defer initialization until the DOM has fully loaded.  This ensures that
// elements like the main menu start button exist when we attach event
// handlers.  We also bind the start button here rather than in init() so
// that the menu behaves reliably across reloads.
document.addEventListener('DOMContentLoaded', async () => {
  await loadStatsAsync();
  await loadRunAsync();

  // === REAL LOADING SCREEN ===
  // Get loading UI elements
  const splashLoading = document.getElementById('splash-loading');
  const splashBtn = document.getElementById('splash-enter-btn');
  const loadingText = splashLoading?.querySelector('.loading-text');

  // Start preloading all systems in background
  // Minimum 800ms display time so user sees the loading screen (even with cached assets)
  const minDisplayTime = new Promise(resolve => setTimeout(resolve, 800));

  const preloadPromise = preloadAllSystems((completed, total, task) => {
    // Update loading text with progress
    if (loadingText) {
      const percent = Math.round((completed / total) * 100);
      loadingText.textContent = `Loading... ${percent}%`;
    }
  });

  // When BOTH preload completes AND minimum time passes, show the ENTER button
  Promise.all([preloadPromise, minDisplayTime]).then(() => {
    if (splashLoading) {
      splashLoading.style.display = 'none';
    }
    if (splashBtn) {
      splashBtn.style.display = '';
      // Trigger the appear animation
      splashBtn.style.opacity = '0';
      splashBtn.style.transform = 'translateY(10px)';
      requestAnimationFrame(() => {
        splashBtn.style.transition = 'opacity 0.4s ease-out, transform 0.4s ease-out';
        splashBtn.style.opacity = '1';
        splashBtn.style.transform = 'translateY(0)';
      });
    }
  });

  // === DEMO MODE UI TOGGLE ===
  // Show/hide UI elements based on IS_DEMO flag
  // Demo elements: splash label, footer, victory screen, wishlist buttons
  // Full game elements: skill tree button, achievements button
  const demoElements = [
    'demo-label',           // "DEMO" text on splash screen
    'demo-footer',          // Footer with demo copyright
    'wishlist-btn',         // Main menu wishlist button
    'pause-wishlist-btn',   // Pause menu wishlist button
    'victory-wishlist-btn', // Victory screen wishlist button
    'victory-overlay'       // Demo victory screen (Round 18 end)
  ];
  const fullGameElements = [
    'skill-tree-btn',       // Hero Skills button
    'achievements-btn'      // Achievements & Stats button
  ];

  demoElements.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.style.display = IS_DEMO ? '' : 'none';
  });

  fullGameElements.forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.disabled = IS_DEMO;
      el.style.opacity = IS_DEMO ? '0.5' : '';
      if (IS_DEMO) {
        // Add "(Full Game)" suffix if not already there
        if (!el.textContent.includes('(Full Game)')) {
          el.innerHTML += ' <span style="font-size:10px;opacity:0.7">(Full Game)</span>';
        }
      }
    }
  });

  // Add menu-active class to hide header until game starts
  document.body.classList.add('menu-active');

  // Load graphics settings first
  loadGfxSettings();

  // Floating spark/ember particle system - subtle rising embers (unless Low FX mode)
  if (!gfxSettings.lowFx) {
    sparkManager = new FloatingSparkManager();
  }

  // Initialize flame background mouse tracking
  initFlameMouseTracking();

  // Set flame to default intensity for main menu
  const flameBg = document.getElementById('flame-bg');
  if (flameBg) {
    flameBg.style.setProperty('--flame-opacity', '0.3');
    flameBg.style.setProperty('--flame-scale', '1.0');
  }

  // Initialize graphics settings UI
  initGfxSettingsListeners();

  // Splash screen - click button to enter and start audio/music
  const splash = document.getElementById('splash-screen');
  const splashEnterBtn = document.getElementById('splash-enter-btn');
  if (splash && splashEnterBtn) {
    // Preloading happens above - button appears when ready
    // Mark splash as ready once preload AND minimum display time complete
    Promise.all([preloadPromise, minDisplayTime]).then(() => {
      splash.classList.add('ready');
    });

    splashEnterBtn.addEventListener('click', async () => {
      // Block clicks until splash is ready (preload complete)
      if (!splash.classList.contains('ready')) return;

      // Disable button to prevent double-clicks
      splashEnterBtn.disabled = true;

      // Initialize audio on this user gesture (for samples/sfx)
      // Note: buffers are already decoded, this just sets up the context
      initAudio();

      // Play rarity sound on enter
      playSample('rarity.ogg', 0.7);

      // Start Tone.js music on ENTER
      await ensureMusicStarted();

      // Crossfade: splash dissolves out while main menu fades in
      const mainMenu = document.getElementById('main-menu');

      // Start main menu invisible but showing
      mainMenu.classList.add('crossfade', 'fading-in', 'show');

      // Start splash dissolve
      splash.classList.add('dissolving');

      // Trigger main menu fade-in on next frame
      requestAnimationFrame(() => {
        mainMenu.classList.remove('fading-in');
      });

      // Clean up splash after transition
      setTimeout(() => {
        splash.classList.remove('show', 'dissolving');
        mainMenu.classList.remove('crossfade');
      }, 800);
    });

    // Hover sound for splash button
    splashEnterBtn.onmouseenter = sfxHover;
  }

  const mm = document.getElementById('main-menu');
  const startBtn = document.getElementById('start-game-btn');
  const contBtn = document.getElementById('continue-btn');
  const exitBtn = document.getElementById('exit-btn');
  const achBtn = document.getElementById('achievements-btn');
  updateContinueButtons();
  if(contBtn){
    contBtn.onclick = async ()=>{
      // Load the saved run data first (clearRunState may have wiped current state)
      const loaded = await loadRunAsync();
      if(!loaded){
        console.warn('No valid save found');
        return;
      }

      if(mm)mm.classList.remove('show');
      document.body.classList.remove('menu-active');
      // Start music engine when continuing a run (also initializes Tone.js if needed)
      await ensureMusicStarted();

      // Clear forge selections to avoid loading mid-forge with random words
      clrSel();

      // Restore to the appropriate game phase
      if(S.gamePhase === 'shop'){
        // Player was in shop - show shop
        showShop();
      } else {
        // Player was in forge - generate fresh encounter and show forge
        newEnc();
        render();
      }
    };
    contBtn.onmouseenter=sfxHover;
  }
  if(startBtn){
    startBtn.onclick=async ()=>{
      // Prevent rapid clicking during transitions
      if(isTransitioning) return;
      // Unified transition: hide menu AND show hero select at peak
      await playSceneTransition(async () => {
        if(mm)mm.classList.remove('show');
        document.body.classList.remove('menu-active');
        // Initialize new run state AND show hero select at peak (while screen is black)
        await startNewRun();
      });
    };
    startBtn.onmouseenter=sfxHover;
  }
  if(exitBtn){
    exitBtn.onclick=()=>{
      if(mm)mm.classList.remove('show');
      // Only remove menu-active if there's an active run (game already started)
      if(S.hero && S.roundIndex > 0){
        document.body.classList.remove('menu-active');
      }
    };
    exitBtn.onmouseenter=sfxHover;
  }
  if(achBtn){
    achBtn.onclick=()=>{showOverlay('#achievements-overlay');playSfxOpen();renderStats();};
    achBtn.onmouseenter=sfxHover;
  }

  // Main menu Graphics Settings and Credits buttons
  const mainGfxBtn = document.getElementById('main-graphics-btn');
  if(mainGfxBtn){
    mainGfxBtn.onclick = () => {
      showOverlay('#graphics-settings');
      playSfxOpen();
    };
    mainGfxBtn.onmouseenter = sfxHover;
  }
  const mainCreditsBtn = document.getElementById('main-credits-btn');
  if(mainCreditsBtn){
    mainCreditsBtn.onclick = () => {
      showOverlay('#credits-overlay');
      playSfxOpen();
    };
    mainCreditsBtn.onmouseenter = sfxHover;
  }
  // Quit Game and Reset Data buttons (Electron app)
  const confirmModal = document.getElementById('confirm-modal');
  const confirmTitle = document.getElementById('confirm-title');
  const confirmMessage = document.getElementById('confirm-message');
  const confirmCancel = document.getElementById('confirm-cancel');
  const confirmYes = document.getElementById('confirm-yes');
  let confirmAction = null;

  // Helper to get current save location text for unsaved progress warning
  function getSaveLocationText() {
    if (!S.roundIndex || S.roundIndex < 1) return 'None';
    const round = S.roundIndex;
    const inShop = document.getElementById('shop-overlay')?.classList.contains('show');
    const inCombat = document.getElementById('combat-overlay')?.classList.contains('show');
    if (inShop) return `Round ${round} Shop`;
    if (inCombat) return `Round ${round} Battle`;
    return `Round ${round}`;
  }

  function showConfirmModal(title, message, action) {
    confirmTitle.textContent = title;
    confirmMessage.textContent = message;
    confirmAction = action;
    showOverlay(confirmModal);
    playSfxOpen();
  }

  function hideConfirmModal() {
    hideOverlay(confirmModal);
    confirmAction = null;
  }

  if(confirmCancel) {
    confirmCancel.onclick = () => { hideConfirmModal(); sfxClick(); };
    confirmCancel.onmouseenter = sfxHover;
  }
  if(confirmYes) {
    confirmYes.onclick = () => {
      sfxClick();
      if(confirmAction === 'quit') {
        // Close the Electron app
        if(window.electronAudio && window.electronAudio.isElectron) {
          window.close();
        } else {
          window.close();
        }
      } else if(confirmAction === 'title') {
        // Return to title screen
        hideConfirmModal();
        closePauseMenu();
        clearRunState();
        showMainMenu();
        return; // Don't call hideConfirmModal again
      } else if(confirmAction === 'reset') {
        // Clear all localStorage and reload
        localStorage.clear();
        location.reload();
      } else if(confirmAction === 'forfeit') {
        // Forfeit current run and cash out XP
        hideConfirmModal();
        executeForfeit();
        return;
      }
      hideConfirmModal();
    };
    confirmYes.onmouseenter = sfxHover;
  }

  // Forfeit button in forge
  const forfeitBtnInit = document.getElementById('forfeit-btn');
  if(forfeitBtnInit) {
    forfeitBtnInit.onclick = () => {
      const xpPreview = S.hero ? calcRunXP(S.roundIndex, false) : 0;
      showConfirmModal('Forfeit Run?', `End this run and receive ${xpPreview} XP.`, 'forfeit');
    };
    forfeitBtnInit.onmouseenter = sfxHover;
  }

  // Main menu quit button
  const mainQuitBtn = document.getElementById('main-quit-btn');
  if(mainQuitBtn) {
    mainQuitBtn.onclick = () => showConfirmModal('Quit Game?', 'Are you sure you want to quit?', 'quit');
    mainQuitBtn.onmouseenter = sfxHover;
  }

  // Pause menu quit button
  const pauseQuitBtn = document.getElementById('pause-quit-btn');
  if(pauseQuitBtn) {
    pauseQuitBtn.onclick = () => {
      if (S.roundIndex && S.roundIndex > 0) {
        const saveLocation = getSaveLocationText();
        showConfirmModal('Quit Game?', `Unsaved progress will be lost.\n\nLast save: ${saveLocation}`, 'quit');
      } else {
        showConfirmModal('Quit Game?', 'Are you sure you want to quit?', 'quit');
      }
    };
    pauseQuitBtn.onmouseenter = sfxHover;
  }

  // Pause menu wishlist button
  const pauseWishlistBtn = document.getElementById('pause-wishlist-btn');
  if(pauseWishlistBtn) {
    pauseWishlistBtn.onclick = () => { window.open(STEAM_WISHLIST_URL, '_blank'); };
    pauseWishlistBtn.onmouseenter = sfxHover;
  }

  // Settings modal reset data button
  const gfxResetBtn = document.getElementById('gfx-reset-data');
  if(gfxResetBtn) {
    gfxResetBtn.onclick = () => showConfirmModal('Reset Data?', 'This will erase all progress and unlocks. Are you sure?', 'reset');
    gfxResetBtn.onmouseenter = sfxHover;
  }

  // Skill Tree button
  const skillTreeBtn = document.getElementById('skill-tree-btn');
  if(skillTreeBtn){
    skillTreeBtn.onclick = () => {
      showSkillTree('Graham Moor');
    };
    skillTreeBtn.onmouseenter = sfxHover;
  }

  // Setup skill tree listeners
  setupSkillTreeListeners();

  // Victory screen button handlers (Demo version - wishlist instead of endless)
  const victoryWishlistBtn = document.getElementById('victory-wishlist-btn');
  const victoryNewRunBtn = document.getElementById('victory-newrun-btn');
  if(victoryWishlistBtn){
    victoryWishlistBtn.onclick = () => {
      window.open(STEAM_WISHLIST_URL, '_blank');
    };
    victoryWishlistBtn.onmouseenter=sfxHover;
  }
  if(victoryNewRunBtn){
    victoryNewRunBtn.onclick = async () => {
      if(isTransitioning) return;
      // Unified transition: hide victory AND start new run at peak
      await playSceneTransition(async () => {
        const victoryOverlay = document.getElementById('victory-overlay');
        if(victoryOverlay) victoryOverlay.classList.remove('show');
        // Reset embers to normal
        if (sparkManager) sparkManager.setColorMode('normal');
        // Initialize new run AND show hero select at peak
        await startNewRun();
      });
    };
    victoryNewRunBtn.onmouseenter=sfxHover;
  }

  // Main menu wishlist button (Demo)
  const wishlistBtn = document.getElementById('wishlist-btn');
  if(wishlistBtn){
    wishlistBtn.onclick = () => {
      window.open(STEAM_WISHLIST_URL, '_blank');
    };
    wishlistBtn.onmouseenter=sfxHover;
  }

  // Main menu Discord button (always shown)
  const discordBtn = document.getElementById('discord-btn');
  if(discordBtn){
    discordBtn.onclick = () => {
      window.open(DISCORD_URL, '_blank');
    };
    discordBtn.onmouseenter=sfxHover;
    // Subtle hover effect
    discordBtn.addEventListener('mouseenter', () => {
      discordBtn.style.opacity = '1';
    });
    discordBtn.addEventListener('mouseleave', () => {
      discordBtn.style.opacity = '0.7';
    });
  }

  // Pause menu Discord button (always shown)
  const pauseDiscordBtn = document.getElementById('pause-discord-btn');
  if(pauseDiscordBtn){
    pauseDiscordBtn.onclick = () => {
      window.open(DISCORD_URL, '_blank');
    };
    pauseDiscordBtn.onmouseenter=sfxHover;
    // Subtle hover effect
    pauseDiscordBtn.addEventListener('mouseenter', () => {
      pauseDiscordBtn.style.opacity = '1';
    });
    pauseDiscordBtn.addEventListener('mouseleave', () => {
      pauseDiscordBtn.style.opacity = '0.7';
    });
  }

  const pauseBtn=document.getElementById('pause-btn');
  if(pauseBtn){
    pauseBtn.onclick=()=>openPauseMenu(isShopOpen()?"shop":"run");
    pauseBtn.onmouseenter=sfxHover;
  }

  // Sound panel handlers
  const soundBtn = document.getElementById('sound-btn');
  const shopSoundBtn = document.getElementById('shop-sound-btn');
  const soundPanel = document.getElementById('sound-panel');
  const soundPanelClose = document.getElementById('sound-panel-close');

  const toggleSoundPanel = () => {
    const isHidden = soundPanel.classList.contains('hidden');
    soundPanel.classList.toggle('hidden');
    if (isHidden) {
      playSfxOpen();
    } else {
      playSfxBack();
    }
  };

  if (soundBtn && soundPanel) {
    soundBtn.onclick = toggleSoundPanel;
  }
  if (shopSoundBtn && soundPanel) {
    shopSoundBtn.onclick = toggleSoundPanel;
    shopSoundBtn.onmouseenter = sfxHover;
  }
  if (soundPanelClose && soundPanel) {
    soundPanelClose.onclick = () => { soundPanel.classList.add('hidden'); playSfxBack(); };
  }

  // Volume slider handlers
  const setupVolumeSlider = (id, onChange) => {
    const slider = document.getElementById(id);
    if (!slider) return;
    const valueSpan = slider.parentElement.querySelector('.vol-value');
    slider.oninput = () => {
      const val = parseInt(slider.value) / 100;
      if (valueSpan) valueSpan.textContent = slider.value + '%';
      onChange(val);
    };
  };

  setupVolumeSlider('vol-master', (val) => {
    volMaster = val;
    if (masterGain) masterGain.gain.value = val;
    if (musicEngine && musicEngine.masterGain) musicEngine.masterGain.gain.value = val * volMusic;
    saveAudioSettings();
  });
  setupVolumeSlider('vol-music', (val) => {
    volMusic = val;
    if (musicEngine) {
      if (musicEngine.masterGain) musicEngine.masterGain.gain.value = volMaster * val;
      // If turning volume back up and music isn't playing, start it (if in a run)
      if (val > 0 && musicEngine.initialized && !musicEngine.playing && S.hero) {
        musicEngine.start();
      }
    }
    saveAudioSettings();
  });
  setupVolumeSlider('vol-sfx', (val) => {
    volSfx = val;
    saveAudioSettings();
  });
  // Apply saved audio settings to sliders on load
  applyAudioSettings();
  $("#pause-continue").onclick=()=>closePauseMenu();
  $("#pause-continue").onmouseenter=sfxHover;
  $("#pause-new").onclick=async ()=>{
    // Full reset - clear all guards and state
    isTransitioning=false;
    isForging=false;
    // Unified transition: hide everything AND start new run at peak
    await playSceneTransition(async () => {
      // Force close shop overlay and exit shop mode
      const shopOverlay = document.getElementById('shop-overlay');
      if(shopOverlay) shopOverlay.classList.remove('show');
      if(musicEngine && musicEngine.inShopMode) musicEngine.exitShopMode();
      // Remove shop-hidden class from forge (restores pointer-events)
      const forgeEl = document.getElementById('forge');
      if(forgeEl) forgeEl.classList.remove('shop-hidden');
      // Clear selection before closing overlays
      clrSel();
      closeRunOverlays();
      // Initialize new run AND show hero select at peak
      await startNewRun();
    });
  };
  $("#pause-new").onmouseenter=sfxHover;
  $("#pause-achievements").onclick=()=>{closePauseMenu(true);showOverlay('#achievements-overlay');playSfxOpen();renderStats();};
  $("#pause-achievements").onmouseenter=sfxHover;
  $("#pause-graphics").onclick=()=>{closePauseMenu(true);openGraphicsSettings();};
  $("#pause-graphics").onmouseenter=sfxHover;
  $("#pause-credits").onclick=()=>{closePauseMenu(true);showOverlay('#credits-overlay');playSfxOpen();};
  $("#pause-credits").onmouseenter=sfxHover;
  $("#credits-close").onclick=()=>{document.getElementById('credits-overlay').classList.remove('show');playSfxBack();};
  $("#credits-close").onmouseenter=sfxHover;
  // Return to title screen
  $("#pause-title").onclick=()=>{
    if (S.roundIndex && S.roundIndex > 0) {
      const saveLocation = getSaveLocationText();
      showConfirmModal('Return to Title?', `Unsaved progress will be lost.\n\nLast save: ${saveLocation}`, 'title');
    } else {
      closePauseMenu();
      showMainMenu();
    }
  };
  $("#pause-title").onmouseenter=sfxHover;
  const shopMenuBtn=document.getElementById('shop-menu');
  if(shopMenuBtn){shopMenuBtn.onclick=()=>openPauseMenu('shop');shopMenuBtn.onmouseenter=sfxHover;}
  const resetBtn=document.getElementById('stats-reset');
  if(resetBtn){
    resetBtn.onclick=()=>{
      PStats={attempts:0,victories:0,weaponsForged:0,bestDamage:0,bestWeaponName:"",heroClears:{},highestRound:0,tutorialComplete:false,bossDefeats:{},unlockedHeroes: IS_DEMO ? ['Graham Moor', 'Quivera'] : ['Graham Moor']};
      saveStats();
      clearRunSave();
      renderStats();
    };
    resetBtn.onmouseenter=sfxHover;
  }
  $("#achievements-close").onclick=()=>{document.getElementById('achievements-overlay').classList.remove('show');playSfxBack();};
  $("#achievements-close").onmouseenter=sfxHover;

  // Talent viewer handlers
  $("#view-talents-btn").onclick = () => {
    openTalentViewer();
  };
  $("#view-talents-btn").onmouseenter=sfxHover;
  $("#talent-viewer-close").onclick = () => {
    document.getElementById('talent-viewer-overlay').classList.remove('show');
    playSfxBack(); // "Back" sound
  };
  $("#talent-viewer-close").onmouseenter=sfxHover;

  // Talent selection screen - view talents button
  const talentSelectViewBtn = document.getElementById('talent-select-view-btn');
  if(talentSelectViewBtn){
    talentSelectViewBtn.onclick = () => openTalentViewer();
    talentSelectViewBtn.onmouseenter = sfxHover;
  }

  // Add Enter key handler for Forge Weapon button
  document.addEventListener('keydown', (e) => {
    if(e.key === 'Enter'){
      const forgeBtn = document.getElementById('forge-btn');
      if(forgeBtn && !forgeBtn.disabled){
        forgeBtn.click();
      }
    }
  });

  // Portrait click handlers - cycle through dialogue with talking sound
  const heroPortrait = document.querySelector('.hero-portrait');
  const enemyPortrait = document.querySelector('.enemy-portrait');

  // Word-by-word dialogue animation
  let heroDialogueAnimId = null;
  let enemyDialogueAnimId = null;

  function animateDialogueWords(element, text, portrait, soundType, onComplete) {
    if(!element) return null;
    const words = text.split(' ');
    let currentIndex = 0;
    element.textContent = '';

    function showNextWord() {
      if(currentIndex < words.length) {
        if(currentIndex > 0) element.textContent += ' ';
        element.textContent += words[currentIndex];
        currentIndex++;

        // Play talk sound and wiggle for each word (synced to 1/8 note)
        playTalkSound(soundType);
        portrait.classList.add('speaking');
        setTimeout(() => portrait.classList.remove('speaking'), RHYTHM.QUARTER);

        return setTimeout(showNextWord, RHYTHM.HALF);
      } else {
        if(onComplete) onComplete();
        return null;
      }
    }

    return showNextWord();
  }

  if(heroPortrait){
    heroPortrait.style.cursor = 'pointer';
    heroPortrait.onclick = (e) => {
      // Skip babble if clicking the talents button
      if(e.target.closest('#view-talents-btn')) return;
      if(!S.hero || !S.hero.dialogue || S.hero.dialogue.length === 0) return;
      // Cancel any ongoing animation
      if(heroDialogueAnimId) {
        clearTimeout(heroDialogueAnimId);
        heroDialogueAnimId = null;
      }
      // Initialize dialogue index if not set
      if(S.heroDialogueIndex === undefined) S.heroDialogueIndex = 0;
      // Cycle to next dialogue
      S.heroDialogueIndex = (S.heroDialogueIndex + 1) % S.hero.dialogue.length;
      const line = S.hero.dialogue[S.heroDialogueIndex];
      // Animate the inline dialogue word by word
      const inlineEl = document.getElementById('hero-inline-dialogue');
      heroDialogueAnimId = animateDialogueWords(inlineEl, line, heroPortrait, 'hero', () => {
        heroDialogueAnimId = null;
      });
    };
  }

  if(enemyPortrait){
    enemyPortrait.style.cursor = 'pointer';
    enemyPortrait.onclick = () => {
      if(!S.enemy || !S.enemy.dialogue || S.enemy.dialogue.length === 0) return;
      // Cancel any ongoing animation
      if(enemyDialogueAnimId) {
        clearTimeout(enemyDialogueAnimId);
        enemyDialogueAnimId = null;
      }
      // Initialize dialogue index if not set
      if(S.enemyDialogueIndex === undefined) S.enemyDialogueIndex = 0;
      // Cycle to next dialogue
      S.enemyDialogueIndex = (S.enemyDialogueIndex + 1) % S.enemy.dialogue.length;
      const line = S.enemy.dialogue[S.enemyDialogueIndex];
      // Animate the inline dialogue word by word
      const inlineEl = document.getElementById('enemy-inline-dialogue');
      enemyDialogueAnimId = animateDialogueWords(inlineEl, line, enemyPortrait, 'enemy', () => {
        enemyDialogueAnimId = null;
      });
    };
  }

  // Logo click handlers - bounce animation and sound
  document.querySelectorAll('.logo-img').forEach(logo => {
    logo.addEventListener('click', (e) => {
      e.preventDefault();
      // Play a fun sound
      playSample('gem.ogg', 0.1);
      // Add bounce animation (double-rAF avoids forced reflow)
      logo.classList.remove('logo-bounce');
      requestAnimationFrame(() => {
        requestAnimationFrame(() => logo.classList.add('logo-bounce'));
      });
    });
    // Prevent drag
    logo.addEventListener('dragstart', (e) => e.preventDefault());
  });
});

// Call init immediately to ensure the game initializes even if DOMContentLoaded has already fired.
// Without this call, the inventory and event handlers may not set up if this script loads after
// the DOM has already completed parsing.
init();

// ========================================
// DEBUG PERFORMANCE MONITOR (F3 to toggle)
// ========================================
(function() {
  const debugOverlay = document.getElementById('debug-overlay');
  const debugCopyBtn = document.getElementById('debug-copy-log');
  if (!debugOverlay) return;

  // Performance tracking state
  let debugEnabled = false;
  let frameCount = 0;
  let lastTime = performance.now();
  let lastFpsUpdate = performance.now();
  let fps = 0;
  let minFps = Infinity;
  let maxFps = 0;
  let frameTimes = [];
  let performanceLog = [];
  let eventLog = []; // Custom event log for word slotting, etc.
  let logInterval = null;
  let animFrameId = null;

  // Expose global function for logging custom events (word slotting, etc.)
  window.logPerfEvent = function(eventType, details) {
    if (!debugEnabled) return;
    const event = {
      time: new Date().toISOString().substr(11, 12),
      type: eventType,
      ...details
    };
    eventLog.push(event);
    if (eventLog.length > 100) eventLog.shift();
  };

  // DOM element refs
  const fpsEl = document.getElementById('debug-fps');
  const frameTimeEl = document.getElementById('debug-frame-time');
  const fpsRangeEl = document.getElementById('debug-fps-range');
  const avgFrameEl = document.getElementById('debug-avg-frame');
  const memoryEl = document.getElementById('debug-memory');
  const particlesEl = document.getElementById('debug-particles');
  const domEl = document.getElementById('debug-dom');
  const sceneEl = document.getElementById('debug-scene');
  const logStatusEl = document.getElementById('debug-log-status');

  // Get current scene name
  function getCurrentScene() {
    if (document.querySelector('#splash-screen.show')) return 'Splash';
    if (document.querySelector('#main-menu.show')) return 'MainMenu';
    if (document.querySelector('#hero-select-overlay.show')) return 'HeroSelect';
    if (document.querySelector('#shop-overlay.show')) return 'Shop';
    if (document.querySelector('#combat-overlay.show')) return 'Combat';
    if (document.querySelector('#talent-overlay.show')) return 'Talents';
    if (document.querySelector('#victory-overlay.show')) return 'Victory';
    if (document.querySelector('#loss-overlay.show')) return 'Loss';
    if (document.querySelector('#pause-menu.show')) return 'Pause';
    return 'Gameplay';
  }

  // Count active particles
  function countParticles() {
    let count = 0;
    if (typeof sparkManager !== 'undefined' && sparkManager && sparkManager.sparks) {
      count += sparkManager.sparks.length;
    }
    if (typeof emberManager !== 'undefined' && emberManager && emberManager.embers) {
      count += emberManager.embers.length;
    }
    count += document.querySelectorAll('.aura-particle, .flame-particle, .health-shard').length;
    return count;
  }

  // Get memory info (Chrome/Electron only)
  function getMemoryMB() {
    if (performance.memory) {
      return (performance.memory.usedJSHeapSize / 1048576).toFixed(1);
    }
    return '--';
  }

  // Update display
  function updateDebugDisplay(frameTime) {
    const currentFps = Math.round(fps);

    if (currentFps > 0 && currentFps < 1000) {
      minFps = Math.min(minFps, currentFps);
      maxFps = Math.max(maxFps, currentFps);
    }

    frameTimes.push(frameTime);
    if (frameTimes.length > 60) frameTimes.shift();
    const avgFrameTime = frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length;

    fpsEl.textContent = currentFps;
    fpsEl.className = currentFps < 30 ? 'debug-bad' : currentFps < 55 ? 'debug-warn' : '';

    frameTimeEl.textContent = frameTime.toFixed(1) + ' ms';
    frameTimeEl.className = frameTime > 33 ? 'debug-bad' : frameTime > 18 ? 'debug-warn' : '';

    fpsRangeEl.textContent = (minFps === Infinity ? '--' : minFps) + ' - ' + (maxFps === 0 ? '--' : maxFps);
    avgFrameEl.textContent = avgFrameTime.toFixed(1) + ' ms';
    memoryEl.textContent = getMemoryMB() + ' MB';
    particlesEl.textContent = countParticles();
    domEl.textContent = document.querySelectorAll('*').length;
    sceneEl.textContent = getCurrentScene();
  }

  // Main update loop
  function debugLoop(now) {
    if (!debugEnabled) return;

    frameCount++;
    const frameTime = now - lastTime;
    lastTime = now;

    if (now - lastFpsUpdate >= 500) {
      fps = frameCount * 1000 / (now - lastFpsUpdate);
      frameCount = 0;
      lastFpsUpdate = now;
    }

    updateDebugDisplay(frameTime);
    animFrameId = requestAnimationFrame(debugLoop);
  }

  // Log snapshot every 2 seconds
  function logSnapshot() {
    const snapshot = {
      time: new Date().toISOString().substr(11, 8),
      scene: getCurrentScene(),
      fps: Math.round(fps),
      minFps: minFps === Infinity ? 0 : minFps,
      maxFps: maxFps,
      avgFrame: (frameTimes.length > 0 ? frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length : 0).toFixed(1),
      memory: getMemoryMB(),
      particles: countParticles(),
      dom: document.querySelectorAll('*').length
    };
    performanceLog.push(snapshot);
    if (performanceLog.length > 60) performanceLog.shift();
    logStatusEl.textContent = `Logging: ${performanceLog.length} snapshots`;
  }

  // Generate log text for pasting
  function generateLogText() {
    let text = '=== WORDY WEAPON PERFORMANCE LOG ===\n';
    text += `Generated: ${new Date().toISOString()}\n`;
    text += `Platform: ${navigator.platform}\n`;
    text += `UserAgent: ${navigator.userAgent.substring(0, 100)}\n`;
    text += `Screen: ${window.screen.width}x${window.screen.height} @ ${window.devicePixelRatio}x DPR\n`;
    text += `Window: ${window.innerWidth}x${window.innerHeight}\n\n`;

    text += 'TIME     | SCENE       | FPS | MIN | MAX | AVG ms | MEM MB | PART | DOM\n';
    text += '-'.repeat(75) + '\n';

    performanceLog.forEach(s => {
      text += `${s.time} | ${s.scene.padEnd(11)} | ${String(s.fps).padStart(3)} | ${String(s.minFps).padStart(3)} | ${String(s.maxFps).padStart(3)} | ${String(s.avgFrame).padStart(6)} | ${String(s.memory).padStart(6)} | ${String(s.particles).padStart(4)} | ${s.dom}\n`;
    });

    text += '\n=== SUMMARY ===\n';
    if (performanceLog.length > 0) {
      const avgFps = performanceLog.reduce((a, s) => a + s.fps, 0) / performanceLog.length;
      const overallMin = Math.min(...performanceLog.map(s => s.minFps).filter(v => v > 0));
      const overallMax = Math.max(...performanceLog.map(s => s.maxFps));
      const avgMem = performanceLog.reduce((a, s) => a + parseFloat(s.memory || 0), 0) / performanceLog.length;
      const maxParticles = Math.max(...performanceLog.map(s => s.particles));
      text += `Avg FPS: ${avgFps.toFixed(1)}\n`;
      text += `FPS Range: ${overallMin || 0} - ${overallMax}\n`;
      text += `Avg Memory: ${avgMem.toFixed(1)} MB\n`;
      text += `Max Particles: ${maxParticles}\n`;
      text += `Samples: ${performanceLog.length} (2s intervals)\n`;

      // Flag any issues
      const lowFpsCount = performanceLog.filter(s => s.fps < 30).length;
      const stutterCount = performanceLog.filter(s => parseFloat(s.avgFrame) > 33).length;
      if (lowFpsCount > 0) text += `\n‚ö†Ô∏è LOW FPS (<30): ${lowFpsCount} samples\n`;
      if (stutterCount > 0) text += `‚ö†Ô∏è STUTTER (>33ms): ${stutterCount} samples\n`;
    }

    // Add event log section for word slotting and other custom events
    if (eventLog.length > 0) {
      text += '\n=== WORD SLOT EVENTS ===\n';
      text += 'TIME         | EVENT           | DETAILS\n';
      text += '-'.repeat(70) + '\n';
      eventLog.forEach(e => {
        const details = Object.entries(e)
          .filter(([k]) => k !== 'time' && k !== 'type')
          .map(([k, v]) => `${k}=${typeof v === 'number' ? v.toFixed(2) : v}`)
          .join(', ');
        text += `${e.time} | ${e.type.padEnd(15)} | ${details}\n`;
      });

      // Summarize slow events
      const slowEvents = eventLog.filter(e => e.totalMs && e.totalMs > 16);
      if (slowEvents.length > 0) {
        text += `\n‚ö†Ô∏è SLOW SLOT EVENTS (>16ms): ${slowEvents.length}\n`;
        slowEvents.forEach(e => {
          text += `  - ${e.time}: ${e.totalMs.toFixed(1)}ms (${e.word || 'unknown'})\n`;
        });
      }
    }

    return text;
  }

  // Toggle debug overlay with F3
  document.addEventListener('keydown', (e) => {
    if (e.key === 'F3') {
      e.preventDefault();
      debugEnabled = !debugEnabled;
      debugOverlay.classList.toggle('hidden', !debugEnabled);

      if (debugEnabled) {
        minFps = Infinity;
        maxFps = 0;
        frameTimes = [];
        performanceLog = [];
        eventLog = []; // Clear custom event log
        lastTime = performance.now();
        lastFpsUpdate = performance.now();
        frameCount = 0;

        animFrameId = requestAnimationFrame(debugLoop);
        logInterval = setInterval(logSnapshot, 2000);
        logStatusEl.textContent = 'Logging started...';
      } else {
        if (animFrameId) cancelAnimationFrame(animFrameId);
        if (logInterval) clearInterval(logInterval);
        logStatusEl.textContent = '';
      }
    }
  });

  // Copy log button
  debugCopyBtn.addEventListener('click', () => {
    const logText = generateLogText();
    navigator.clipboard.writeText(logText).then(() => {
      debugCopyBtn.textContent = 'Copied!';
      setTimeout(() => { debugCopyBtn.textContent = 'Copy Log'; }, 1500);
    }).catch(() => {
      const textarea = document.createElement('textarea');
      textarea.value = logText;
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand('copy');
      document.body.removeChild(textarea);
      debugCopyBtn.textContent = 'Copied!';
      setTimeout(() => { debugCopyBtn.textContent = 'Copy Log'; }, 1500);
    });
  });
})();
